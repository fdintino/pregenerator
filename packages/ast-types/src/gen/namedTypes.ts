// !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!!
import { Omit } from "../types";
import { Type } from "../lib/types";
import * as K from "./kinds";
export namespace namedTypes {
  export type Node =
    | BinaryExpression
    | AssignmentExpression
    | AwaitExpression
    | ForOfStatement
    | ObjectExpression
    | ObjectMethod
    | ObjectProperty
    | SpreadElement
    | TemplateElement
    | CatchClause
    | Identifier
    | ArrayPattern
    | ObjectPattern
    | ImportExpression
    | ExportAllDeclaration
    | CallExpression
    | MemberExpression
    | ChainExpression
    | OptionalCallExpression
    | OptionalMemberExpression
    | LogicalExpression
    | Decorator
    | Property
    | MethodDefinition
    | PrivateName
    | ClassPrivateProperty
    | File
    | Program
    | BlockStatement
    | EmptyStatement
    | ExpressionStatement
    | IfStatement
    | LabeledStatement
    | BreakStatement
    | ContinueStatement
    | WithStatement
    | SwitchStatement
    | SwitchCase
    | ReturnStatement
    | ThrowStatement
    | TryStatement
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | VariableDeclaration
    | ForInStatement
    | DebuggerStatement
    | FunctionDeclaration
    | FunctionExpression
    | VariableDeclarator
    | ThisExpression
    | ArrayExpression
    | SequenceExpression
    | UnaryExpression
    | UpdateExpression
    | ConditionalExpression
    | NewExpression
    | RestElement
    | ArrowFunctionExpression
    | YieldExpression
    | GeneratorExpression
    | ComprehensionBlock
    | ComprehensionExpression
    | AssignmentPattern
    | ClassPropertyDefinition
    | ClassProperty
    | ClassBody
    | ClassDeclaration
    | ClassExpression
    | Super
    | ImportSpecifier
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportDeclaration
    | ExportNamedDeclaration
    | ExportSpecifier
    | ExportDefaultDeclaration
    | TaggedTemplateExpression
    | TemplateLiteral
    | MetaProperty
    | JSXAttribute
    | JSXIdentifier
    | JSXNamespacedName
    | JSXExpressionContainer
    | JSXElement
    | JSXFragment
    | JSXMemberExpression
    | JSXSpreadAttribute
    | JSXEmptyExpression
    | JSXText
    | JSXSpreadChild
    | JSXOpeningElement
    | JSXClosingElement
    | JSXOpeningFragment
    | JSXClosingFragment
    | TypeAnnotation
    | TSTypeAnnotation
    | TypeParameterDeclaration
    | TSTypeParameterDeclaration
    | ClassMethod
    | ClassPrivateMethod
    | TypeParameterInstantiation
    | TSTypeParameterInstantiation
    | ClassImplements
    | TSExpressionWithTypeArguments
    | AnyTypeAnnotation
    | EmptyTypeAnnotation
    | MixedTypeAnnotation
    | VoidTypeAnnotation
    | SymbolTypeAnnotation
    | NumberTypeAnnotation
    | BigIntTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumericLiteralTypeAnnotation
    | BigIntLiteralTypeAnnotation
    | StringTypeAnnotation
    | StringLiteralTypeAnnotation
    | BooleanTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | NullableTypeAnnotation
    | NullLiteralTypeAnnotation
    | NullTypeAnnotation
    | ThisTypeAnnotation
    | ExistsTypeAnnotation
    | ExistentialTypeParam
    | FunctionTypeAnnotation
    | FunctionTypeParam
    | ArrayTypeAnnotation
    | ObjectTypeAnnotation
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty
    | ObjectTypeIndexer
    | ObjectTypeCallProperty
    | ObjectTypeInternalSlot
    | Variance
    | QualifiedTypeIdentifier
    | GenericTypeAnnotation
    | MemberTypeAnnotation
    | UnionTypeAnnotation
    | IntersectionTypeAnnotation
    | TypeofTypeAnnotation
    | TypeParameter
    | InterfaceTypeAnnotation
    | InterfaceExtends
    | InterfaceDeclaration
    | TypeAlias
    | DeclareTypeAlias
    | OpaqueType
    | DeclareOpaqueType
    | TypeCastExpression
    | TupleTypeAnnotation
    | DeclareVariable
    | DeclareFunction
    | DeclareClass
    | DeclareModule
    | DeclareModuleExports
    | DeclareExportDeclaration
    | ExportBatchSpecifier
    | DeclareExportAllDeclaration
    | InferredPredicate
    | DeclaredPredicate
    | EnumDeclaration
    | ExportDeclaration
    | Noop
    | DoExpression
    | BindExpression
    | ParenthesizedExpression
    | ExportNamespaceSpecifier
    | ExportDefaultSpecifier
    | Directive
    | DirectiveLiteral
    | InterpreterDirective
    | StringLiteral
    | NumericLiteral
    | BigIntLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | ForAwaitStatement
    | Import
    | TSQualifiedName
    | TSTypeReference
    | TSAsExpression
    | TSNonNullExpression
    | TSAnyKeyword
    | TSBigIntKeyword
    | TSBooleanKeyword
    | TSNeverKeyword
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSUndefinedKeyword
    | TSUnknownKeyword
    | TSVoidKeyword
    | TSThisType
    | TSArrayType
    | TSLiteralType
    | TSUnionType
    | TSIntersectionType
    | TSConditionalType
    | TSInferType
    | TSTypeParameter
    | TSParenthesizedType
    | TSFunctionType
    | TSConstructorType
    | TSDeclareFunction
    | TSDeclareMethod
    | TSMappedType
    | TSTupleType
    | TSNamedTupleMember
    | TSRestType
    | TSOptionalType
    | TSIndexedAccessType
    | TSTypeOperator
    | TSIndexSignature
    | TSPropertySignature
    | TSMethodSignature
    | TSTypePredicate
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSEnumMember
    | TSTypeQuery
    | TSImportType
    | TSTypeLiteral
    | TSTypeAssertion
    | TSEnumDeclaration
    | TSTypeAliasDeclaration
    | TSModuleBlock
    | TSModuleDeclaration
    | TSImportEqualsDeclaration
    | TSExternalModuleReference
    | TSExportAssignment
    | TSNamespaceExportDeclaration
    | TSInterfaceBody
    | TSInterfaceDeclaration
    | TSParameterProperty;
  export type Expression =
    | BinaryExpression
    | AssignmentExpression
    | AwaitExpression
    | ObjectExpression
    | Identifier
    | ImportExpression
    | CallExpression
    | MemberExpression
    | ChainExpression
    | OptionalCallExpression
    | OptionalMemberExpression
    | LogicalExpression
    | PrivateName
    | FunctionExpression
    | ThisExpression
    | ArrayExpression
    | SequenceExpression
    | UnaryExpression
    | UpdateExpression
    | ConditionalExpression
    | NewExpression
    | ArrowFunctionExpression
    | YieldExpression
    | GeneratorExpression
    | ComprehensionExpression
    | ClassExpression
    | Super
    | TaggedTemplateExpression
    | TemplateLiteral
    | MetaProperty
    | JSXElement
    | JSXFragment
    | TypeCastExpression
    | DoExpression
    | BindExpression
    | ParenthesizedExpression
    | DirectiveLiteral
    | StringLiteral
    | NumericLiteral
    | BigIntLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | Import
    | TSAsExpression
    | TSNonNullExpression
    | TSTypeAssertion;
  export type Binary = BinaryExpression | LogicalExpression;
  export type Scopable =
    | ForOfStatement
    | ObjectMethod
    | CatchClause
    | Program
    | BlockStatement
    | SwitchStatement
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | ForInStatement
    | FunctionDeclaration
    | FunctionExpression
    | ArrowFunctionExpression
    | ClassDeclaration
    | ClassExpression
    | ClassMethod
    | ClassPrivateMethod;
  export type BlockParent =
    | ObjectMethod
    | CatchClause
    | Program
    | BlockStatement
    | SwitchStatement
    | FunctionDeclaration
    | FunctionExpression
    | ArrowFunctionExpression
    | ClassMethod
    | ClassPrivateMethod;
  export type Function =
    | ObjectMethod
    | FunctionDeclaration
    | FunctionExpression
    | ArrowFunctionExpression
    | ClassMethod
    | ClassPrivateMethod;
  export type Statement =
    | ForOfStatement
    | ExportAllDeclaration
    | MethodDefinition
    | ClassPrivateProperty
    | BlockStatement
    | EmptyStatement
    | ExpressionStatement
    | IfStatement
    | LabeledStatement
    | BreakStatement
    | ContinueStatement
    | WithStatement
    | SwitchStatement
    | ReturnStatement
    | ThrowStatement
    | TryStatement
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | VariableDeclaration
    | ForInStatement
    | DebuggerStatement
    | FunctionDeclaration
    | ClassPropertyDefinition
    | ClassProperty
    | ClassBody
    | ClassDeclaration
    | ImportDeclaration
    | ExportNamedDeclaration
    | ExportDefaultDeclaration
    | TSTypeParameterDeclaration
    | InterfaceDeclaration
    | TypeAlias
    | DeclareTypeAlias
    | OpaqueType
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareFunction
    | DeclareClass
    | DeclareModule
    | DeclareModuleExports
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | EnumDeclaration
    | ExportDeclaration
    | Noop
    | ForAwaitStatement
    | TSDeclareFunction
    | TSDeclareMethod
    | TSEnumDeclaration
    | TSTypeAliasDeclaration
    | TSModuleDeclaration
    | TSImportEqualsDeclaration
    | TSExportAssignment
    | TSNamespaceExportDeclaration
    | TSInterfaceDeclaration;
  export type Loop =
    | ForOfStatement
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | ForInStatement;
  export type For = ForOfStatement | ForStatement | ForInStatement;
  export type ForX = ForOfStatement | ForInStatement;
  export type FunctionParent =
    | ObjectMethod
    | FunctionDeclaration
    | FunctionExpression
    | ArrowFunctionExpression
    | ClassMethod
    | ClassPrivateMethod;
  export type PatternLike =
    | Identifier
    | ArrayPattern
    | ObjectPattern
    | RestElement
    | AssignmentPattern;
  export type LVal =
    | Identifier
    | ArrayPattern
    | ObjectPattern
    | MemberExpression
    | OptionalMemberExpression
    | RestElement
    | AssignmentPattern
    | TSParameterProperty;
  export type Pattern = ArrayPattern | ObjectPattern | AssignmentPattern;
  export type Declaration =
    | ExportAllDeclaration
    | MethodDefinition
    | ClassPrivateProperty
    | VariableDeclaration
    | FunctionDeclaration
    | ClassPropertyDefinition
    | ClassProperty
    | ClassBody
    | ClassDeclaration
    | ImportDeclaration
    | ExportNamedDeclaration
    | ExportDefaultDeclaration
    | TSTypeParameterDeclaration
    | InterfaceDeclaration
    | TypeAlias
    | DeclareTypeAlias
    | OpaqueType
    | DeclareOpaqueType
    | DeclareClass
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | EnumDeclaration
    | ExportDeclaration
    | TSDeclareFunction
    | TSDeclareMethod
    | TSEnumDeclaration
    | TSTypeAliasDeclaration
    | TSModuleDeclaration
    | TSInterfaceDeclaration;
  export type Pureish =
    | FunctionDeclaration
    | FunctionExpression
    | StringLiteral
    | NumericLiteral
    | BigIntLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral;
  export type Literal =
    | StringLiteral
    | NumericLiteral
    | BigIntLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral;
  export type ChainElement = CallExpression | MemberExpression;
  export type Comment = Block | Line | CommentBlock | CommentLine;
  export type Conditional = IfStatement | ConditionalExpression;
  export type CompletionStatement =
    | BreakStatement
    | ContinueStatement
    | ReturnStatement
    | ThrowStatement;
  export type While = WhileStatement | DoWhileStatement;
  export type Class = ClassDeclaration | ClassExpression;
  export type Specifier =
    | ImportSpecifier
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ExportSpecifier
    | ExportBatchSpecifier
    | ExportNamespaceSpecifier
    | ExportDefaultSpecifier;
  export type ModuleSpecifier =
    | ImportSpecifier
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ExportSpecifier;
  export type JSX =
    | JSXAttribute
    | JSXIdentifier
    | JSXNamespacedName
    | JSXExpressionContainer
    | JSXElement
    | JSXFragment
    | JSXMemberExpression
    | JSXSpreadAttribute
    | JSXEmptyExpression
    | JSXText
    | JSXSpreadChild
    | JSXOpeningElement
    | JSXClosingElement
    | JSXOpeningFragment
    | JSXClosingFragment;
  export type TSType =
    | TSExpressionWithTypeArguments
    | TSTypeReference
    | TSAnyKeyword
    | TSBigIntKeyword
    | TSBooleanKeyword
    | TSNeverKeyword
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSUndefinedKeyword
    | TSUnknownKeyword
    | TSVoidKeyword
    | TSThisType
    | TSArrayType
    | TSLiteralType
    | TSUnionType
    | TSIntersectionType
    | TSConditionalType
    | TSInferType
    | TSParenthesizedType
    | TSFunctionType
    | TSConstructorType
    | TSMappedType
    | TSTupleType
    | TSNamedTupleMember
    | TSRestType
    | TSOptionalType
    | TSIndexedAccessType
    | TSTypeOperator
    | TSTypePredicate
    | TSTypeQuery
    | TSImportType
    | TSTypeLiteral;
  export type Flow =
    | AnyTypeAnnotation
    | EmptyTypeAnnotation
    | MixedTypeAnnotation
    | VoidTypeAnnotation
    | SymbolTypeAnnotation
    | NumberTypeAnnotation
    | BigIntTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumericLiteralTypeAnnotation
    | BigIntLiteralTypeAnnotation
    | StringTypeAnnotation
    | StringLiteralTypeAnnotation
    | BooleanTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | NullableTypeAnnotation
    | NullLiteralTypeAnnotation
    | NullTypeAnnotation
    | ThisTypeAnnotation
    | ExistsTypeAnnotation
    | ExistentialTypeParam
    | FunctionTypeAnnotation
    | ArrayTypeAnnotation
    | ObjectTypeAnnotation
    | GenericTypeAnnotation
    | MemberTypeAnnotation
    | UnionTypeAnnotation
    | IntersectionTypeAnnotation
    | TypeofTypeAnnotation
    | TypeParameter
    | InterfaceTypeAnnotation
    | TupleTypeAnnotation
    | InferredPredicate
    | DeclaredPredicate;
  export type TSTypeElement =
    | TSIndexSignature
    | TSPropertySignature
    | TSMethodSignature
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration;
  export interface BaseNode {
    type: string;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }
  export interface BinaryExpression extends BaseNode {
    operator:
      | "=="
      | "!="
      | "==="
      | "!=="
      | "<"
      | "<="
      | ">"
      | ">="
      | "<<"
      | ">>"
      | ">>>"
      | "+"
      | "-"
      | "*"
      | "/"
      | "%"
      | "&"
      | "|"
      | "^"
      | "in"
      | "instanceof";
    left: Expression;
    right: Expression;
    type: "BinaryExpression";
  }
  export interface AssignmentExpression extends BaseNode {
    operator:
      | "="
      | "+="
      | "-="
      | "*="
      | "/="
      | "%="
      | "<<="
      | ">>="
      | ">>>="
      | "|="
      | "^="
      | "&=";
    left: LVal;
    right: Expression;
    type: "AssignmentExpression";
  }
  export interface BaseFunction extends BaseNode {
    async?: boolean;
    id?: namedTypes.Identifier | null;
    params: namedTypes.PatternLike[];
    body: BlockStatement;
    generator?: boolean;
    expression?: boolean;
    defaults: (namedTypes.Expression | null)[];
    rest?: namedTypes.Identifier | null;
    predicate?: namedTypes.FlowPredicate | null;
  }
  export interface AwaitExpression extends BaseNode {
    argument: namedTypes.Expression | null;
    all?: boolean;
    type: "AwaitExpression";
  }
  export interface ForOfStatement extends BaseNode {
    await?: boolean;
    left: namedTypes.VariableDeclaration | namedTypes.LVal;
    right: Expression;
    body: Statement;
    type: "ForOfStatement";
  }
  export interface ObjectExpression extends BaseNode {
    properties: (
      | namedTypes.Property
      | namedTypes.ObjectMethod
      | namedTypes.ObjectProperty
      | namedTypes.SpreadElement
    )[];
    type: "ObjectExpression";
  }
  export interface ObjectMethod
    extends Omit<BaseFunction, "params" | "body" | "generator" | "async"> {
    returnType?: namedTypes.TypeAnnotation | namedTypes.TSTypeAnnotation | null;
    typeParameters?:
      | namedTypes.TypeParameterDeclaration
      | namedTypes.TSTypeParameterDeclaration
      | null;
    kind: "method" | "get" | "set";
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    params: namedTypes.PatternLike[];
    body: BlockStatement;
    computed?: boolean;
    generator?: boolean;
    async?: boolean;
    accessibility?: namedTypes.Literal | null;
    decorators?: namedTypes.Decorator[] | null;
    type: "ObjectMethod";
  }
  export interface ObjectProperty extends BaseNode {
    shorthand?: boolean;
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    value: namedTypes.Expression | namedTypes.PatternLike;
    accessibility?: namedTypes.Literal | null;
    computed?: boolean;
    type: "ObjectProperty";
  }
  export interface SpreadElement extends BaseNode {
    argument: Expression;
    type: "SpreadElement";
  }
  export interface TemplateElement extends BaseNode {
    value: { cooked: string; raw: string };
    tail: boolean;
    type: "TemplateElement";
  }
  export interface CatchClause extends BaseNode {
    param:
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
      | namedTypes.Identifier
      | null;
    guard?: namedTypes.Expression | null;
    body: BlockStatement;
    type: "CatchClause";
  }
  export interface Identifier extends BaseNode {
    name: string;
    optional?: boolean;
    typeAnnotation?:
      | namedTypes.TypeAnnotation
      | namedTypes.TSTypeAnnotation
      | null;
    type: "Identifier";
  }
  export interface ArrayPattern extends BaseNode {
    elements: (namedTypes.PatternLike | null)[];
    type: "ArrayPattern";
  }
  export interface ObjectPattern extends BaseNode {
    properties: (namedTypes.Property | namedTypes.ObjectProperty)[];
    typeAnnotation?:
      | namedTypes.TypeAnnotation
      | namedTypes.TSTypeAnnotation
      | null;
    decorators?: namedTypes.Decorator[] | null;
    type: "ObjectPattern";
  }
  export interface ImportExpression extends BaseNode {
    source: Expression;
    type: "ImportExpression";
  }
  export interface ExportAllDeclaration extends BaseNode {
    source: Literal;
    exported: namedTypes.Identifier | null;
    type: "ExportAllDeclaration";
  }
  export interface CallExpression extends BaseNode {
    optional?: boolean;
    callee: Expression;
    arguments: (namedTypes.Expression | namedTypes.SpreadElement)[];
    typeArguments?: null | namedTypes.TypeParameterInstantiation;
    type: "CallExpression";
  }
  export interface MemberExpression extends BaseNode {
    optional?: boolean;
    object: Expression;
    property: namedTypes.Identifier | namedTypes.Expression;
    computed?: boolean;
    type: "MemberExpression";
  }
  export interface ChainExpression extends BaseNode {
    expression: ChainElement;
    type: "ChainExpression";
  }
  export interface OptionalCallExpression extends BaseNode {
    callee: Expression;
    arguments: namedTypes.Expression[];
    optional: boolean;
    type: "OptionalCallExpression";
  }
  export interface OptionalMemberExpression extends BaseNode {
    object: Expression;
    property: namedTypes.Identifier | namedTypes.Expression;
    computed?: boolean;
    optional: boolean;
    type: "OptionalMemberExpression";
  }
  export interface LogicalExpression extends BaseNode {
    operator: "||" | "&&";
    left: Expression;
    right: Expression;
    type: "LogicalExpression";
  }
  export interface Decorator extends BaseNode {
    expression: Expression;
    type: "Decorator";
  }
  export interface Property extends BaseNode {
    decorators?: namedTypes.Decorator[] | null;
    kind: "init" | "get" | "set";
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    value: namedTypes.Expression | namedTypes.PatternLike;
    method?: boolean;
    shorthand?: boolean;
    computed?: boolean;
    type: "Property";
  }
  export interface MethodDefinition extends BaseNode {
    decorators?: namedTypes.Decorator[] | null;
    kind: "constructor" | "method" | "get" | "set";
    key: Expression;
    value: Function;
    computed?: boolean;
    static?: boolean;
    type: "MethodDefinition";
  }
  export interface PrivateName extends BaseNode {
    id: Identifier;
    type: "PrivateName";
  }
  export interface ClassPrivateProperty extends BaseNode {
    key: PrivateName;
    value?: namedTypes.Expression | null;
    computed?: boolean;
    type: "ClassPrivateProperty";
  }
  export interface SourceLocation {
    start: Position;
    end: Position;
    source?: string | null;
  }
  export interface Position {
    line: number;
    column: number;
  }
  export interface File extends BaseNode {
    program: Program;
    name?: string | null;
    type: "File";
  }
  export interface Program extends BaseNode {
    body: namedTypes.Statement[];
    directives: namedTypes.Directive[];
    interpreter?: namedTypes.InterpreterDirective | null;
    type: "Program";
  }
  export interface BlockStatement extends BaseNode {
    body: namedTypes.Statement[];
    directives: namedTypes.Directive[];
    type: "BlockStatement";
  }
  export interface EmptyStatement extends BaseNode {
    type: "EmptyStatement";
  }
  export interface ExpressionStatement extends BaseNode {
    expression: Expression;
    type: "ExpressionStatement";
  }
  export interface IfStatement extends BaseNode {
    test: Expression;
    consequent: Statement;
    alternate?: namedTypes.Statement | null;
    type: "IfStatement";
  }
  export interface LabeledStatement extends BaseNode {
    label: Identifier;
    body: Statement;
    type: "LabeledStatement";
  }
  export interface BreakStatement extends BaseNode {
    label?: namedTypes.Identifier | null;
    type: "BreakStatement";
  }
  export interface ContinueStatement extends BaseNode {
    label?: namedTypes.Identifier | null;
    type: "ContinueStatement";
  }
  export interface WithStatement extends BaseNode {
    object: Expression;
    body: Statement;
    type: "WithStatement";
  }
  export interface SwitchStatement extends BaseNode {
    discriminant: Expression;
    cases: namedTypes.SwitchCase[];
    lexical?: boolean;
    type: "SwitchStatement";
  }
  export interface SwitchCase extends BaseNode {
    test: namedTypes.Expression | null;
    consequent: namedTypes.Statement[];
    type: "SwitchCase";
  }
  export interface ReturnStatement extends BaseNode {
    argument: namedTypes.Expression | null;
    type: "ReturnStatement";
  }
  export interface ThrowStatement extends BaseNode {
    argument: Expression;
    type: "ThrowStatement";
  }
  export interface TryStatement extends BaseNode {
    block: BlockStatement;
    handler?: namedTypes.CatchClause | null;
    handlers: namedTypes.CatchClause[];
    guardedHandlers: namedTypes.CatchClause[];
    finalizer?: namedTypes.BlockStatement | null;
    type: "TryStatement";
  }
  export interface WhileStatement extends BaseNode {
    test: Expression;
    body: Statement;
    type: "WhileStatement";
  }
  export interface DoWhileStatement extends BaseNode {
    body: Statement;
    test: Expression;
    type: "DoWhileStatement";
  }
  export interface ForStatement extends BaseNode {
    init: namedTypes.VariableDeclaration | namedTypes.Expression | null;
    test: namedTypes.Expression | null;
    update: namedTypes.Expression | null;
    body: Statement;
    type: "ForStatement";
  }
  export interface VariableDeclaration extends BaseNode {
    kind: "var" | "let" | "const";
    declarations: (namedTypes.VariableDeclarator | namedTypes.Identifier)[];
    type: "VariableDeclaration";
  }
  export interface ForInStatement extends BaseNode {
    left: namedTypes.VariableDeclaration | namedTypes.LVal;
    right: Expression;
    body: Statement;
    type: "ForInStatement";
  }
  export interface DebuggerStatement extends BaseNode {
    type: "DebuggerStatement";
  }
  export interface FunctionDeclaration extends Omit<BaseFunction, "id"> {
    id: namedTypes.Identifier | null;
    returnType?: namedTypes.TypeAnnotation | namedTypes.TSTypeAnnotation | null;
    typeParameters?:
      | namedTypes.TypeParameterDeclaration
      | namedTypes.TSTypeParameterDeclaration
      | null;
    type: "FunctionDeclaration";
  }
  export interface FunctionExpression extends BaseFunction {
    returnType?: namedTypes.TypeAnnotation | namedTypes.TSTypeAnnotation | null;
    typeParameters?:
      | namedTypes.TypeParameterDeclaration
      | namedTypes.TSTypeParameterDeclaration
      | null;
    type: "FunctionExpression";
  }
  export interface VariableDeclarator extends BaseNode {
    id: LVal;
    init?: namedTypes.Expression | null;
    type: "VariableDeclarator";
  }
  export interface ThisExpression extends BaseNode {
    type: "ThisExpression";
  }
  export interface ArrayExpression extends BaseNode {
    elements: (namedTypes.Expression | namedTypes.SpreadElement | null)[];
    type: "ArrayExpression";
  }
  export interface SequenceExpression extends BaseNode {
    expressions: namedTypes.Expression[];
    type: "SequenceExpression";
  }
  export interface UnaryExpression extends BaseNode {
    operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";
    argument: Expression;
    prefix: boolean;
    type: "UnaryExpression";
  }
  export interface UpdateExpression extends BaseNode {
    operator: "++" | "--";
    argument: Expression;
    prefix: boolean;
    type: "UpdateExpression";
  }
  export interface ConditionalExpression extends BaseNode {
    test: Expression;
    consequent: Expression;
    alternate: Expression;
    type: "ConditionalExpression";
  }
  export interface NewExpression extends BaseNode {
    callee: Expression;
    arguments: (namedTypes.Expression | namedTypes.SpreadElement)[];
    typeArguments?: null | namedTypes.TypeParameterInstantiation;
    type: "NewExpression";
  }
  export interface BaseComment {
    loc?: namedTypes.SourceLocation | null;
    value: string;
    leading: boolean;
    trailing?: boolean;
  }
  export interface RestElement extends BaseNode {
    argument: LVal;
    typeAnnotation?:
      | namedTypes.TypeAnnotation
      | namedTypes.TSTypeAnnotation
      | null;
    type: "RestElement";
  }
  export interface ArrowFunctionExpression
    extends Omit<BaseFunction, "id" | "body" | "generator"> {
    id?: null;
    body: namedTypes.BlockStatement | namedTypes.Expression;
    generator?: false;
    returnType?: namedTypes.TypeAnnotation | namedTypes.TSTypeAnnotation | null;
    typeParameters?:
      | namedTypes.TypeParameterDeclaration
      | namedTypes.TSTypeParameterDeclaration
      | null;
    type: "ArrowFunctionExpression";
  }
  export interface YieldExpression extends BaseNode {
    argument: namedTypes.Expression | null;
    delegate?: boolean;
    type: "YieldExpression";
  }
  export interface GeneratorExpression extends BaseNode {
    body: Expression;
    blocks: namedTypes.ComprehensionBlock[];
    filter: namedTypes.Expression | null;
    type: "GeneratorExpression";
  }
  export interface ComprehensionBlock extends BaseNode {
    left: Pattern;
    right: Expression;
    each: boolean;
    type: "ComprehensionBlock";
  }
  export interface ComprehensionExpression extends BaseNode {
    body: Expression;
    blocks: namedTypes.ComprehensionBlock[];
    filter: namedTypes.Expression | null;
    type: "ComprehensionExpression";
  }
  export interface AssignmentPattern extends BaseNode {
    left:
      | namedTypes.Identifier
      | namedTypes.ObjectPattern
      | namedTypes.ArrayPattern
      | namedTypes.MemberExpression;
    right: Expression;
    type: "AssignmentPattern";
  }
  export interface ClassPropertyDefinition extends BaseNode {
    definition:
      | namedTypes.MethodDefinition
      | namedTypes.VariableDeclarator
      | namedTypes.ClassPropertyDefinition
      | namedTypes.ClassProperty;
    type: "ClassPropertyDefinition";
  }
  export interface ClassProperty extends BaseNode {
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    computed?: boolean;
    value: namedTypes.Expression | null;
    static?: boolean;
    typeAnnotation?:
      | namedTypes.TypeAnnotation
      | namedTypes.TSTypeAnnotation
      | null;
    variance?: namedTypes.Variance | "plus" | "minus" | null;
    access?: "public" | "private" | "protected" | undefined;
    type: "ClassProperty";
  }
  export interface ClassBody extends BaseNode {
    body: (
      | namedTypes.MethodDefinition
      | namedTypes.VariableDeclarator
      | namedTypes.ClassPropertyDefinition
      | namedTypes.ClassProperty
      | namedTypes.ClassPrivateProperty
      | namedTypes.ClassMethod
      | namedTypes.ClassPrivateMethod
      | namedTypes.TSDeclareMethod
      | (
          | namedTypes.TSCallSignatureDeclaration
          | namedTypes.TSConstructSignatureDeclaration
          | namedTypes.TSIndexSignature
          | namedTypes.TSMethodSignature
          | namedTypes.TSPropertySignature
        )
    )[];
    type: "ClassBody";
  }
  export interface ClassDeclaration extends BaseNode {
    id: namedTypes.Identifier | null;
    body: ClassBody;
    superClass?: namedTypes.Expression | null;
    typeParameters?:
      | namedTypes.TypeParameterDeclaration
      | namedTypes.TSTypeParameterDeclaration
      | null;
    superTypeParameters?:
      | namedTypes.TypeParameterInstantiation
      | namedTypes.TSTypeParameterInstantiation
      | null;
    implements:
      | namedTypes.ClassImplements[]
      | namedTypes.TSExpressionWithTypeArguments[];
    type: "ClassDeclaration";
  }
  export interface ClassExpression extends BaseNode {
    id?: namedTypes.Identifier | null;
    body: ClassBody;
    superClass?: namedTypes.Expression | null;
    typeParameters?:
      | namedTypes.TypeParameterDeclaration
      | namedTypes.TSTypeParameterDeclaration
      | null;
    superTypeParameters?:
      | namedTypes.TypeParameterInstantiation
      | namedTypes.TSTypeParameterInstantiation
      | null;
    implements:
      | namedTypes.ClassImplements[]
      | namedTypes.TSExpressionWithTypeArguments[];
    type: "ClassExpression";
  }
  export interface Super extends BaseNode {
    type: "Super";
  }
  export interface ImportSpecifier extends BaseNode {
    local?: namedTypes.Identifier | null;
    id?: namedTypes.Identifier | null;
    name?: namedTypes.Identifier | null;
    imported: Identifier;
    type: "ImportSpecifier";
  }
  export interface ImportDefaultSpecifier extends BaseNode {
    local?: namedTypes.Identifier | null;
    id?: namedTypes.Identifier | null;
    name?: namedTypes.Identifier | null;
    type: "ImportDefaultSpecifier";
  }
  export interface ImportNamespaceSpecifier extends BaseNode {
    local?: namedTypes.Identifier | null;
    id?: namedTypes.Identifier | null;
    name?: namedTypes.Identifier | null;
    type: "ImportNamespaceSpecifier";
  }
  export interface ImportDeclaration extends BaseNode {
    specifiers: (
      | namedTypes.ImportSpecifier
      | namedTypes.ImportNamespaceSpecifier
      | namedTypes.ImportDefaultSpecifier
    )[];
    source: Literal;
    importKind: "value" | "type" | "typeof";
    type: "ImportDeclaration";
  }
  export interface ExportNamedDeclaration extends BaseNode {
    declaration: namedTypes.Declaration | null;
    specifiers: namedTypes.ExportSpecifier[];
    source?: namedTypes.Literal | null;
    type: "ExportNamedDeclaration";
  }
  export interface ExportSpecifier extends BaseNode {
    local?: namedTypes.Identifier | null;
    id?: namedTypes.Identifier | null;
    name?: namedTypes.Identifier | null;
    exported: Identifier;
    type: "ExportSpecifier";
  }
  export interface ExportDefaultDeclaration extends BaseNode {
    declaration: namedTypes.Declaration | namedTypes.Expression;
    type: "ExportDefaultDeclaration";
  }
  export interface TaggedTemplateExpression extends BaseNode {
    tag: Expression;
    quasi: TemplateLiteral;
    type: "TaggedTemplateExpression";
  }
  export interface TemplateLiteral extends BaseNode {
    quasis: namedTypes.TemplateElement[];
    expressions: namedTypes.Expression[];
    type: "TemplateLiteral";
  }
  export interface MetaProperty extends BaseNode {
    meta: Identifier;
    property: Identifier;
    type: "MetaProperty";
  }
  export interface JSXAttribute extends BaseNode {
    name: namedTypes.JSXIdentifier | namedTypes.JSXNamespacedName;
    value?:
      | namedTypes.Literal
      | namedTypes.JSXExpressionContainer
      | namedTypes.JSXElement
      | namedTypes.JSXFragment
      | null;
    type: "JSXAttribute";
  }
  export interface JSXIdentifier extends BaseNode {
    name: string;
    type: "JSXIdentifier";
  }
  export interface JSXNamespacedName extends BaseNode {
    namespace: JSXIdentifier;
    name: JSXIdentifier;
    type: "JSXNamespacedName";
  }
  export interface JSXExpressionContainer extends BaseNode {
    expression: namedTypes.Expression | namedTypes.JSXEmptyExpression;
    type: "JSXExpressionContainer";
  }
  export interface JSXElement extends BaseNode {
    openingElement: JSXOpeningElement;
    closingElement?: namedTypes.JSXClosingElement | null;
    children: (
      | namedTypes.JSXText
      | namedTypes.JSXExpressionContainer
      | namedTypes.JSXSpreadChild
      | namedTypes.JSXElement
      | namedTypes.JSXFragment
      | namedTypes.Literal
    )[];
    name?:
      | namedTypes.JSXIdentifier
      | namedTypes.JSXNamespacedName
      | namedTypes.JSXMemberExpression;
    selfClosing?: boolean;
    attributes?: (namedTypes.JSXAttribute | namedTypes.JSXSpreadAttribute)[];
    type: "JSXElement";
  }
  export interface JSXFragment extends BaseNode {
    openingFragment: JSXOpeningFragment;
    closingFragment: JSXClosingFragment;
    children: (
      | namedTypes.JSXText
      | namedTypes.JSXExpressionContainer
      | namedTypes.JSXSpreadChild
      | namedTypes.JSXElement
      | namedTypes.JSXFragment
      | namedTypes.Literal
    )[];
    type: "JSXFragment";
  }
  export interface JSXMemberExpression extends BaseNode {
    object: namedTypes.JSXIdentifier | namedTypes.JSXMemberExpression;
    property: JSXIdentifier;
    computed?: boolean;
    type: "JSXMemberExpression";
  }
  export interface JSXSpreadAttribute extends BaseNode {
    argument: Expression;
    type: "JSXSpreadAttribute";
  }
  export interface JSXEmptyExpression extends BaseNode {
    type: "JSXEmptyExpression";
  }
  export interface JSXText extends BaseNode {
    value: string;
    raw?: string;
    type: "JSXText";
  }
  export interface JSXSpreadChild extends BaseNode {
    expression: Expression;
    type: "JSXSpreadChild";
  }
  export interface JSXOpeningElement extends BaseNode {
    name:
      | namedTypes.JSXIdentifier
      | namedTypes.JSXNamespacedName
      | namedTypes.JSXMemberExpression;
    attributes: (namedTypes.JSXAttribute | namedTypes.JSXSpreadAttribute)[];
    selfClosing?: boolean;
    type: "JSXOpeningElement";
  }
  export interface JSXClosingElement extends BaseNode {
    name:
      | namedTypes.JSXIdentifier
      | namedTypes.JSXNamespacedName
      | namedTypes.JSXMemberExpression;
    type: "JSXClosingElement";
  }
  export interface JSXOpeningFragment extends BaseNode {
    type: "JSXOpeningFragment";
  }
  export interface JSXClosingFragment extends BaseNode {
    type: "JSXClosingFragment";
  }
  export interface TypeAnnotation extends BaseNode {
    typeAnnotation: FlowType;
    type: "TypeAnnotation";
  }
  export interface TSTypeAnnotation extends BaseNode {
    typeAnnotation: namedTypes.TSType | namedTypes.TSTypeAnnotation;
    type: "TSTypeAnnotation";
  }
  export interface TypeParameterDeclaration extends BaseNode {
    params: namedTypes.TypeParameter[];
    type: "TypeParameterDeclaration";
  }
  export interface TSTypeParameterDeclaration extends BaseNode {
    params: namedTypes.TSTypeParameter[];
    type: "TSTypeParameterDeclaration";
  }
  export interface ClassMethod extends Omit<BaseFunction, "body"> {
    returnType?: namedTypes.TypeAnnotation | namedTypes.TSTypeAnnotation | null;
    typeParameters?:
      | namedTypes.TypeParameterDeclaration
      | namedTypes.TSTypeParameterDeclaration
      | null;
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    kind: "get" | "set" | "method" | "constructor";
    body: BlockStatement;
    computed?: boolean;
    static?: boolean | null;
    abstract?: boolean | null;
    access?: "public" | "private" | "protected" | null;
    accessibility?: "public" | "private" | "protected" | null;
    decorators?: namedTypes.Decorator[] | null;
    optional?: boolean | null;
    type: "ClassMethod";
  }
  export interface ClassPrivateMethod extends Omit<BaseFunction, "body"> {
    returnType?: namedTypes.TypeAnnotation | namedTypes.TSTypeAnnotation | null;
    typeParameters?:
      | namedTypes.TypeParameterDeclaration
      | namedTypes.TSTypeParameterDeclaration
      | null;
    key: PrivateName;
    kind: "get" | "set" | "method" | "constructor";
    body: BlockStatement;
    computed?: boolean;
    static?: boolean | null;
    abstract?: boolean | null;
    access?: "public" | "private" | "protected" | null;
    accessibility?: "public" | "private" | "protected" | null;
    decorators?: namedTypes.Decorator[] | null;
    optional?: boolean | null;
    type: "ClassPrivateMethod";
  }
  export interface TypeParameterInstantiation extends BaseNode {
    params: namedTypes.FlowType[];
    type: "TypeParameterInstantiation";
  }
  export interface TSTypeParameterInstantiation extends BaseNode {
    params: namedTypes.TSType[];
    type: "TSTypeParameterInstantiation";
  }
  export interface ClassImplements extends BaseNode {
    id: Identifier;
    superClass?: namedTypes.Expression | null;
    typeParameters?: namedTypes.TypeParameterInstantiation | null;
    type: "ClassImplements";
  }
  export interface TSHasOptionalTypeParameterInstantiation extends BaseNode {
    typeParameters?: namedTypes.TSTypeParameterInstantiation | null;
  }
  export interface TSExpressionWithTypeArguments
    extends TSHasOptionalTypeParameterInstantiation {
    expression: namedTypes.Identifier | namedTypes.TSQualifiedName;
    type: "TSExpressionWithTypeArguments";
  }
  export interface FlowType extends BaseNode {}
  export interface AnyTypeAnnotation extends BaseNode {
    type: "AnyTypeAnnotation";
  }
  export interface EmptyTypeAnnotation extends BaseNode {
    type: "EmptyTypeAnnotation";
  }
  export interface MixedTypeAnnotation extends BaseNode {
    type: "MixedTypeAnnotation";
  }
  export interface VoidTypeAnnotation extends BaseNode {
    type: "VoidTypeAnnotation";
  }
  export interface SymbolTypeAnnotation extends BaseNode {
    type: "SymbolTypeAnnotation";
  }
  export interface NumberTypeAnnotation extends BaseNode {
    type: "NumberTypeAnnotation";
  }
  export interface BigIntTypeAnnotation extends BaseNode {
    type: "BigIntTypeAnnotation";
  }
  export interface NumberLiteralTypeAnnotation extends BaseNode {
    value: number;
    raw: string;
    type: "NumberLiteralTypeAnnotation";
  }
  export interface NumericLiteralTypeAnnotation extends BaseNode {
    value: number;
    raw: string;
    type: "NumericLiteralTypeAnnotation";
  }
  export interface BigIntLiteralTypeAnnotation extends BaseNode {
    value: null;
    raw: string;
    type: "BigIntLiteralTypeAnnotation";
  }
  export interface StringTypeAnnotation extends BaseNode {
    type: "StringTypeAnnotation";
  }
  export interface StringLiteralTypeAnnotation extends BaseNode {
    value: string;
    raw: string;
    type: "StringLiteralTypeAnnotation";
  }
  export interface BooleanTypeAnnotation extends BaseNode {
    type: "BooleanTypeAnnotation";
  }
  export interface BooleanLiteralTypeAnnotation extends BaseNode {
    value: boolean;
    raw: string;
    type: "BooleanLiteralTypeAnnotation";
  }
  export interface NullableTypeAnnotation extends BaseNode {
    typeAnnotation: FlowType;
    type: "NullableTypeAnnotation";
  }
  export interface NullLiteralTypeAnnotation extends BaseNode {
    type: "NullLiteralTypeAnnotation";
  }
  export interface NullTypeAnnotation extends BaseNode {
    type: "NullTypeAnnotation";
  }
  export interface ThisTypeAnnotation extends BaseNode {
    type: "ThisTypeAnnotation";
  }
  export interface ExistsTypeAnnotation extends BaseNode {
    type: "ExistsTypeAnnotation";
  }
  export interface ExistentialTypeParam extends BaseNode {
    type: "ExistentialTypeParam";
  }
  export interface FunctionTypeAnnotation extends BaseNode {
    params: namedTypes.FunctionTypeParam[];
    returnType: FlowType;
    rest: namedTypes.FunctionTypeParam | null;
    typeParameters: namedTypes.TypeParameterDeclaration | null;
    type: "FunctionTypeAnnotation";
  }
  export interface FunctionTypeParam extends BaseNode {
    name: namedTypes.Identifier | null;
    typeAnnotation: FlowType;
    optional: boolean;
    type: "FunctionTypeParam";
  }
  export interface ArrayTypeAnnotation extends BaseNode {
    elementType: FlowType;
    type: "ArrayTypeAnnotation";
  }
  export interface ObjectTypeAnnotation extends BaseNode {
    properties: (
      | namedTypes.ObjectTypeProperty
      | namedTypes.ObjectTypeSpreadProperty
    )[];
    indexers: namedTypes.ObjectTypeIndexer[];
    callProperties: namedTypes.ObjectTypeCallProperty[];
    inexact?: boolean | undefined;
    exact?: boolean;
    internalSlots: namedTypes.ObjectTypeInternalSlot[];
    type: "ObjectTypeAnnotation";
  }
  export interface ObjectTypeProperty extends BaseNode {
    key: namedTypes.Literal | namedTypes.Identifier;
    value: FlowType;
    optional: boolean;
    variance?: namedTypes.Variance | "plus" | "minus" | null;
    type: "ObjectTypeProperty";
  }
  export interface ObjectTypeSpreadProperty extends BaseNode {
    argument: FlowType;
    type: "ObjectTypeSpreadProperty";
  }
  export interface ObjectTypeIndexer extends BaseNode {
    id: Identifier;
    key: FlowType;
    value: FlowType;
    variance?: namedTypes.Variance | "plus" | "minus" | null;
    static?: boolean;
    type: "ObjectTypeIndexer";
  }
  export interface ObjectTypeCallProperty extends BaseNode {
    value: FunctionTypeAnnotation;
    static?: boolean;
    type: "ObjectTypeCallProperty";
  }
  export interface ObjectTypeInternalSlot extends BaseNode {
    id: Identifier;
    value: FlowType;
    optional: boolean;
    static: boolean;
    method: boolean;
    type: "ObjectTypeInternalSlot";
  }
  export interface Variance extends BaseNode {
    kind: "plus" | "minus";
    type: "Variance";
  }
  export interface QualifiedTypeIdentifier extends BaseNode {
    qualification: namedTypes.Identifier | namedTypes.QualifiedTypeIdentifier;
    id: Identifier;
    type: "QualifiedTypeIdentifier";
  }
  export interface GenericTypeAnnotation extends BaseNode {
    id: namedTypes.Identifier | namedTypes.QualifiedTypeIdentifier;
    typeParameters: namedTypes.TypeParameterInstantiation | null;
    type: "GenericTypeAnnotation";
  }
  export interface MemberTypeAnnotation extends BaseNode {
    object: Identifier;
    property:
      | namedTypes.MemberTypeAnnotation
      | namedTypes.GenericTypeAnnotation;
    type: "MemberTypeAnnotation";
  }
  export interface UnionTypeAnnotation extends BaseNode {
    types: namedTypes.FlowType[];
    type: "UnionTypeAnnotation";
  }
  export interface IntersectionTypeAnnotation extends BaseNode {
    types: namedTypes.FlowType[];
    type: "IntersectionTypeAnnotation";
  }
  export interface TypeofTypeAnnotation extends BaseNode {
    argument: FlowType;
    type: "TypeofTypeAnnotation";
  }
  export interface TypeParameter extends BaseNode {
    name: string;
    variance?: namedTypes.Variance | "plus" | "minus" | null;
    bound?: namedTypes.TypeAnnotation | null;
    default?: namedTypes.FlowType | null;
    type: "TypeParameter";
  }
  export interface InterfaceTypeAnnotation extends BaseNode {
    body: ObjectTypeAnnotation;
    extends?: namedTypes.InterfaceExtends[] | null;
    type: "InterfaceTypeAnnotation";
  }
  export interface InterfaceExtends extends BaseNode {
    id: Identifier;
    typeParameters?: namedTypes.TypeParameterInstantiation | null;
    type: "InterfaceExtends";
  }
  export interface InterfaceDeclaration extends BaseNode {
    id: Identifier;
    typeParameters?: namedTypes.TypeParameterDeclaration | null;
    body: ObjectTypeAnnotation;
    extends: namedTypes.InterfaceExtends[];
    type: "InterfaceDeclaration";
  }
  export interface TypeAlias extends BaseNode {
    id: Identifier;
    typeParameters: namedTypes.TypeParameterDeclaration | null;
    right: FlowType;
    type: "TypeAlias";
  }
  export interface DeclareTypeAlias extends BaseNode {
    id: Identifier;
    typeParameters: namedTypes.TypeParameterDeclaration | null;
    right: FlowType;
    type: "DeclareTypeAlias";
  }
  export interface OpaqueType extends BaseNode {
    id: Identifier;
    typeParameters: namedTypes.TypeParameterDeclaration | null;
    impltype: FlowType;
    supertype: namedTypes.FlowType | null;
    type: "OpaqueType";
  }
  export interface DeclareOpaqueType extends BaseNode {
    id: Identifier;
    typeParameters: namedTypes.TypeParameterDeclaration | null;
    supertype: namedTypes.FlowType | null;
    impltype: namedTypes.FlowType | null;
    type: "DeclareOpaqueType";
  }
  export interface TypeCastExpression extends BaseNode {
    expression: Expression;
    typeAnnotation: TypeAnnotation;
    type: "TypeCastExpression";
  }
  export interface TupleTypeAnnotation extends BaseNode {
    types: namedTypes.FlowType[];
    type: "TupleTypeAnnotation";
  }
  export interface DeclareVariable extends BaseNode {
    id: Identifier;
    type: "DeclareVariable";
  }
  export interface DeclareFunction extends BaseNode {
    id: Identifier;
    predicate?: namedTypes.FlowPredicate | null;
    type: "DeclareFunction";
  }
  export interface FlowPredicate extends BaseNode {}
  export interface DeclareClass extends BaseNode {
    id: Identifier;
    typeParameters?: namedTypes.TypeParameterDeclaration | null;
    body: ObjectTypeAnnotation;
    extends: namedTypes.InterfaceExtends[];
    type: "DeclareClass";
  }
  export interface DeclareModule extends BaseNode {
    id: namedTypes.Identifier | namedTypes.Literal;
    body: BlockStatement;
    type: "DeclareModule";
  }
  export interface DeclareModuleExports extends BaseNode {
    typeAnnotation: TypeAnnotation;
    type: "DeclareModuleExports";
  }
  export interface DeclareExportDeclaration extends BaseNode {
    default: boolean;
    declaration:
      | namedTypes.DeclareVariable
      | namedTypes.DeclareFunction
      | namedTypes.DeclareClass
      | namedTypes.FlowType
      | namedTypes.TypeAlias
      | namedTypes.DeclareOpaqueType
      | namedTypes.InterfaceDeclaration
      | null;
    specifiers: (
      | namedTypes.ExportSpecifier
      | namedTypes.ExportBatchSpecifier
    )[];
    source?: namedTypes.Literal | null;
    type: "DeclareExportDeclaration";
  }
  export interface ExportBatchSpecifier extends BaseNode {
    type: "ExportBatchSpecifier";
  }
  export interface DeclareExportAllDeclaration extends BaseNode {
    source?: namedTypes.Literal | null;
    type: "DeclareExportAllDeclaration";
  }
  export interface InferredPredicate extends BaseNode {
    type: "InferredPredicate";
  }
  export interface DeclaredPredicate extends BaseNode {
    value: Expression;
    type: "DeclaredPredicate";
  }
  export interface EnumDeclaration extends BaseNode {
    id: Identifier;
    body:
      | namedTypes.EnumBooleanBody
      | namedTypes.EnumNumberBody
      | namedTypes.EnumStringBody
      | namedTypes.EnumSymbolBody;
    type: "EnumDeclaration";
  }
  export interface EnumBooleanBody {
    members: namedTypes.EnumBooleanMember[];
    explicitType: boolean;
  }
  export interface EnumNumberBody {
    members: namedTypes.EnumNumberMember[];
    explicitType: boolean;
  }
  export interface EnumStringBody {
    members: namedTypes.EnumStringMember[] | namedTypes.EnumDefaultedMember[];
    explicitType: boolean;
  }
  export interface EnumSymbolBody {
    members: namedTypes.EnumDefaultedMember[];
  }
  export interface EnumBooleanMember {
    id: Identifier;
    init: namedTypes.Literal | boolean;
  }
  export interface EnumNumberMember {
    id: Identifier;
    init: Literal;
  }
  export interface EnumStringMember {
    id: Identifier;
    init: Literal;
  }
  export interface EnumDefaultedMember {
    id: Identifier;
  }
  export interface ExportDeclaration extends BaseNode {
    default: boolean;
    declaration: namedTypes.Declaration | namedTypes.Expression | null;
    specifiers: (
      | namedTypes.ExportSpecifier
      | namedTypes.ExportBatchSpecifier
    )[];
    source?: namedTypes.Literal | null;
    type: "ExportDeclaration";
  }
  export interface Block extends BaseComment {}
  export interface Line extends BaseComment {}
  export interface Noop extends BaseNode {
    type: "Noop";
  }
  export interface DoExpression extends BaseNode {
    body: namedTypes.Statement[];
    type: "DoExpression";
  }
  export interface BindExpression extends BaseNode {
    object: namedTypes.Expression | null;
    callee: Expression;
    type: "BindExpression";
  }
  export interface ParenthesizedExpression extends BaseNode {
    expression: Expression;
    type: "ParenthesizedExpression";
  }
  export interface ExportNamespaceSpecifier extends BaseNode {
    exported: Identifier;
    type: "ExportNamespaceSpecifier";
  }
  export interface ExportDefaultSpecifier extends BaseNode {
    exported: Identifier;
    type: "ExportDefaultSpecifier";
  }
  export interface CommentBlock extends BaseComment {
    type: string;
  }
  export interface CommentLine extends BaseComment {
    type: string;
  }
  export interface Directive extends BaseNode {
    value: DirectiveLiteral;
    type: "Directive";
  }
  export interface DirectiveLiteral extends BaseNode {
    value: string;
    type: "DirectiveLiteral";
  }
  export interface InterpreterDirective extends BaseNode {
    value: string;
    type: "InterpreterDirective";
  }
  export interface StringLiteral extends BaseNode {
    value: string;
    raw?: string;
    extra: { rawValue: string; raw: string };
    type: "StringLiteral";
  }
  export interface NumericLiteral extends BaseNode {
    value: number;
    raw?: string;
    extra: { rawValue: number; raw: string };
    type: "NumericLiteral";
  }
  export interface BigIntLiteral extends BaseNode {
    value: string | number;
    raw: string;
    extra: { rawValue: string; raw: string };
    type: "BigIntLiteral";
  }
  export interface NullLiteral extends BaseNode {
    value: null;
    raw: string;
    extra: { rawValue: null; raw: string };
    type: "NullLiteral";
  }
  export interface BooleanLiteral extends BaseNode {
    value: boolean;
    raw: string;
    extra: { rawValue: boolean; raw: string };
    type: "BooleanLiteral";
  }
  export interface RegExpLiteral extends BaseNode {
    pattern: string;
    flags: string;
    value: RegExp;
    raw: string;
    extra: { rawValue: RegExp; raw: string };
    type: "RegExpLiteral";
  }
  export interface ForAwaitStatement extends BaseNode {
    left: namedTypes.VariableDeclaration | namedTypes.Expression;
    right: Expression;
    body: Statement;
    type: "ForAwaitStatement";
  }
  export interface Import extends BaseNode {
    type: "Import";
  }
  export interface TSQualifiedName extends BaseNode {
    left: namedTypes.Identifier | namedTypes.TSQualifiedName;
    right: namedTypes.Identifier | namedTypes.TSQualifiedName;
    type: "TSQualifiedName";
  }
  export interface TSTypeReference
    extends TSHasOptionalTypeParameterInstantiation {
    typeName: namedTypes.Identifier | namedTypes.TSQualifiedName;
    type: "TSTypeReference";
  }
  export interface TSHasOptionalTypeParameters extends BaseNode {
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null | undefined;
  }
  export interface TSHasOptionalTypeAnnotation extends BaseNode {
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
  }
  export interface TSAsExpression extends BaseNode {
    expression: Expression;
    typeAnnotation: TSType;
    extra?: { parenthesized: boolean } | null;
    type: "TSAsExpression";
  }
  export interface TSNonNullExpression extends BaseNode {
    expression: Expression;
    type: "TSNonNullExpression";
  }
  export interface TSAnyKeyword extends BaseNode {
    type: "TSAnyKeyword";
  }
  export interface TSBigIntKeyword extends BaseNode {
    type: "TSBigIntKeyword";
  }
  export interface TSBooleanKeyword extends BaseNode {
    type: "TSBooleanKeyword";
  }
  export interface TSNeverKeyword extends BaseNode {
    type: "TSNeverKeyword";
  }
  export interface TSNullKeyword extends BaseNode {
    type: "TSNullKeyword";
  }
  export interface TSNumberKeyword extends BaseNode {
    type: "TSNumberKeyword";
  }
  export interface TSObjectKeyword extends BaseNode {
    type: "TSObjectKeyword";
  }
  export interface TSStringKeyword extends BaseNode {
    type: "TSStringKeyword";
  }
  export interface TSSymbolKeyword extends BaseNode {
    type: "TSSymbolKeyword";
  }
  export interface TSUndefinedKeyword extends BaseNode {
    type: "TSUndefinedKeyword";
  }
  export interface TSUnknownKeyword extends BaseNode {
    type: "TSUnknownKeyword";
  }
  export interface TSVoidKeyword extends BaseNode {
    type: "TSVoidKeyword";
  }
  export interface TSThisType extends BaseNode {
    type: "TSThisType";
  }
  export interface TSArrayType extends BaseNode {
    elementType: TSType;
    type: "TSArrayType";
  }
  export interface TSLiteralType extends BaseNode {
    literal:
      | namedTypes.NumericLiteral
      | namedTypes.StringLiteral
      | namedTypes.BooleanLiteral
      | namedTypes.TemplateLiteral
      | namedTypes.UnaryExpression;
    type: "TSLiteralType";
  }
  export interface TSUnionType extends BaseNode {
    types: namedTypes.TSType[];
    type: "TSUnionType";
  }
  export interface TSIntersectionType extends BaseNode {
    types: namedTypes.TSType[];
    type: "TSIntersectionType";
  }
  export interface TSConditionalType extends BaseNode {
    checkType: TSType;
    extendsType: TSType;
    trueType: TSType;
    falseType: TSType;
    type: "TSConditionalType";
  }
  export interface TSInferType extends BaseNode {
    typeParameter: TSTypeParameter;
    type: "TSInferType";
  }
  export interface TSTypeParameter extends BaseNode {
    name: string;
    constraint?: namedTypes.TSType | undefined;
    default?: namedTypes.TSType | undefined;
    type: "TSTypeParameter";
  }
  export interface TSParenthesizedType extends BaseNode {
    typeAnnotation: TSType;
    type: "TSParenthesizedType";
  }
  export interface TSFunctionType
    extends TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    type: "TSFunctionType";
  }
  export interface TSConstructorType
    extends TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    type: "TSConstructorType";
  }
  export interface TSDeclareFunction extends TSHasOptionalTypeParameters {
    declare?: boolean;
    async?: boolean;
    generator?: boolean;
    id?: namedTypes.Identifier | null;
    params: namedTypes.PatternLike[];
    returnType?: namedTypes.TSTypeAnnotation | namedTypes.Noop | null;
    type: "TSDeclareFunction";
  }
  export interface TSDeclareMethod extends TSHasOptionalTypeParameters {
    async?: boolean;
    generator?: boolean;
    params: namedTypes.PatternLike[];
    abstract?: boolean;
    accessibility?: "public" | "private" | "protected" | undefined;
    static?: boolean;
    computed?: boolean;
    optional?: boolean;
    key:
      | namedTypes.Identifier
      | namedTypes.StringLiteral
      | namedTypes.NumericLiteral
      | namedTypes.Expression;
    kind: "get" | "set" | "method" | "constructor";
    access?: "public" | "private" | "protected" | undefined;
    decorators?: namedTypes.Decorator[] | null;
    returnType?: namedTypes.TSTypeAnnotation | namedTypes.Noop | null;
    type: "TSDeclareMethod";
  }
  export interface TSMappedType extends BaseNode {
    readonly?: boolean | "+" | "-";
    typeParameter: TSTypeParameter;
    optional?: boolean | "+" | "-";
    typeAnnotation?: namedTypes.TSType | null;
    type: "TSMappedType";
  }
  export interface TSTupleType extends BaseNode {
    elementTypes: (namedTypes.TSType | namedTypes.TSNamedTupleMember)[];
    type: "TSTupleType";
  }
  export interface TSNamedTupleMember extends BaseNode {
    label: Identifier;
    optional?: boolean;
    elementType: TSType;
    type: "TSNamedTupleMember";
  }
  export interface TSRestType extends BaseNode {
    typeAnnotation: TSType;
    type: "TSRestType";
  }
  export interface TSOptionalType extends BaseNode {
    typeAnnotation: TSType;
    type: "TSOptionalType";
  }
  export interface TSIndexedAccessType extends BaseNode {
    objectType: TSType;
    indexType: TSType;
    type: "TSIndexedAccessType";
  }
  export interface TSTypeOperator extends BaseNode {
    operator: string;
    typeAnnotation: TSType;
    type: "TSTypeOperator";
  }
  export interface TSIndexSignature extends TSHasOptionalTypeAnnotation {
    parameters: namedTypes.Identifier[];
    readonly?: boolean;
    type: "TSIndexSignature";
  }
  export interface TSPropertySignature extends TSHasOptionalTypeAnnotation {
    key: Expression;
    computed?: boolean;
    readonly?: boolean;
    optional?: boolean;
    initializer?: namedTypes.Expression | null;
    type: "TSPropertySignature";
  }
  export interface TSMethodSignature
    extends TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    key: Expression;
    computed?: boolean;
    optional?: boolean;
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    type: "TSMethodSignature";
  }
  export interface TSTypePredicate extends BaseNode {
    parameterName: namedTypes.Identifier | namedTypes.TSThisType;
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
    asserts?: boolean;
    type: "TSTypePredicate";
  }
  export interface TSCallSignatureDeclaration
    extends TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    type: "TSCallSignatureDeclaration";
  }
  export interface TSConstructSignatureDeclaration
    extends TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    type: "TSConstructSignatureDeclaration";
  }
  export interface TSEnumMember extends BaseNode {
    id: namedTypes.Identifier | namedTypes.StringLiteral;
    initializer?: namedTypes.Expression | null;
    type: "TSEnumMember";
  }
  export interface TSTypeQuery extends BaseNode {
    exprName:
      | (namedTypes.Identifier | namedTypes.TSQualifiedName)
      | namedTypes.TSImportType;
    type: "TSTypeQuery";
  }
  export interface TSImportType
    extends TSHasOptionalTypeParameterInstantiation {
    argument: StringLiteral;
    qualifier?:
      | (namedTypes.Identifier | namedTypes.TSQualifiedName)
      | undefined;
    type: "TSImportType";
  }
  export interface TSTypeLiteral extends BaseNode {
    members: (
      | namedTypes.TSCallSignatureDeclaration
      | namedTypes.TSConstructSignatureDeclaration
      | namedTypes.TSIndexSignature
      | namedTypes.TSMethodSignature
      | namedTypes.TSPropertySignature
    )[];
    type: "TSTypeLiteral";
  }
  export interface TSTypeAssertion extends BaseNode {
    typeAnnotation: TSType;
    expression: Expression;
    extra?: { parenthesized: boolean } | null;
    type: "TSTypeAssertion";
  }
  export interface TSEnumDeclaration extends BaseNode {
    id: Identifier;
    const?: boolean;
    declare?: boolean;
    members: namedTypes.TSEnumMember[];
    initializer?: namedTypes.Expression | null;
    type: "TSEnumDeclaration";
  }
  export interface TSTypeAliasDeclaration extends TSHasOptionalTypeParameters {
    id: Identifier;
    declare?: boolean;
    typeAnnotation: TSType;
    type: "TSTypeAliasDeclaration";
  }
  export interface TSModuleBlock extends BaseNode {
    body: namedTypes.Statement[];
    type: "TSModuleBlock";
  }
  export interface TSModuleDeclaration extends BaseNode {
    id:
      | namedTypes.StringLiteral
      | (namedTypes.Identifier | namedTypes.TSQualifiedName);
    declare?: boolean;
    global?: boolean;
    body?: namedTypes.TSModuleBlock | namedTypes.TSModuleDeclaration | null;
    type: "TSModuleDeclaration";
  }
  export interface TSImportEqualsDeclaration extends BaseNode {
    id: Identifier;
    isExport?: boolean;
    moduleReference:
      | (namedTypes.Identifier | namedTypes.TSQualifiedName)
      | namedTypes.TSExternalModuleReference;
    type: "TSImportEqualsDeclaration";
  }
  export interface TSExternalModuleReference extends BaseNode {
    expression: StringLiteral;
    type: "TSExternalModuleReference";
  }
  export interface TSExportAssignment extends BaseNode {
    expression: Expression;
    type: "TSExportAssignment";
  }
  export interface TSNamespaceExportDeclaration extends BaseNode {
    id: Identifier;
    type: "TSNamespaceExportDeclaration";
  }
  export interface TSInterfaceBody extends BaseNode {
    body: (
      | namedTypes.TSCallSignatureDeclaration
      | namedTypes.TSConstructSignatureDeclaration
      | namedTypes.TSIndexSignature
      | namedTypes.TSMethodSignature
      | namedTypes.TSPropertySignature
    )[];
    type: "TSInterfaceBody";
  }
  export interface TSInterfaceDeclaration extends TSHasOptionalTypeParameters {
    id: namedTypes.Identifier | namedTypes.TSQualifiedName;
    declare?: boolean;
    extends?: namedTypes.TSExpressionWithTypeArguments[] | null;
    body: TSInterfaceBody;
    type: "TSInterfaceDeclaration";
  }
  export interface TSParameterProperty extends BaseNode {
    accessibility?: "public" | "private" | "protected" | undefined;
    readonly?: boolean;
    parameter: namedTypes.Identifier | namedTypes.AssignmentPattern;
    type: "TSParameterProperty";
  }
  export type ASTNode =
    | BinaryExpression
    | AssignmentExpression
    | AwaitExpression
    | ForOfStatement
    | ObjectExpression
    | ObjectMethod
    | ObjectProperty
    | SpreadElement
    | TemplateElement
    | CatchClause
    | Identifier
    | ArrayPattern
    | ObjectPattern
    | ImportExpression
    | ExportAllDeclaration
    | CallExpression
    | MemberExpression
    | ChainExpression
    | OptionalCallExpression
    | OptionalMemberExpression
    | LogicalExpression
    | Decorator
    | Property
    | MethodDefinition
    | PrivateName
    | ClassPrivateProperty
    | File
    | Program
    | BlockStatement
    | EmptyStatement
    | ExpressionStatement
    | IfStatement
    | LabeledStatement
    | BreakStatement
    | ContinueStatement
    | WithStatement
    | SwitchStatement
    | SwitchCase
    | ReturnStatement
    | ThrowStatement
    | TryStatement
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | VariableDeclaration
    | ForInStatement
    | DebuggerStatement
    | FunctionDeclaration
    | FunctionExpression
    | VariableDeclarator
    | ThisExpression
    | ArrayExpression
    | SequenceExpression
    | UnaryExpression
    | UpdateExpression
    | ConditionalExpression
    | NewExpression
    | RestElement
    | ArrowFunctionExpression
    | YieldExpression
    | GeneratorExpression
    | ComprehensionBlock
    | ComprehensionExpression
    | AssignmentPattern
    | ClassPropertyDefinition
    | ClassProperty
    | ClassBody
    | ClassDeclaration
    | ClassExpression
    | Super
    | ImportSpecifier
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportDeclaration
    | ExportNamedDeclaration
    | ExportSpecifier
    | ExportDefaultDeclaration
    | TaggedTemplateExpression
    | TemplateLiteral
    | MetaProperty
    | JSXAttribute
    | JSXIdentifier
    | JSXNamespacedName
    | JSXExpressionContainer
    | JSXElement
    | JSXFragment
    | JSXMemberExpression
    | JSXSpreadAttribute
    | JSXEmptyExpression
    | JSXText
    | JSXSpreadChild
    | JSXOpeningElement
    | JSXClosingElement
    | JSXOpeningFragment
    | JSXClosingFragment
    | TypeAnnotation
    | TSTypeAnnotation
    | TypeParameterDeclaration
    | TSTypeParameterDeclaration
    | ClassMethod
    | ClassPrivateMethod
    | TypeParameterInstantiation
    | TSTypeParameterInstantiation
    | ClassImplements
    | TSExpressionWithTypeArguments
    | AnyTypeAnnotation
    | EmptyTypeAnnotation
    | MixedTypeAnnotation
    | VoidTypeAnnotation
    | SymbolTypeAnnotation
    | NumberTypeAnnotation
    | BigIntTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumericLiteralTypeAnnotation
    | BigIntLiteralTypeAnnotation
    | StringTypeAnnotation
    | StringLiteralTypeAnnotation
    | BooleanTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | NullableTypeAnnotation
    | NullLiteralTypeAnnotation
    | NullTypeAnnotation
    | ThisTypeAnnotation
    | ExistsTypeAnnotation
    | ExistentialTypeParam
    | FunctionTypeAnnotation
    | FunctionTypeParam
    | ArrayTypeAnnotation
    | ObjectTypeAnnotation
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty
    | ObjectTypeIndexer
    | ObjectTypeCallProperty
    | ObjectTypeInternalSlot
    | Variance
    | QualifiedTypeIdentifier
    | GenericTypeAnnotation
    | MemberTypeAnnotation
    | UnionTypeAnnotation
    | IntersectionTypeAnnotation
    | TypeofTypeAnnotation
    | TypeParameter
    | InterfaceTypeAnnotation
    | InterfaceExtends
    | InterfaceDeclaration
    | TypeAlias
    | DeclareTypeAlias
    | OpaqueType
    | DeclareOpaqueType
    | TypeCastExpression
    | TupleTypeAnnotation
    | DeclareVariable
    | DeclareFunction
    | DeclareClass
    | DeclareModule
    | DeclareModuleExports
    | DeclareExportDeclaration
    | ExportBatchSpecifier
    | DeclareExportAllDeclaration
    | InferredPredicate
    | DeclaredPredicate
    | EnumDeclaration
    | EnumBooleanBody
    | EnumNumberBody
    | EnumStringBody
    | EnumSymbolBody
    | EnumBooleanMember
    | EnumNumberMember
    | EnumStringMember
    | EnumDefaultedMember
    | ExportDeclaration
    | Block
    | Line
    | Noop
    | DoExpression
    | BindExpression
    | ParenthesizedExpression
    | ExportNamespaceSpecifier
    | ExportDefaultSpecifier
    | CommentBlock
    | CommentLine
    | Directive
    | DirectiveLiteral
    | InterpreterDirective
    | StringLiteral
    | NumericLiteral
    | BigIntLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | ForAwaitStatement
    | Import
    | TSQualifiedName
    | TSTypeReference
    | TSAsExpression
    | TSNonNullExpression
    | TSAnyKeyword
    | TSBigIntKeyword
    | TSBooleanKeyword
    | TSNeverKeyword
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSUndefinedKeyword
    | TSUnknownKeyword
    | TSVoidKeyword
    | TSThisType
    | TSArrayType
    | TSLiteralType
    | TSUnionType
    | TSIntersectionType
    | TSConditionalType
    | TSInferType
    | TSTypeParameter
    | TSParenthesizedType
    | TSFunctionType
    | TSConstructorType
    | TSDeclareFunction
    | TSDeclareMethod
    | TSMappedType
    | TSTupleType
    | TSNamedTupleMember
    | TSRestType
    | TSOptionalType
    | TSIndexedAccessType
    | TSTypeOperator
    | TSIndexSignature
    | TSPropertySignature
    | TSMethodSignature
    | TSTypePredicate
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSEnumMember
    | TSTypeQuery
    | TSImportType
    | TSTypeLiteral
    | TSTypeAssertion
    | TSEnumDeclaration
    | TSTypeAliasDeclaration
    | TSModuleBlock
    | TSModuleDeclaration
    | TSImportEqualsDeclaration
    | TSExternalModuleReference
    | TSExportAssignment
    | TSNamespaceExportDeclaration
    | TSInterfaceBody
    | TSInterfaceDeclaration
    | TSParameterProperty;
  export let Node: Type<Node>;
  export let BaseNode: Type<BaseNode>;
  export let Expression: Type<Expression>;
  export let Binary: Type<Binary>;
  export let BinaryExpression: Type<BinaryExpression>;
  export let AssignmentExpression: Type<AssignmentExpression>;
  export let Scopable: Type<Scopable>;
  export let BlockParent: Type<BlockParent>;
  export let Function: Type<Function>;
  export let BaseFunction: Type<BaseFunction>;
  export let AwaitExpression: Type<AwaitExpression>;
  export let Statement: Type<Statement>;
  export let Loop: Type<Loop>;
  export let For: Type<For>;
  export let ForX: Type<ForX>;
  export let ForOfStatement: Type<ForOfStatement>;
  export let ObjectExpression: Type<ObjectExpression>;
  export let FunctionParent: Type<FunctionParent>;
  export let ObjectMethod: Type<ObjectMethod>;
  export let ObjectProperty: Type<ObjectProperty>;
  export let SpreadElement: Type<SpreadElement>;
  export let TemplateElement: Type<TemplateElement>;
  export let CatchClause: Type<CatchClause>;
  export let PatternLike: Type<PatternLike>;
  export let LVal: Type<LVal>;
  export let Identifier: Type<Identifier>;
  export let Pattern: Type<Pattern>;
  export let ArrayPattern: Type<ArrayPattern>;
  export let ObjectPattern: Type<ObjectPattern>;
  export let ImportExpression: Type<ImportExpression>;
  export let Declaration: Type<Declaration>;
  export let ExportAllDeclaration: Type<ExportAllDeclaration>;
  export let Pureish: Type<Pureish>;
  export let Literal: Type<Literal>;
  export let ChainElement: Type<ChainElement>;
  export let CallExpression: Type<CallExpression>;
  export let MemberExpression: Type<MemberExpression>;
  export let ChainExpression: Type<ChainExpression>;
  export let OptionalCallExpression: Type<OptionalCallExpression>;
  export let OptionalMemberExpression: Type<OptionalMemberExpression>;
  export let LogicalExpression: Type<LogicalExpression>;
  export let Decorator: Type<Decorator>;
  export let Property: Type<Property>;
  export let MethodDefinition: Type<MethodDefinition>;
  export let PrivateName: Type<PrivateName>;
  export let ClassPrivateProperty: Type<ClassPrivateProperty>;
  export let Comment: Type<Comment>;
  export let SourceLocation: Type<SourceLocation>;
  export let Position: Type<Position>;
  export let File: Type<File>;
  export let Program: Type<Program>;
  export let BlockStatement: Type<BlockStatement>;
  export let EmptyStatement: Type<EmptyStatement>;
  export let ExpressionStatement: Type<ExpressionStatement>;
  export let Conditional: Type<Conditional>;
  export let IfStatement: Type<IfStatement>;
  export let LabeledStatement: Type<LabeledStatement>;
  export let CompletionStatement: Type<CompletionStatement>;
  export let BreakStatement: Type<BreakStatement>;
  export let ContinueStatement: Type<ContinueStatement>;
  export let WithStatement: Type<WithStatement>;
  export let SwitchStatement: Type<SwitchStatement>;
  export let SwitchCase: Type<SwitchCase>;
  export let ReturnStatement: Type<ReturnStatement>;
  export let ThrowStatement: Type<ThrowStatement>;
  export let TryStatement: Type<TryStatement>;
  export let While: Type<While>;
  export let WhileStatement: Type<WhileStatement>;
  export let DoWhileStatement: Type<DoWhileStatement>;
  export let ForStatement: Type<ForStatement>;
  export let VariableDeclaration: Type<VariableDeclaration>;
  export let ForInStatement: Type<ForInStatement>;
  export let DebuggerStatement: Type<DebuggerStatement>;
  export let FunctionDeclaration: Type<FunctionDeclaration>;
  export let FunctionExpression: Type<FunctionExpression>;
  export let VariableDeclarator: Type<VariableDeclarator>;
  export let ThisExpression: Type<ThisExpression>;
  export let ArrayExpression: Type<ArrayExpression>;
  export let SequenceExpression: Type<SequenceExpression>;
  export let UnaryExpression: Type<UnaryExpression>;
  export let UpdateExpression: Type<UpdateExpression>;
  export let ConditionalExpression: Type<ConditionalExpression>;
  export let NewExpression: Type<NewExpression>;
  export let BaseComment: Type<BaseComment>;
  export let RestElement: Type<RestElement>;
  export let ArrowFunctionExpression: Type<ArrowFunctionExpression>;
  export let YieldExpression: Type<YieldExpression>;
  export let GeneratorExpression: Type<GeneratorExpression>;
  export let ComprehensionBlock: Type<ComprehensionBlock>;
  export let ComprehensionExpression: Type<ComprehensionExpression>;
  export let AssignmentPattern: Type<AssignmentPattern>;
  export let ClassPropertyDefinition: Type<ClassPropertyDefinition>;
  export let ClassProperty: Type<ClassProperty>;
  export let ClassBody: Type<ClassBody>;
  export let Class: Type<Class>;
  export let ClassDeclaration: Type<ClassDeclaration>;
  export let ClassExpression: Type<ClassExpression>;
  export let Super: Type<Super>;
  export let Specifier: Type<Specifier>;
  export let ModuleSpecifier: Type<ModuleSpecifier>;
  export let ImportSpecifier: Type<ImportSpecifier>;
  export let ImportDefaultSpecifier: Type<ImportDefaultSpecifier>;
  export let ImportNamespaceSpecifier: Type<ImportNamespaceSpecifier>;
  export let ImportDeclaration: Type<ImportDeclaration>;
  export let ExportNamedDeclaration: Type<ExportNamedDeclaration>;
  export let ExportSpecifier: Type<ExportSpecifier>;
  export let ExportDefaultDeclaration: Type<ExportDefaultDeclaration>;
  export let TaggedTemplateExpression: Type<TaggedTemplateExpression>;
  export let TemplateLiteral: Type<TemplateLiteral>;
  export let MetaProperty: Type<MetaProperty>;
  export let JSX: Type<JSX>;
  export let JSXAttribute: Type<JSXAttribute>;
  export let JSXIdentifier: Type<JSXIdentifier>;
  export let JSXNamespacedName: Type<JSXNamespacedName>;
  export let JSXExpressionContainer: Type<JSXExpressionContainer>;
  export let JSXElement: Type<JSXElement>;
  export let JSXFragment: Type<JSXFragment>;
  export let JSXMemberExpression: Type<JSXMemberExpression>;
  export let JSXSpreadAttribute: Type<JSXSpreadAttribute>;
  export let JSXEmptyExpression: Type<JSXEmptyExpression>;
  export let JSXText: Type<JSXText>;
  export let JSXSpreadChild: Type<JSXSpreadChild>;
  export let JSXOpeningElement: Type<JSXOpeningElement>;
  export let JSXClosingElement: Type<JSXClosingElement>;
  export let JSXOpeningFragment: Type<JSXOpeningFragment>;
  export let JSXClosingFragment: Type<JSXClosingFragment>;
  export let TypeAnnotation: Type<TypeAnnotation>;
  export let TSTypeAnnotation: Type<TSTypeAnnotation>;
  export let TypeParameterDeclaration: Type<TypeParameterDeclaration>;
  export let TSTypeParameterDeclaration: Type<TSTypeParameterDeclaration>;
  export let ClassMethod: Type<ClassMethod>;
  export let ClassPrivateMethod: Type<ClassPrivateMethod>;
  export let TypeParameterInstantiation: Type<TypeParameterInstantiation>;
  export let TSTypeParameterInstantiation: Type<TSTypeParameterInstantiation>;
  export let ClassImplements: Type<ClassImplements>;
  export let TSHasOptionalTypeParameterInstantiation: Type<TSHasOptionalTypeParameterInstantiation>;
  export let TSType: Type<TSType>;
  export let TSExpressionWithTypeArguments: Type<TSExpressionWithTypeArguments>;
  export let Flow: Type<Flow>;
  export let FlowType: Type<FlowType>;
  export let AnyTypeAnnotation: Type<AnyTypeAnnotation>;
  export let EmptyTypeAnnotation: Type<EmptyTypeAnnotation>;
  export let MixedTypeAnnotation: Type<MixedTypeAnnotation>;
  export let VoidTypeAnnotation: Type<VoidTypeAnnotation>;
  export let SymbolTypeAnnotation: Type<SymbolTypeAnnotation>;
  export let NumberTypeAnnotation: Type<NumberTypeAnnotation>;
  export let BigIntTypeAnnotation: Type<BigIntTypeAnnotation>;
  export let NumberLiteralTypeAnnotation: Type<NumberLiteralTypeAnnotation>;
  export let NumericLiteralTypeAnnotation: Type<NumericLiteralTypeAnnotation>;
  export let BigIntLiteralTypeAnnotation: Type<BigIntLiteralTypeAnnotation>;
  export let StringTypeAnnotation: Type<StringTypeAnnotation>;
  export let StringLiteralTypeAnnotation: Type<StringLiteralTypeAnnotation>;
  export let BooleanTypeAnnotation: Type<BooleanTypeAnnotation>;
  export let BooleanLiteralTypeAnnotation: Type<BooleanLiteralTypeAnnotation>;
  export let NullableTypeAnnotation: Type<NullableTypeAnnotation>;
  export let NullLiteralTypeAnnotation: Type<NullLiteralTypeAnnotation>;
  export let NullTypeAnnotation: Type<NullTypeAnnotation>;
  export let ThisTypeAnnotation: Type<ThisTypeAnnotation>;
  export let ExistsTypeAnnotation: Type<ExistsTypeAnnotation>;
  export let ExistentialTypeParam: Type<ExistentialTypeParam>;
  export let FunctionTypeAnnotation: Type<FunctionTypeAnnotation>;
  export let FunctionTypeParam: Type<FunctionTypeParam>;
  export let ArrayTypeAnnotation: Type<ArrayTypeAnnotation>;
  export let ObjectTypeAnnotation: Type<ObjectTypeAnnotation>;
  export let ObjectTypeProperty: Type<ObjectTypeProperty>;
  export let ObjectTypeSpreadProperty: Type<ObjectTypeSpreadProperty>;
  export let ObjectTypeIndexer: Type<ObjectTypeIndexer>;
  export let ObjectTypeCallProperty: Type<ObjectTypeCallProperty>;
  export let ObjectTypeInternalSlot: Type<ObjectTypeInternalSlot>;
  export let Variance: Type<Variance>;
  export let QualifiedTypeIdentifier: Type<QualifiedTypeIdentifier>;
  export let GenericTypeAnnotation: Type<GenericTypeAnnotation>;
  export let MemberTypeAnnotation: Type<MemberTypeAnnotation>;
  export let UnionTypeAnnotation: Type<UnionTypeAnnotation>;
  export let IntersectionTypeAnnotation: Type<IntersectionTypeAnnotation>;
  export let TypeofTypeAnnotation: Type<TypeofTypeAnnotation>;
  export let TypeParameter: Type<TypeParameter>;
  export let InterfaceTypeAnnotation: Type<InterfaceTypeAnnotation>;
  export let InterfaceExtends: Type<InterfaceExtends>;
  export let InterfaceDeclaration: Type<InterfaceDeclaration>;
  export let TypeAlias: Type<TypeAlias>;
  export let DeclareTypeAlias: Type<DeclareTypeAlias>;
  export let OpaqueType: Type<OpaqueType>;
  export let DeclareOpaqueType: Type<DeclareOpaqueType>;
  export let TypeCastExpression: Type<TypeCastExpression>;
  export let TupleTypeAnnotation: Type<TupleTypeAnnotation>;
  export let DeclareVariable: Type<DeclareVariable>;
  export let DeclareFunction: Type<DeclareFunction>;
  export let FlowPredicate: Type<FlowPredicate>;
  export let DeclareClass: Type<DeclareClass>;
  export let DeclareModule: Type<DeclareModule>;
  export let DeclareModuleExports: Type<DeclareModuleExports>;
  export let DeclareExportDeclaration: Type<DeclareExportDeclaration>;
  export let ExportBatchSpecifier: Type<ExportBatchSpecifier>;
  export let DeclareExportAllDeclaration: Type<DeclareExportAllDeclaration>;
  export let InferredPredicate: Type<InferredPredicate>;
  export let DeclaredPredicate: Type<DeclaredPredicate>;
  export let EnumDeclaration: Type<EnumDeclaration>;
  export let EnumBooleanBody: Type<EnumBooleanBody>;
  export let EnumNumberBody: Type<EnumNumberBody>;
  export let EnumStringBody: Type<EnumStringBody>;
  export let EnumSymbolBody: Type<EnumSymbolBody>;
  export let EnumBooleanMember: Type<EnumBooleanMember>;
  export let EnumNumberMember: Type<EnumNumberMember>;
  export let EnumStringMember: Type<EnumStringMember>;
  export let EnumDefaultedMember: Type<EnumDefaultedMember>;
  export let ExportDeclaration: Type<ExportDeclaration>;
  export let Block: Type<Block>;
  export let Line: Type<Line>;
  export let Noop: Type<Noop>;
  export let DoExpression: Type<DoExpression>;
  export let BindExpression: Type<BindExpression>;
  export let ParenthesizedExpression: Type<ParenthesizedExpression>;
  export let ExportNamespaceSpecifier: Type<ExportNamespaceSpecifier>;
  export let ExportDefaultSpecifier: Type<ExportDefaultSpecifier>;
  export let CommentBlock: Type<CommentBlock>;
  export let CommentLine: Type<CommentLine>;
  export let Directive: Type<Directive>;
  export let DirectiveLiteral: Type<DirectiveLiteral>;
  export let InterpreterDirective: Type<InterpreterDirective>;
  export let StringLiteral: Type<StringLiteral>;
  export let NumericLiteral: Type<NumericLiteral>;
  export let BigIntLiteral: Type<BigIntLiteral>;
  export let NullLiteral: Type<NullLiteral>;
  export let BooleanLiteral: Type<BooleanLiteral>;
  export let RegExpLiteral: Type<RegExpLiteral>;
  export let ForAwaitStatement: Type<ForAwaitStatement>;
  export let Import: Type<Import>;
  export let TSQualifiedName: Type<TSQualifiedName>;
  export let TSTypeReference: Type<TSTypeReference>;
  export let TSHasOptionalTypeParameters: Type<TSHasOptionalTypeParameters>;
  export let TSHasOptionalTypeAnnotation: Type<TSHasOptionalTypeAnnotation>;
  export let TSAsExpression: Type<TSAsExpression>;
  export let TSNonNullExpression: Type<TSNonNullExpression>;
  export let TSAnyKeyword: Type<TSAnyKeyword>;
  export let TSBigIntKeyword: Type<TSBigIntKeyword>;
  export let TSBooleanKeyword: Type<TSBooleanKeyword>;
  export let TSNeverKeyword: Type<TSNeverKeyword>;
  export let TSNullKeyword: Type<TSNullKeyword>;
  export let TSNumberKeyword: Type<TSNumberKeyword>;
  export let TSObjectKeyword: Type<TSObjectKeyword>;
  export let TSStringKeyword: Type<TSStringKeyword>;
  export let TSSymbolKeyword: Type<TSSymbolKeyword>;
  export let TSUndefinedKeyword: Type<TSUndefinedKeyword>;
  export let TSUnknownKeyword: Type<TSUnknownKeyword>;
  export let TSVoidKeyword: Type<TSVoidKeyword>;
  export let TSThisType: Type<TSThisType>;
  export let TSArrayType: Type<TSArrayType>;
  export let TSLiteralType: Type<TSLiteralType>;
  export let TSUnionType: Type<TSUnionType>;
  export let TSIntersectionType: Type<TSIntersectionType>;
  export let TSConditionalType: Type<TSConditionalType>;
  export let TSInferType: Type<TSInferType>;
  export let TSTypeParameter: Type<TSTypeParameter>;
  export let TSParenthesizedType: Type<TSParenthesizedType>;
  export let TSFunctionType: Type<TSFunctionType>;
  export let TSConstructorType: Type<TSConstructorType>;
  export let TSDeclareFunction: Type<TSDeclareFunction>;
  export let TSDeclareMethod: Type<TSDeclareMethod>;
  export let TSMappedType: Type<TSMappedType>;
  export let TSTupleType: Type<TSTupleType>;
  export let TSNamedTupleMember: Type<TSNamedTupleMember>;
  export let TSRestType: Type<TSRestType>;
  export let TSOptionalType: Type<TSOptionalType>;
  export let TSIndexedAccessType: Type<TSIndexedAccessType>;
  export let TSTypeOperator: Type<TSTypeOperator>;
  export let TSTypeElement: Type<TSTypeElement>;
  export let TSIndexSignature: Type<TSIndexSignature>;
  export let TSPropertySignature: Type<TSPropertySignature>;
  export let TSMethodSignature: Type<TSMethodSignature>;
  export let TSTypePredicate: Type<TSTypePredicate>;
  export let TSCallSignatureDeclaration: Type<TSCallSignatureDeclaration>;
  export let TSConstructSignatureDeclaration: Type<TSConstructSignatureDeclaration>;
  export let TSEnumMember: Type<TSEnumMember>;
  export let TSTypeQuery: Type<TSTypeQuery>;
  export let TSImportType: Type<TSImportType>;
  export let TSTypeLiteral: Type<TSTypeLiteral>;
  export let TSTypeAssertion: Type<TSTypeAssertion>;
  export let TSEnumDeclaration: Type<TSEnumDeclaration>;
  export let TSTypeAliasDeclaration: Type<TSTypeAliasDeclaration>;
  export let TSModuleBlock: Type<TSModuleBlock>;
  export let TSModuleDeclaration: Type<TSModuleDeclaration>;
  export let TSImportEqualsDeclaration: Type<TSImportEqualsDeclaration>;
  export let TSExternalModuleReference: Type<TSExternalModuleReference>;
  export let TSExportAssignment: Type<TSExportAssignment>;
  export let TSNamespaceExportDeclaration: Type<TSNamespaceExportDeclaration>;
  export let TSInterfaceBody: Type<TSInterfaceBody>;
  export let TSInterfaceDeclaration: Type<TSInterfaceDeclaration>;
  export let TSParameterProperty: Type<TSParameterProperty>;
  export function assertNode(x: unknown): asserts x is Node {
    Node.assert(x);
  }
  export function assertBaseNode(x: unknown): asserts x is BaseNode {
    BaseNode.assert(x);
  }
  export function assertExpression(x: unknown): asserts x is Expression {
    Expression.assert(x);
  }
  export function assertBinary(x: unknown): asserts x is Binary {
    Binary.assert(x);
  }
  export function assertBinaryExpression(
    x: unknown
  ): asserts x is BinaryExpression {
    BinaryExpression.assert(x);
  }
  export function assertAssignmentExpression(
    x: unknown
  ): asserts x is AssignmentExpression {
    AssignmentExpression.assert(x);
  }
  export function assertScopable(x: unknown): asserts x is Scopable {
    Scopable.assert(x);
  }
  export function assertBlockParent(x: unknown): asserts x is BlockParent {
    BlockParent.assert(x);
  }
  export function assertFunction(x: unknown): asserts x is Function {
    Function.assert(x);
  }
  export function assertBaseFunction(x: unknown): asserts x is BaseFunction {
    BaseFunction.assert(x);
  }
  export function assertAwaitExpression(
    x: unknown
  ): asserts x is AwaitExpression {
    AwaitExpression.assert(x);
  }
  export function assertStatement(x: unknown): asserts x is Statement {
    Statement.assert(x);
  }
  export function assertLoop(x: unknown): asserts x is Loop {
    Loop.assert(x);
  }
  export function assertFor(x: unknown): asserts x is For {
    For.assert(x);
  }
  export function assertForX(x: unknown): asserts x is ForX {
    ForX.assert(x);
  }
  export function assertForOfStatement(
    x: unknown
  ): asserts x is ForOfStatement {
    ForOfStatement.assert(x);
  }
  export function assertObjectExpression(
    x: unknown
  ): asserts x is ObjectExpression {
    ObjectExpression.assert(x);
  }
  export function assertFunctionParent(
    x: unknown
  ): asserts x is FunctionParent {
    FunctionParent.assert(x);
  }
  export function assertObjectMethod(x: unknown): asserts x is ObjectMethod {
    ObjectMethod.assert(x);
  }
  export function assertObjectProperty(
    x: unknown
  ): asserts x is ObjectProperty {
    ObjectProperty.assert(x);
  }
  export function assertSpreadElement(x: unknown): asserts x is SpreadElement {
    SpreadElement.assert(x);
  }
  export function assertTemplateElement(
    x: unknown
  ): asserts x is TemplateElement {
    TemplateElement.assert(x);
  }
  export function assertCatchClause(x: unknown): asserts x is CatchClause {
    CatchClause.assert(x);
  }
  export function assertPatternLike(x: unknown): asserts x is PatternLike {
    PatternLike.assert(x);
  }
  export function assertLVal(x: unknown): asserts x is LVal {
    LVal.assert(x);
  }
  export function assertIdentifier(x: unknown): asserts x is Identifier {
    Identifier.assert(x);
  }
  export function assertPattern(x: unknown): asserts x is Pattern {
    Pattern.assert(x);
  }
  export function assertArrayPattern(x: unknown): asserts x is ArrayPattern {
    ArrayPattern.assert(x);
  }
  export function assertObjectPattern(x: unknown): asserts x is ObjectPattern {
    ObjectPattern.assert(x);
  }
  export function assertImportExpression(
    x: unknown
  ): asserts x is ImportExpression {
    ImportExpression.assert(x);
  }
  export function assertDeclaration(x: unknown): asserts x is Declaration {
    Declaration.assert(x);
  }
  export function assertExportAllDeclaration(
    x: unknown
  ): asserts x is ExportAllDeclaration {
    ExportAllDeclaration.assert(x);
  }
  export function assertPureish(x: unknown): asserts x is Pureish {
    Pureish.assert(x);
  }
  export function assertLiteral(x: unknown): asserts x is Literal {
    Literal.assert(x);
  }
  export function assertChainElement(x: unknown): asserts x is ChainElement {
    ChainElement.assert(x);
  }
  export function assertCallExpression(
    x: unknown
  ): asserts x is CallExpression {
    CallExpression.assert(x);
  }
  export function assertMemberExpression(
    x: unknown
  ): asserts x is MemberExpression {
    MemberExpression.assert(x);
  }
  export function assertChainExpression(
    x: unknown
  ): asserts x is ChainExpression {
    ChainExpression.assert(x);
  }
  export function assertOptionalCallExpression(
    x: unknown
  ): asserts x is OptionalCallExpression {
    OptionalCallExpression.assert(x);
  }
  export function assertOptionalMemberExpression(
    x: unknown
  ): asserts x is OptionalMemberExpression {
    OptionalMemberExpression.assert(x);
  }
  export function assertLogicalExpression(
    x: unknown
  ): asserts x is LogicalExpression {
    LogicalExpression.assert(x);
  }
  export function assertDecorator(x: unknown): asserts x is Decorator {
    Decorator.assert(x);
  }
  export function assertProperty(x: unknown): asserts x is Property {
    Property.assert(x);
  }
  export function assertMethodDefinition(
    x: unknown
  ): asserts x is MethodDefinition {
    MethodDefinition.assert(x);
  }
  export function assertPrivateName(x: unknown): asserts x is PrivateName {
    PrivateName.assert(x);
  }
  export function assertClassPrivateProperty(
    x: unknown
  ): asserts x is ClassPrivateProperty {
    ClassPrivateProperty.assert(x);
  }
  export function assertComment(x: unknown): asserts x is Comment {
    Comment.assert(x);
  }
  export function assertSourceLocation(
    x: unknown
  ): asserts x is SourceLocation {
    SourceLocation.assert(x);
  }
  export function assertPosition(x: unknown): asserts x is Position {
    Position.assert(x);
  }
  export function assertFile(x: unknown): asserts x is File {
    File.assert(x);
  }
  export function assertProgram(x: unknown): asserts x is Program {
    Program.assert(x);
  }
  export function assertBlockStatement(
    x: unknown
  ): asserts x is BlockStatement {
    BlockStatement.assert(x);
  }
  export function assertEmptyStatement(
    x: unknown
  ): asserts x is EmptyStatement {
    EmptyStatement.assert(x);
  }
  export function assertExpressionStatement(
    x: unknown
  ): asserts x is ExpressionStatement {
    ExpressionStatement.assert(x);
  }
  export function assertConditional(x: unknown): asserts x is Conditional {
    Conditional.assert(x);
  }
  export function assertIfStatement(x: unknown): asserts x is IfStatement {
    IfStatement.assert(x);
  }
  export function assertLabeledStatement(
    x: unknown
  ): asserts x is LabeledStatement {
    LabeledStatement.assert(x);
  }
  export function assertCompletionStatement(
    x: unknown
  ): asserts x is CompletionStatement {
    CompletionStatement.assert(x);
  }
  export function assertBreakStatement(
    x: unknown
  ): asserts x is BreakStatement {
    BreakStatement.assert(x);
  }
  export function assertContinueStatement(
    x: unknown
  ): asserts x is ContinueStatement {
    ContinueStatement.assert(x);
  }
  export function assertWithStatement(x: unknown): asserts x is WithStatement {
    WithStatement.assert(x);
  }
  export function assertSwitchStatement(
    x: unknown
  ): asserts x is SwitchStatement {
    SwitchStatement.assert(x);
  }
  export function assertSwitchCase(x: unknown): asserts x is SwitchCase {
    SwitchCase.assert(x);
  }
  export function assertReturnStatement(
    x: unknown
  ): asserts x is ReturnStatement {
    ReturnStatement.assert(x);
  }
  export function assertThrowStatement(
    x: unknown
  ): asserts x is ThrowStatement {
    ThrowStatement.assert(x);
  }
  export function assertTryStatement(x: unknown): asserts x is TryStatement {
    TryStatement.assert(x);
  }
  export function assertWhile(x: unknown): asserts x is While {
    While.assert(x);
  }
  export function assertWhileStatement(
    x: unknown
  ): asserts x is WhileStatement {
    WhileStatement.assert(x);
  }
  export function assertDoWhileStatement(
    x: unknown
  ): asserts x is DoWhileStatement {
    DoWhileStatement.assert(x);
  }
  export function assertForStatement(x: unknown): asserts x is ForStatement {
    ForStatement.assert(x);
  }
  export function assertVariableDeclaration(
    x: unknown
  ): asserts x is VariableDeclaration {
    VariableDeclaration.assert(x);
  }
  export function assertForInStatement(
    x: unknown
  ): asserts x is ForInStatement {
    ForInStatement.assert(x);
  }
  export function assertDebuggerStatement(
    x: unknown
  ): asserts x is DebuggerStatement {
    DebuggerStatement.assert(x);
  }
  export function assertFunctionDeclaration(
    x: unknown
  ): asserts x is FunctionDeclaration {
    FunctionDeclaration.assert(x);
  }
  export function assertFunctionExpression(
    x: unknown
  ): asserts x is FunctionExpression {
    FunctionExpression.assert(x);
  }
  export function assertVariableDeclarator(
    x: unknown
  ): asserts x is VariableDeclarator {
    VariableDeclarator.assert(x);
  }
  export function assertThisExpression(
    x: unknown
  ): asserts x is ThisExpression {
    ThisExpression.assert(x);
  }
  export function assertArrayExpression(
    x: unknown
  ): asserts x is ArrayExpression {
    ArrayExpression.assert(x);
  }
  export function assertSequenceExpression(
    x: unknown
  ): asserts x is SequenceExpression {
    SequenceExpression.assert(x);
  }
  export function assertUnaryExpression(
    x: unknown
  ): asserts x is UnaryExpression {
    UnaryExpression.assert(x);
  }
  export function assertUpdateExpression(
    x: unknown
  ): asserts x is UpdateExpression {
    UpdateExpression.assert(x);
  }
  export function assertConditionalExpression(
    x: unknown
  ): asserts x is ConditionalExpression {
    ConditionalExpression.assert(x);
  }
  export function assertNewExpression(x: unknown): asserts x is NewExpression {
    NewExpression.assert(x);
  }
  export function assertBaseComment(x: unknown): asserts x is BaseComment {
    BaseComment.assert(x);
  }
  export function assertRestElement(x: unknown): asserts x is RestElement {
    RestElement.assert(x);
  }
  export function assertArrowFunctionExpression(
    x: unknown
  ): asserts x is ArrowFunctionExpression {
    ArrowFunctionExpression.assert(x);
  }
  export function assertYieldExpression(
    x: unknown
  ): asserts x is YieldExpression {
    YieldExpression.assert(x);
  }
  export function assertGeneratorExpression(
    x: unknown
  ): asserts x is GeneratorExpression {
    GeneratorExpression.assert(x);
  }
  export function assertComprehensionBlock(
    x: unknown
  ): asserts x is ComprehensionBlock {
    ComprehensionBlock.assert(x);
  }
  export function assertComprehensionExpression(
    x: unknown
  ): asserts x is ComprehensionExpression {
    ComprehensionExpression.assert(x);
  }
  export function assertAssignmentPattern(
    x: unknown
  ): asserts x is AssignmentPattern {
    AssignmentPattern.assert(x);
  }
  export function assertClassPropertyDefinition(
    x: unknown
  ): asserts x is ClassPropertyDefinition {
    ClassPropertyDefinition.assert(x);
  }
  export function assertClassProperty(x: unknown): asserts x is ClassProperty {
    ClassProperty.assert(x);
  }
  export function assertClassBody(x: unknown): asserts x is ClassBody {
    ClassBody.assert(x);
  }
  export function assertClass(x: unknown): asserts x is Class {
    Class.assert(x);
  }
  export function assertClassDeclaration(
    x: unknown
  ): asserts x is ClassDeclaration {
    ClassDeclaration.assert(x);
  }
  export function assertClassExpression(
    x: unknown
  ): asserts x is ClassExpression {
    ClassExpression.assert(x);
  }
  export function assertSuper(x: unknown): asserts x is Super {
    Super.assert(x);
  }
  export function assertSpecifier(x: unknown): asserts x is Specifier {
    Specifier.assert(x);
  }
  export function assertModuleSpecifier(
    x: unknown
  ): asserts x is ModuleSpecifier {
    ModuleSpecifier.assert(x);
  }
  export function assertImportSpecifier(
    x: unknown
  ): asserts x is ImportSpecifier {
    ImportSpecifier.assert(x);
  }
  export function assertImportDefaultSpecifier(
    x: unknown
  ): asserts x is ImportDefaultSpecifier {
    ImportDefaultSpecifier.assert(x);
  }
  export function assertImportNamespaceSpecifier(
    x: unknown
  ): asserts x is ImportNamespaceSpecifier {
    ImportNamespaceSpecifier.assert(x);
  }
  export function assertImportDeclaration(
    x: unknown
  ): asserts x is ImportDeclaration {
    ImportDeclaration.assert(x);
  }
  export function assertExportNamedDeclaration(
    x: unknown
  ): asserts x is ExportNamedDeclaration {
    ExportNamedDeclaration.assert(x);
  }
  export function assertExportSpecifier(
    x: unknown
  ): asserts x is ExportSpecifier {
    ExportSpecifier.assert(x);
  }
  export function assertExportDefaultDeclaration(
    x: unknown
  ): asserts x is ExportDefaultDeclaration {
    ExportDefaultDeclaration.assert(x);
  }
  export function assertTaggedTemplateExpression(
    x: unknown
  ): asserts x is TaggedTemplateExpression {
    TaggedTemplateExpression.assert(x);
  }
  export function assertTemplateLiteral(
    x: unknown
  ): asserts x is TemplateLiteral {
    TemplateLiteral.assert(x);
  }
  export function assertMetaProperty(x: unknown): asserts x is MetaProperty {
    MetaProperty.assert(x);
  }
  export function assertJSX(x: unknown): asserts x is JSX {
    JSX.assert(x);
  }
  export function assertJSXAttribute(x: unknown): asserts x is JSXAttribute {
    JSXAttribute.assert(x);
  }
  export function assertJSXIdentifier(x: unknown): asserts x is JSXIdentifier {
    JSXIdentifier.assert(x);
  }
  export function assertJSXNamespacedName(
    x: unknown
  ): asserts x is JSXNamespacedName {
    JSXNamespacedName.assert(x);
  }
  export function assertJSXExpressionContainer(
    x: unknown
  ): asserts x is JSXExpressionContainer {
    JSXExpressionContainer.assert(x);
  }
  export function assertJSXElement(x: unknown): asserts x is JSXElement {
    JSXElement.assert(x);
  }
  export function assertJSXFragment(x: unknown): asserts x is JSXFragment {
    JSXFragment.assert(x);
  }
  export function assertJSXMemberExpression(
    x: unknown
  ): asserts x is JSXMemberExpression {
    JSXMemberExpression.assert(x);
  }
  export function assertJSXSpreadAttribute(
    x: unknown
  ): asserts x is JSXSpreadAttribute {
    JSXSpreadAttribute.assert(x);
  }
  export function assertJSXEmptyExpression(
    x: unknown
  ): asserts x is JSXEmptyExpression {
    JSXEmptyExpression.assert(x);
  }
  export function assertJSXText(x: unknown): asserts x is JSXText {
    JSXText.assert(x);
  }
  export function assertJSXSpreadChild(
    x: unknown
  ): asserts x is JSXSpreadChild {
    JSXSpreadChild.assert(x);
  }
  export function assertJSXOpeningElement(
    x: unknown
  ): asserts x is JSXOpeningElement {
    JSXOpeningElement.assert(x);
  }
  export function assertJSXClosingElement(
    x: unknown
  ): asserts x is JSXClosingElement {
    JSXClosingElement.assert(x);
  }
  export function assertJSXOpeningFragment(
    x: unknown
  ): asserts x is JSXOpeningFragment {
    JSXOpeningFragment.assert(x);
  }
  export function assertJSXClosingFragment(
    x: unknown
  ): asserts x is JSXClosingFragment {
    JSXClosingFragment.assert(x);
  }
  export function assertTypeAnnotation(
    x: unknown
  ): asserts x is TypeAnnotation {
    TypeAnnotation.assert(x);
  }
  export function assertTSTypeAnnotation(
    x: unknown
  ): asserts x is TSTypeAnnotation {
    TSTypeAnnotation.assert(x);
  }
  export function assertTypeParameterDeclaration(
    x: unknown
  ): asserts x is TypeParameterDeclaration {
    TypeParameterDeclaration.assert(x);
  }
  export function assertTSTypeParameterDeclaration(
    x: unknown
  ): asserts x is TSTypeParameterDeclaration {
    TSTypeParameterDeclaration.assert(x);
  }
  export function assertClassMethod(x: unknown): asserts x is ClassMethod {
    ClassMethod.assert(x);
  }
  export function assertClassPrivateMethod(
    x: unknown
  ): asserts x is ClassPrivateMethod {
    ClassPrivateMethod.assert(x);
  }
  export function assertTypeParameterInstantiation(
    x: unknown
  ): asserts x is TypeParameterInstantiation {
    TypeParameterInstantiation.assert(x);
  }
  export function assertTSTypeParameterInstantiation(
    x: unknown
  ): asserts x is TSTypeParameterInstantiation {
    TSTypeParameterInstantiation.assert(x);
  }
  export function assertClassImplements(
    x: unknown
  ): asserts x is ClassImplements {
    ClassImplements.assert(x);
  }
  export function assertTSHasOptionalTypeParameterInstantiation(
    x: unknown
  ): asserts x is TSHasOptionalTypeParameterInstantiation {
    TSHasOptionalTypeParameterInstantiation.assert(x);
  }
  export function assertTSType(x: unknown): asserts x is TSType {
    TSType.assert(x);
  }
  export function assertTSExpressionWithTypeArguments(
    x: unknown
  ): asserts x is TSExpressionWithTypeArguments {
    TSExpressionWithTypeArguments.assert(x);
  }
  export function assertFlow(x: unknown): asserts x is Flow {
    Flow.assert(x);
  }
  export function assertFlowType(x: unknown): asserts x is FlowType {
    FlowType.assert(x);
  }
  export function assertAnyTypeAnnotation(
    x: unknown
  ): asserts x is AnyTypeAnnotation {
    AnyTypeAnnotation.assert(x);
  }
  export function assertEmptyTypeAnnotation(
    x: unknown
  ): asserts x is EmptyTypeAnnotation {
    EmptyTypeAnnotation.assert(x);
  }
  export function assertMixedTypeAnnotation(
    x: unknown
  ): asserts x is MixedTypeAnnotation {
    MixedTypeAnnotation.assert(x);
  }
  export function assertVoidTypeAnnotation(
    x: unknown
  ): asserts x is VoidTypeAnnotation {
    VoidTypeAnnotation.assert(x);
  }
  export function assertSymbolTypeAnnotation(
    x: unknown
  ): asserts x is SymbolTypeAnnotation {
    SymbolTypeAnnotation.assert(x);
  }
  export function assertNumberTypeAnnotation(
    x: unknown
  ): asserts x is NumberTypeAnnotation {
    NumberTypeAnnotation.assert(x);
  }
  export function assertBigIntTypeAnnotation(
    x: unknown
  ): asserts x is BigIntTypeAnnotation {
    BigIntTypeAnnotation.assert(x);
  }
  export function assertNumberLiteralTypeAnnotation(
    x: unknown
  ): asserts x is NumberLiteralTypeAnnotation {
    NumberLiteralTypeAnnotation.assert(x);
  }
  export function assertNumericLiteralTypeAnnotation(
    x: unknown
  ): asserts x is NumericLiteralTypeAnnotation {
    NumericLiteralTypeAnnotation.assert(x);
  }
  export function assertBigIntLiteralTypeAnnotation(
    x: unknown
  ): asserts x is BigIntLiteralTypeAnnotation {
    BigIntLiteralTypeAnnotation.assert(x);
  }
  export function assertStringTypeAnnotation(
    x: unknown
  ): asserts x is StringTypeAnnotation {
    StringTypeAnnotation.assert(x);
  }
  export function assertStringLiteralTypeAnnotation(
    x: unknown
  ): asserts x is StringLiteralTypeAnnotation {
    StringLiteralTypeAnnotation.assert(x);
  }
  export function assertBooleanTypeAnnotation(
    x: unknown
  ): asserts x is BooleanTypeAnnotation {
    BooleanTypeAnnotation.assert(x);
  }
  export function assertBooleanLiteralTypeAnnotation(
    x: unknown
  ): asserts x is BooleanLiteralTypeAnnotation {
    BooleanLiteralTypeAnnotation.assert(x);
  }
  export function assertNullableTypeAnnotation(
    x: unknown
  ): asserts x is NullableTypeAnnotation {
    NullableTypeAnnotation.assert(x);
  }
  export function assertNullLiteralTypeAnnotation(
    x: unknown
  ): asserts x is NullLiteralTypeAnnotation {
    NullLiteralTypeAnnotation.assert(x);
  }
  export function assertNullTypeAnnotation(
    x: unknown
  ): asserts x is NullTypeAnnotation {
    NullTypeAnnotation.assert(x);
  }
  export function assertThisTypeAnnotation(
    x: unknown
  ): asserts x is ThisTypeAnnotation {
    ThisTypeAnnotation.assert(x);
  }
  export function assertExistsTypeAnnotation(
    x: unknown
  ): asserts x is ExistsTypeAnnotation {
    ExistsTypeAnnotation.assert(x);
  }
  export function assertExistentialTypeParam(
    x: unknown
  ): asserts x is ExistentialTypeParam {
    ExistentialTypeParam.assert(x);
  }
  export function assertFunctionTypeAnnotation(
    x: unknown
  ): asserts x is FunctionTypeAnnotation {
    FunctionTypeAnnotation.assert(x);
  }
  export function assertFunctionTypeParam(
    x: unknown
  ): asserts x is FunctionTypeParam {
    FunctionTypeParam.assert(x);
  }
  export function assertArrayTypeAnnotation(
    x: unknown
  ): asserts x is ArrayTypeAnnotation {
    ArrayTypeAnnotation.assert(x);
  }
  export function assertObjectTypeAnnotation(
    x: unknown
  ): asserts x is ObjectTypeAnnotation {
    ObjectTypeAnnotation.assert(x);
  }
  export function assertObjectTypeProperty(
    x: unknown
  ): asserts x is ObjectTypeProperty {
    ObjectTypeProperty.assert(x);
  }
  export function assertObjectTypeSpreadProperty(
    x: unknown
  ): asserts x is ObjectTypeSpreadProperty {
    ObjectTypeSpreadProperty.assert(x);
  }
  export function assertObjectTypeIndexer(
    x: unknown
  ): asserts x is ObjectTypeIndexer {
    ObjectTypeIndexer.assert(x);
  }
  export function assertObjectTypeCallProperty(
    x: unknown
  ): asserts x is ObjectTypeCallProperty {
    ObjectTypeCallProperty.assert(x);
  }
  export function assertObjectTypeInternalSlot(
    x: unknown
  ): asserts x is ObjectTypeInternalSlot {
    ObjectTypeInternalSlot.assert(x);
  }
  export function assertVariance(x: unknown): asserts x is Variance {
    Variance.assert(x);
  }
  export function assertQualifiedTypeIdentifier(
    x: unknown
  ): asserts x is QualifiedTypeIdentifier {
    QualifiedTypeIdentifier.assert(x);
  }
  export function assertGenericTypeAnnotation(
    x: unknown
  ): asserts x is GenericTypeAnnotation {
    GenericTypeAnnotation.assert(x);
  }
  export function assertMemberTypeAnnotation(
    x: unknown
  ): asserts x is MemberTypeAnnotation {
    MemberTypeAnnotation.assert(x);
  }
  export function assertUnionTypeAnnotation(
    x: unknown
  ): asserts x is UnionTypeAnnotation {
    UnionTypeAnnotation.assert(x);
  }
  export function assertIntersectionTypeAnnotation(
    x: unknown
  ): asserts x is IntersectionTypeAnnotation {
    IntersectionTypeAnnotation.assert(x);
  }
  export function assertTypeofTypeAnnotation(
    x: unknown
  ): asserts x is TypeofTypeAnnotation {
    TypeofTypeAnnotation.assert(x);
  }
  export function assertTypeParameter(x: unknown): asserts x is TypeParameter {
    TypeParameter.assert(x);
  }
  export function assertInterfaceTypeAnnotation(
    x: unknown
  ): asserts x is InterfaceTypeAnnotation {
    InterfaceTypeAnnotation.assert(x);
  }
  export function assertInterfaceExtends(
    x: unknown
  ): asserts x is InterfaceExtends {
    InterfaceExtends.assert(x);
  }
  export function assertInterfaceDeclaration(
    x: unknown
  ): asserts x is InterfaceDeclaration {
    InterfaceDeclaration.assert(x);
  }
  export function assertTypeAlias(x: unknown): asserts x is TypeAlias {
    TypeAlias.assert(x);
  }
  export function assertDeclareTypeAlias(
    x: unknown
  ): asserts x is DeclareTypeAlias {
    DeclareTypeAlias.assert(x);
  }
  export function assertOpaqueType(x: unknown): asserts x is OpaqueType {
    OpaqueType.assert(x);
  }
  export function assertDeclareOpaqueType(
    x: unknown
  ): asserts x is DeclareOpaqueType {
    DeclareOpaqueType.assert(x);
  }
  export function assertTypeCastExpression(
    x: unknown
  ): asserts x is TypeCastExpression {
    TypeCastExpression.assert(x);
  }
  export function assertTupleTypeAnnotation(
    x: unknown
  ): asserts x is TupleTypeAnnotation {
    TupleTypeAnnotation.assert(x);
  }
  export function assertDeclareVariable(
    x: unknown
  ): asserts x is DeclareVariable {
    DeclareVariable.assert(x);
  }
  export function assertDeclareFunction(
    x: unknown
  ): asserts x is DeclareFunction {
    DeclareFunction.assert(x);
  }
  export function assertFlowPredicate(x: unknown): asserts x is FlowPredicate {
    FlowPredicate.assert(x);
  }
  export function assertDeclareClass(x: unknown): asserts x is DeclareClass {
    DeclareClass.assert(x);
  }
  export function assertDeclareModule(x: unknown): asserts x is DeclareModule {
    DeclareModule.assert(x);
  }
  export function assertDeclareModuleExports(
    x: unknown
  ): asserts x is DeclareModuleExports {
    DeclareModuleExports.assert(x);
  }
  export function assertDeclareExportDeclaration(
    x: unknown
  ): asserts x is DeclareExportDeclaration {
    DeclareExportDeclaration.assert(x);
  }
  export function assertExportBatchSpecifier(
    x: unknown
  ): asserts x is ExportBatchSpecifier {
    ExportBatchSpecifier.assert(x);
  }
  export function assertDeclareExportAllDeclaration(
    x: unknown
  ): asserts x is DeclareExportAllDeclaration {
    DeclareExportAllDeclaration.assert(x);
  }
  export function assertInferredPredicate(
    x: unknown
  ): asserts x is InferredPredicate {
    InferredPredicate.assert(x);
  }
  export function assertDeclaredPredicate(
    x: unknown
  ): asserts x is DeclaredPredicate {
    DeclaredPredicate.assert(x);
  }
  export function assertEnumDeclaration(
    x: unknown
  ): asserts x is EnumDeclaration {
    EnumDeclaration.assert(x);
  }
  export function assertEnumBooleanBody(
    x: unknown
  ): asserts x is EnumBooleanBody {
    EnumBooleanBody.assert(x);
  }
  export function assertEnumNumberBody(
    x: unknown
  ): asserts x is EnumNumberBody {
    EnumNumberBody.assert(x);
  }
  export function assertEnumStringBody(
    x: unknown
  ): asserts x is EnumStringBody {
    EnumStringBody.assert(x);
  }
  export function assertEnumSymbolBody(
    x: unknown
  ): asserts x is EnumSymbolBody {
    EnumSymbolBody.assert(x);
  }
  export function assertEnumBooleanMember(
    x: unknown
  ): asserts x is EnumBooleanMember {
    EnumBooleanMember.assert(x);
  }
  export function assertEnumNumberMember(
    x: unknown
  ): asserts x is EnumNumberMember {
    EnumNumberMember.assert(x);
  }
  export function assertEnumStringMember(
    x: unknown
  ): asserts x is EnumStringMember {
    EnumStringMember.assert(x);
  }
  export function assertEnumDefaultedMember(
    x: unknown
  ): asserts x is EnumDefaultedMember {
    EnumDefaultedMember.assert(x);
  }
  export function assertExportDeclaration(
    x: unknown
  ): asserts x is ExportDeclaration {
    ExportDeclaration.assert(x);
  }
  export function assertBlock(x: unknown): asserts x is Block {
    Block.assert(x);
  }
  export function assertLine(x: unknown): asserts x is Line {
    Line.assert(x);
  }
  export function assertNoop(x: unknown): asserts x is Noop {
    Noop.assert(x);
  }
  export function assertDoExpression(x: unknown): asserts x is DoExpression {
    DoExpression.assert(x);
  }
  export function assertBindExpression(
    x: unknown
  ): asserts x is BindExpression {
    BindExpression.assert(x);
  }
  export function assertParenthesizedExpression(
    x: unknown
  ): asserts x is ParenthesizedExpression {
    ParenthesizedExpression.assert(x);
  }
  export function assertExportNamespaceSpecifier(
    x: unknown
  ): asserts x is ExportNamespaceSpecifier {
    ExportNamespaceSpecifier.assert(x);
  }
  export function assertExportDefaultSpecifier(
    x: unknown
  ): asserts x is ExportDefaultSpecifier {
    ExportDefaultSpecifier.assert(x);
  }
  export function assertCommentBlock(x: unknown): asserts x is CommentBlock {
    CommentBlock.assert(x);
  }
  export function assertCommentLine(x: unknown): asserts x is CommentLine {
    CommentLine.assert(x);
  }
  export function assertDirective(x: unknown): asserts x is Directive {
    Directive.assert(x);
  }
  export function assertDirectiveLiteral(
    x: unknown
  ): asserts x is DirectiveLiteral {
    DirectiveLiteral.assert(x);
  }
  export function assertInterpreterDirective(
    x: unknown
  ): asserts x is InterpreterDirective {
    InterpreterDirective.assert(x);
  }
  export function assertStringLiteral(x: unknown): asserts x is StringLiteral {
    StringLiteral.assert(x);
  }
  export function assertNumericLiteral(
    x: unknown
  ): asserts x is NumericLiteral {
    NumericLiteral.assert(x);
  }
  export function assertBigIntLiteral(x: unknown): asserts x is BigIntLiteral {
    BigIntLiteral.assert(x);
  }
  export function assertNullLiteral(x: unknown): asserts x is NullLiteral {
    NullLiteral.assert(x);
  }
  export function assertBooleanLiteral(
    x: unknown
  ): asserts x is BooleanLiteral {
    BooleanLiteral.assert(x);
  }
  export function assertRegExpLiteral(x: unknown): asserts x is RegExpLiteral {
    RegExpLiteral.assert(x);
  }
  export function assertForAwaitStatement(
    x: unknown
  ): asserts x is ForAwaitStatement {
    ForAwaitStatement.assert(x);
  }
  export function assertImport(x: unknown): asserts x is Import {
    Import.assert(x);
  }
  export function assertTSQualifiedName(
    x: unknown
  ): asserts x is TSQualifiedName {
    TSQualifiedName.assert(x);
  }
  export function assertTSTypeReference(
    x: unknown
  ): asserts x is TSTypeReference {
    TSTypeReference.assert(x);
  }
  export function assertTSHasOptionalTypeParameters(
    x: unknown
  ): asserts x is TSHasOptionalTypeParameters {
    TSHasOptionalTypeParameters.assert(x);
  }
  export function assertTSHasOptionalTypeAnnotation(
    x: unknown
  ): asserts x is TSHasOptionalTypeAnnotation {
    TSHasOptionalTypeAnnotation.assert(x);
  }
  export function assertTSAsExpression(
    x: unknown
  ): asserts x is TSAsExpression {
    TSAsExpression.assert(x);
  }
  export function assertTSNonNullExpression(
    x: unknown
  ): asserts x is TSNonNullExpression {
    TSNonNullExpression.assert(x);
  }
  export function assertTSAnyKeyword(x: unknown): asserts x is TSAnyKeyword {
    TSAnyKeyword.assert(x);
  }
  export function assertTSBigIntKeyword(
    x: unknown
  ): asserts x is TSBigIntKeyword {
    TSBigIntKeyword.assert(x);
  }
  export function assertTSBooleanKeyword(
    x: unknown
  ): asserts x is TSBooleanKeyword {
    TSBooleanKeyword.assert(x);
  }
  export function assertTSNeverKeyword(
    x: unknown
  ): asserts x is TSNeverKeyword {
    TSNeverKeyword.assert(x);
  }
  export function assertTSNullKeyword(x: unknown): asserts x is TSNullKeyword {
    TSNullKeyword.assert(x);
  }
  export function assertTSNumberKeyword(
    x: unknown
  ): asserts x is TSNumberKeyword {
    TSNumberKeyword.assert(x);
  }
  export function assertTSObjectKeyword(
    x: unknown
  ): asserts x is TSObjectKeyword {
    TSObjectKeyword.assert(x);
  }
  export function assertTSStringKeyword(
    x: unknown
  ): asserts x is TSStringKeyword {
    TSStringKeyword.assert(x);
  }
  export function assertTSSymbolKeyword(
    x: unknown
  ): asserts x is TSSymbolKeyword {
    TSSymbolKeyword.assert(x);
  }
  export function assertTSUndefinedKeyword(
    x: unknown
  ): asserts x is TSUndefinedKeyword {
    TSUndefinedKeyword.assert(x);
  }
  export function assertTSUnknownKeyword(
    x: unknown
  ): asserts x is TSUnknownKeyword {
    TSUnknownKeyword.assert(x);
  }
  export function assertTSVoidKeyword(x: unknown): asserts x is TSVoidKeyword {
    TSVoidKeyword.assert(x);
  }
  export function assertTSThisType(x: unknown): asserts x is TSThisType {
    TSThisType.assert(x);
  }
  export function assertTSArrayType(x: unknown): asserts x is TSArrayType {
    TSArrayType.assert(x);
  }
  export function assertTSLiteralType(x: unknown): asserts x is TSLiteralType {
    TSLiteralType.assert(x);
  }
  export function assertTSUnionType(x: unknown): asserts x is TSUnionType {
    TSUnionType.assert(x);
  }
  export function assertTSIntersectionType(
    x: unknown
  ): asserts x is TSIntersectionType {
    TSIntersectionType.assert(x);
  }
  export function assertTSConditionalType(
    x: unknown
  ): asserts x is TSConditionalType {
    TSConditionalType.assert(x);
  }
  export function assertTSInferType(x: unknown): asserts x is TSInferType {
    TSInferType.assert(x);
  }
  export function assertTSTypeParameter(
    x: unknown
  ): asserts x is TSTypeParameter {
    TSTypeParameter.assert(x);
  }
  export function assertTSParenthesizedType(
    x: unknown
  ): asserts x is TSParenthesizedType {
    TSParenthesizedType.assert(x);
  }
  export function assertTSFunctionType(
    x: unknown
  ): asserts x is TSFunctionType {
    TSFunctionType.assert(x);
  }
  export function assertTSConstructorType(
    x: unknown
  ): asserts x is TSConstructorType {
    TSConstructorType.assert(x);
  }
  export function assertTSDeclareFunction(
    x: unknown
  ): asserts x is TSDeclareFunction {
    TSDeclareFunction.assert(x);
  }
  export function assertTSDeclareMethod(
    x: unknown
  ): asserts x is TSDeclareMethod {
    TSDeclareMethod.assert(x);
  }
  export function assertTSMappedType(x: unknown): asserts x is TSMappedType {
    TSMappedType.assert(x);
  }
  export function assertTSTupleType(x: unknown): asserts x is TSTupleType {
    TSTupleType.assert(x);
  }
  export function assertTSNamedTupleMember(
    x: unknown
  ): asserts x is TSNamedTupleMember {
    TSNamedTupleMember.assert(x);
  }
  export function assertTSRestType(x: unknown): asserts x is TSRestType {
    TSRestType.assert(x);
  }
  export function assertTSOptionalType(
    x: unknown
  ): asserts x is TSOptionalType {
    TSOptionalType.assert(x);
  }
  export function assertTSIndexedAccessType(
    x: unknown
  ): asserts x is TSIndexedAccessType {
    TSIndexedAccessType.assert(x);
  }
  export function assertTSTypeOperator(
    x: unknown
  ): asserts x is TSTypeOperator {
    TSTypeOperator.assert(x);
  }
  export function assertTSTypeElement(x: unknown): asserts x is TSTypeElement {
    TSTypeElement.assert(x);
  }
  export function assertTSIndexSignature(
    x: unknown
  ): asserts x is TSIndexSignature {
    TSIndexSignature.assert(x);
  }
  export function assertTSPropertySignature(
    x: unknown
  ): asserts x is TSPropertySignature {
    TSPropertySignature.assert(x);
  }
  export function assertTSMethodSignature(
    x: unknown
  ): asserts x is TSMethodSignature {
    TSMethodSignature.assert(x);
  }
  export function assertTSTypePredicate(
    x: unknown
  ): asserts x is TSTypePredicate {
    TSTypePredicate.assert(x);
  }
  export function assertTSCallSignatureDeclaration(
    x: unknown
  ): asserts x is TSCallSignatureDeclaration {
    TSCallSignatureDeclaration.assert(x);
  }
  export function assertTSConstructSignatureDeclaration(
    x: unknown
  ): asserts x is TSConstructSignatureDeclaration {
    TSConstructSignatureDeclaration.assert(x);
  }
  export function assertTSEnumMember(x: unknown): asserts x is TSEnumMember {
    TSEnumMember.assert(x);
  }
  export function assertTSTypeQuery(x: unknown): asserts x is TSTypeQuery {
    TSTypeQuery.assert(x);
  }
  export function assertTSImportType(x: unknown): asserts x is TSImportType {
    TSImportType.assert(x);
  }
  export function assertTSTypeLiteral(x: unknown): asserts x is TSTypeLiteral {
    TSTypeLiteral.assert(x);
  }
  export function assertTSTypeAssertion(
    x: unknown
  ): asserts x is TSTypeAssertion {
    TSTypeAssertion.assert(x);
  }
  export function assertTSEnumDeclaration(
    x: unknown
  ): asserts x is TSEnumDeclaration {
    TSEnumDeclaration.assert(x);
  }
  export function assertTSTypeAliasDeclaration(
    x: unknown
  ): asserts x is TSTypeAliasDeclaration {
    TSTypeAliasDeclaration.assert(x);
  }
  export function assertTSModuleBlock(x: unknown): asserts x is TSModuleBlock {
    TSModuleBlock.assert(x);
  }
  export function assertTSModuleDeclaration(
    x: unknown
  ): asserts x is TSModuleDeclaration {
    TSModuleDeclaration.assert(x);
  }
  export function assertTSImportEqualsDeclaration(
    x: unknown
  ): asserts x is TSImportEqualsDeclaration {
    TSImportEqualsDeclaration.assert(x);
  }
  export function assertTSExternalModuleReference(
    x: unknown
  ): asserts x is TSExternalModuleReference {
    TSExternalModuleReference.assert(x);
  }
  export function assertTSExportAssignment(
    x: unknown
  ): asserts x is TSExportAssignment {
    TSExportAssignment.assert(x);
  }
  export function assertTSNamespaceExportDeclaration(
    x: unknown
  ): asserts x is TSNamespaceExportDeclaration {
    TSNamespaceExportDeclaration.assert(x);
  }
  export function assertTSInterfaceBody(
    x: unknown
  ): asserts x is TSInterfaceBody {
    TSInterfaceBody.assert(x);
  }
  export function assertTSInterfaceDeclaration(
    x: unknown
  ): asserts x is TSInterfaceDeclaration {
    TSInterfaceDeclaration.assert(x);
  }
  export function assertTSParameterProperty(
    x: unknown
  ): asserts x is TSParameterProperty {
    TSParameterProperty.assert(x);
  }
}
export interface NamedTypes {
  Node: Type<namedTypes.Node>;
  BaseNode: Type<namedTypes.BaseNode>;
  Expression: Type<namedTypes.Expression>;
  Binary: Type<namedTypes.Binary>;
  BinaryExpression: Type<namedTypes.BinaryExpression>;
  AssignmentExpression: Type<namedTypes.AssignmentExpression>;
  Scopable: Type<namedTypes.Scopable>;
  BlockParent: Type<namedTypes.BlockParent>;
  Function: Type<namedTypes.Function>;
  BaseFunction: Type<namedTypes.BaseFunction>;
  AwaitExpression: Type<namedTypes.AwaitExpression>;
  Statement: Type<namedTypes.Statement>;
  Loop: Type<namedTypes.Loop>;
  For: Type<namedTypes.For>;
  ForX: Type<namedTypes.ForX>;
  ForOfStatement: Type<namedTypes.ForOfStatement>;
  ObjectExpression: Type<namedTypes.ObjectExpression>;
  FunctionParent: Type<namedTypes.FunctionParent>;
  ObjectMethod: Type<namedTypes.ObjectMethod>;
  ObjectProperty: Type<namedTypes.ObjectProperty>;
  SpreadElement: Type<namedTypes.SpreadElement>;
  TemplateElement: Type<namedTypes.TemplateElement>;
  CatchClause: Type<namedTypes.CatchClause>;
  PatternLike: Type<namedTypes.PatternLike>;
  LVal: Type<namedTypes.LVal>;
  Identifier: Type<namedTypes.Identifier>;
  Pattern: Type<namedTypes.Pattern>;
  ArrayPattern: Type<namedTypes.ArrayPattern>;
  ObjectPattern: Type<namedTypes.ObjectPattern>;
  ImportExpression: Type<namedTypes.ImportExpression>;
  Declaration: Type<namedTypes.Declaration>;
  ExportAllDeclaration: Type<namedTypes.ExportAllDeclaration>;
  Pureish: Type<namedTypes.Pureish>;
  Literal: Type<namedTypes.Literal>;
  ChainElement: Type<namedTypes.ChainElement>;
  CallExpression: Type<namedTypes.CallExpression>;
  MemberExpression: Type<namedTypes.MemberExpression>;
  ChainExpression: Type<namedTypes.ChainExpression>;
  OptionalCallExpression: Type<namedTypes.OptionalCallExpression>;
  OptionalMemberExpression: Type<namedTypes.OptionalMemberExpression>;
  LogicalExpression: Type<namedTypes.LogicalExpression>;
  Decorator: Type<namedTypes.Decorator>;
  Property: Type<namedTypes.Property>;
  MethodDefinition: Type<namedTypes.MethodDefinition>;
  PrivateName: Type<namedTypes.PrivateName>;
  ClassPrivateProperty: Type<namedTypes.ClassPrivateProperty>;
  Comment: Type<namedTypes.Comment>;
  SourceLocation: Type<namedTypes.SourceLocation>;
  Position: Type<namedTypes.Position>;
  File: Type<namedTypes.File>;
  Program: Type<namedTypes.Program>;
  BlockStatement: Type<namedTypes.BlockStatement>;
  EmptyStatement: Type<namedTypes.EmptyStatement>;
  ExpressionStatement: Type<namedTypes.ExpressionStatement>;
  Conditional: Type<namedTypes.Conditional>;
  IfStatement: Type<namedTypes.IfStatement>;
  LabeledStatement: Type<namedTypes.LabeledStatement>;
  CompletionStatement: Type<namedTypes.CompletionStatement>;
  BreakStatement: Type<namedTypes.BreakStatement>;
  ContinueStatement: Type<namedTypes.ContinueStatement>;
  WithStatement: Type<namedTypes.WithStatement>;
  SwitchStatement: Type<namedTypes.SwitchStatement>;
  SwitchCase: Type<namedTypes.SwitchCase>;
  ReturnStatement: Type<namedTypes.ReturnStatement>;
  ThrowStatement: Type<namedTypes.ThrowStatement>;
  TryStatement: Type<namedTypes.TryStatement>;
  While: Type<namedTypes.While>;
  WhileStatement: Type<namedTypes.WhileStatement>;
  DoWhileStatement: Type<namedTypes.DoWhileStatement>;
  ForStatement: Type<namedTypes.ForStatement>;
  VariableDeclaration: Type<namedTypes.VariableDeclaration>;
  ForInStatement: Type<namedTypes.ForInStatement>;
  DebuggerStatement: Type<namedTypes.DebuggerStatement>;
  FunctionDeclaration: Type<namedTypes.FunctionDeclaration>;
  FunctionExpression: Type<namedTypes.FunctionExpression>;
  VariableDeclarator: Type<namedTypes.VariableDeclarator>;
  ThisExpression: Type<namedTypes.ThisExpression>;
  ArrayExpression: Type<namedTypes.ArrayExpression>;
  SequenceExpression: Type<namedTypes.SequenceExpression>;
  UnaryExpression: Type<namedTypes.UnaryExpression>;
  UpdateExpression: Type<namedTypes.UpdateExpression>;
  ConditionalExpression: Type<namedTypes.ConditionalExpression>;
  NewExpression: Type<namedTypes.NewExpression>;
  BaseComment: Type<namedTypes.BaseComment>;
  RestElement: Type<namedTypes.RestElement>;
  ArrowFunctionExpression: Type<namedTypes.ArrowFunctionExpression>;
  YieldExpression: Type<namedTypes.YieldExpression>;
  GeneratorExpression: Type<namedTypes.GeneratorExpression>;
  ComprehensionBlock: Type<namedTypes.ComprehensionBlock>;
  ComprehensionExpression: Type<namedTypes.ComprehensionExpression>;
  AssignmentPattern: Type<namedTypes.AssignmentPattern>;
  ClassPropertyDefinition: Type<namedTypes.ClassPropertyDefinition>;
  ClassProperty: Type<namedTypes.ClassProperty>;
  ClassBody: Type<namedTypes.ClassBody>;
  Class: Type<namedTypes.Class>;
  ClassDeclaration: Type<namedTypes.ClassDeclaration>;
  ClassExpression: Type<namedTypes.ClassExpression>;
  Super: Type<namedTypes.Super>;
  Specifier: Type<namedTypes.Specifier>;
  ModuleSpecifier: Type<namedTypes.ModuleSpecifier>;
  ImportSpecifier: Type<namedTypes.ImportSpecifier>;
  ImportDefaultSpecifier: Type<namedTypes.ImportDefaultSpecifier>;
  ImportNamespaceSpecifier: Type<namedTypes.ImportNamespaceSpecifier>;
  ImportDeclaration: Type<namedTypes.ImportDeclaration>;
  ExportNamedDeclaration: Type<namedTypes.ExportNamedDeclaration>;
  ExportSpecifier: Type<namedTypes.ExportSpecifier>;
  ExportDefaultDeclaration: Type<namedTypes.ExportDefaultDeclaration>;
  TaggedTemplateExpression: Type<namedTypes.TaggedTemplateExpression>;
  TemplateLiteral: Type<namedTypes.TemplateLiteral>;
  MetaProperty: Type<namedTypes.MetaProperty>;
  JSX: Type<namedTypes.JSX>;
  JSXAttribute: Type<namedTypes.JSXAttribute>;
  JSXIdentifier: Type<namedTypes.JSXIdentifier>;
  JSXNamespacedName: Type<namedTypes.JSXNamespacedName>;
  JSXExpressionContainer: Type<namedTypes.JSXExpressionContainer>;
  JSXElement: Type<namedTypes.JSXElement>;
  JSXFragment: Type<namedTypes.JSXFragment>;
  JSXMemberExpression: Type<namedTypes.JSXMemberExpression>;
  JSXSpreadAttribute: Type<namedTypes.JSXSpreadAttribute>;
  JSXEmptyExpression: Type<namedTypes.JSXEmptyExpression>;
  JSXText: Type<namedTypes.JSXText>;
  JSXSpreadChild: Type<namedTypes.JSXSpreadChild>;
  JSXOpeningElement: Type<namedTypes.JSXOpeningElement>;
  JSXClosingElement: Type<namedTypes.JSXClosingElement>;
  JSXOpeningFragment: Type<namedTypes.JSXOpeningFragment>;
  JSXClosingFragment: Type<namedTypes.JSXClosingFragment>;
  TypeAnnotation: Type<namedTypes.TypeAnnotation>;
  TSTypeAnnotation: Type<namedTypes.TSTypeAnnotation>;
  TypeParameterDeclaration: Type<namedTypes.TypeParameterDeclaration>;
  TSTypeParameterDeclaration: Type<namedTypes.TSTypeParameterDeclaration>;
  ClassMethod: Type<namedTypes.ClassMethod>;
  ClassPrivateMethod: Type<namedTypes.ClassPrivateMethod>;
  TypeParameterInstantiation: Type<namedTypes.TypeParameterInstantiation>;
  TSTypeParameterInstantiation: Type<namedTypes.TSTypeParameterInstantiation>;
  ClassImplements: Type<namedTypes.ClassImplements>;
  TSHasOptionalTypeParameterInstantiation: Type<namedTypes.TSHasOptionalTypeParameterInstantiation>;
  TSType: Type<namedTypes.TSType>;
  TSExpressionWithTypeArguments: Type<namedTypes.TSExpressionWithTypeArguments>;
  Flow: Type<namedTypes.Flow>;
  FlowType: Type<namedTypes.FlowType>;
  AnyTypeAnnotation: Type<namedTypes.AnyTypeAnnotation>;
  EmptyTypeAnnotation: Type<namedTypes.EmptyTypeAnnotation>;
  MixedTypeAnnotation: Type<namedTypes.MixedTypeAnnotation>;
  VoidTypeAnnotation: Type<namedTypes.VoidTypeAnnotation>;
  SymbolTypeAnnotation: Type<namedTypes.SymbolTypeAnnotation>;
  NumberTypeAnnotation: Type<namedTypes.NumberTypeAnnotation>;
  BigIntTypeAnnotation: Type<namedTypes.BigIntTypeAnnotation>;
  NumberLiteralTypeAnnotation: Type<namedTypes.NumberLiteralTypeAnnotation>;
  NumericLiteralTypeAnnotation: Type<namedTypes.NumericLiteralTypeAnnotation>;
  BigIntLiteralTypeAnnotation: Type<namedTypes.BigIntLiteralTypeAnnotation>;
  StringTypeAnnotation: Type<namedTypes.StringTypeAnnotation>;
  StringLiteralTypeAnnotation: Type<namedTypes.StringLiteralTypeAnnotation>;
  BooleanTypeAnnotation: Type<namedTypes.BooleanTypeAnnotation>;
  BooleanLiteralTypeAnnotation: Type<namedTypes.BooleanLiteralTypeAnnotation>;
  NullableTypeAnnotation: Type<namedTypes.NullableTypeAnnotation>;
  NullLiteralTypeAnnotation: Type<namedTypes.NullLiteralTypeAnnotation>;
  NullTypeAnnotation: Type<namedTypes.NullTypeAnnotation>;
  ThisTypeAnnotation: Type<namedTypes.ThisTypeAnnotation>;
  ExistsTypeAnnotation: Type<namedTypes.ExistsTypeAnnotation>;
  ExistentialTypeParam: Type<namedTypes.ExistentialTypeParam>;
  FunctionTypeAnnotation: Type<namedTypes.FunctionTypeAnnotation>;
  FunctionTypeParam: Type<namedTypes.FunctionTypeParam>;
  ArrayTypeAnnotation: Type<namedTypes.ArrayTypeAnnotation>;
  ObjectTypeAnnotation: Type<namedTypes.ObjectTypeAnnotation>;
  ObjectTypeProperty: Type<namedTypes.ObjectTypeProperty>;
  ObjectTypeSpreadProperty: Type<namedTypes.ObjectTypeSpreadProperty>;
  ObjectTypeIndexer: Type<namedTypes.ObjectTypeIndexer>;
  ObjectTypeCallProperty: Type<namedTypes.ObjectTypeCallProperty>;
  ObjectTypeInternalSlot: Type<namedTypes.ObjectTypeInternalSlot>;
  Variance: Type<namedTypes.Variance>;
  QualifiedTypeIdentifier: Type<namedTypes.QualifiedTypeIdentifier>;
  GenericTypeAnnotation: Type<namedTypes.GenericTypeAnnotation>;
  MemberTypeAnnotation: Type<namedTypes.MemberTypeAnnotation>;
  UnionTypeAnnotation: Type<namedTypes.UnionTypeAnnotation>;
  IntersectionTypeAnnotation: Type<namedTypes.IntersectionTypeAnnotation>;
  TypeofTypeAnnotation: Type<namedTypes.TypeofTypeAnnotation>;
  TypeParameter: Type<namedTypes.TypeParameter>;
  InterfaceTypeAnnotation: Type<namedTypes.InterfaceTypeAnnotation>;
  InterfaceExtends: Type<namedTypes.InterfaceExtends>;
  InterfaceDeclaration: Type<namedTypes.InterfaceDeclaration>;
  TypeAlias: Type<namedTypes.TypeAlias>;
  DeclareTypeAlias: Type<namedTypes.DeclareTypeAlias>;
  OpaqueType: Type<namedTypes.OpaqueType>;
  DeclareOpaqueType: Type<namedTypes.DeclareOpaqueType>;
  TypeCastExpression: Type<namedTypes.TypeCastExpression>;
  TupleTypeAnnotation: Type<namedTypes.TupleTypeAnnotation>;
  DeclareVariable: Type<namedTypes.DeclareVariable>;
  DeclareFunction: Type<namedTypes.DeclareFunction>;
  FlowPredicate: Type<namedTypes.FlowPredicate>;
  DeclareClass: Type<namedTypes.DeclareClass>;
  DeclareModule: Type<namedTypes.DeclareModule>;
  DeclareModuleExports: Type<namedTypes.DeclareModuleExports>;
  DeclareExportDeclaration: Type<namedTypes.DeclareExportDeclaration>;
  ExportBatchSpecifier: Type<namedTypes.ExportBatchSpecifier>;
  DeclareExportAllDeclaration: Type<namedTypes.DeclareExportAllDeclaration>;
  InferredPredicate: Type<namedTypes.InferredPredicate>;
  DeclaredPredicate: Type<namedTypes.DeclaredPredicate>;
  EnumDeclaration: Type<namedTypes.EnumDeclaration>;
  EnumBooleanBody: Type<namedTypes.EnumBooleanBody>;
  EnumNumberBody: Type<namedTypes.EnumNumberBody>;
  EnumStringBody: Type<namedTypes.EnumStringBody>;
  EnumSymbolBody: Type<namedTypes.EnumSymbolBody>;
  EnumBooleanMember: Type<namedTypes.EnumBooleanMember>;
  EnumNumberMember: Type<namedTypes.EnumNumberMember>;
  EnumStringMember: Type<namedTypes.EnumStringMember>;
  EnumDefaultedMember: Type<namedTypes.EnumDefaultedMember>;
  ExportDeclaration: Type<namedTypes.ExportDeclaration>;
  Block: Type<namedTypes.Block>;
  Line: Type<namedTypes.Line>;
  Noop: Type<namedTypes.Noop>;
  DoExpression: Type<namedTypes.DoExpression>;
  BindExpression: Type<namedTypes.BindExpression>;
  ParenthesizedExpression: Type<namedTypes.ParenthesizedExpression>;
  ExportNamespaceSpecifier: Type<namedTypes.ExportNamespaceSpecifier>;
  ExportDefaultSpecifier: Type<namedTypes.ExportDefaultSpecifier>;
  CommentBlock: Type<namedTypes.CommentBlock>;
  CommentLine: Type<namedTypes.CommentLine>;
  Directive: Type<namedTypes.Directive>;
  DirectiveLiteral: Type<namedTypes.DirectiveLiteral>;
  InterpreterDirective: Type<namedTypes.InterpreterDirective>;
  StringLiteral: Type<namedTypes.StringLiteral>;
  NumericLiteral: Type<namedTypes.NumericLiteral>;
  BigIntLiteral: Type<namedTypes.BigIntLiteral>;
  NullLiteral: Type<namedTypes.NullLiteral>;
  BooleanLiteral: Type<namedTypes.BooleanLiteral>;
  RegExpLiteral: Type<namedTypes.RegExpLiteral>;
  ForAwaitStatement: Type<namedTypes.ForAwaitStatement>;
  Import: Type<namedTypes.Import>;
  TSQualifiedName: Type<namedTypes.TSQualifiedName>;
  TSTypeReference: Type<namedTypes.TSTypeReference>;
  TSHasOptionalTypeParameters: Type<namedTypes.TSHasOptionalTypeParameters>;
  TSHasOptionalTypeAnnotation: Type<namedTypes.TSHasOptionalTypeAnnotation>;
  TSAsExpression: Type<namedTypes.TSAsExpression>;
  TSNonNullExpression: Type<namedTypes.TSNonNullExpression>;
  TSAnyKeyword: Type<namedTypes.TSAnyKeyword>;
  TSBigIntKeyword: Type<namedTypes.TSBigIntKeyword>;
  TSBooleanKeyword: Type<namedTypes.TSBooleanKeyword>;
  TSNeverKeyword: Type<namedTypes.TSNeverKeyword>;
  TSNullKeyword: Type<namedTypes.TSNullKeyword>;
  TSNumberKeyword: Type<namedTypes.TSNumberKeyword>;
  TSObjectKeyword: Type<namedTypes.TSObjectKeyword>;
  TSStringKeyword: Type<namedTypes.TSStringKeyword>;
  TSSymbolKeyword: Type<namedTypes.TSSymbolKeyword>;
  TSUndefinedKeyword: Type<namedTypes.TSUndefinedKeyword>;
  TSUnknownKeyword: Type<namedTypes.TSUnknownKeyword>;
  TSVoidKeyword: Type<namedTypes.TSVoidKeyword>;
  TSThisType: Type<namedTypes.TSThisType>;
  TSArrayType: Type<namedTypes.TSArrayType>;
  TSLiteralType: Type<namedTypes.TSLiteralType>;
  TSUnionType: Type<namedTypes.TSUnionType>;
  TSIntersectionType: Type<namedTypes.TSIntersectionType>;
  TSConditionalType: Type<namedTypes.TSConditionalType>;
  TSInferType: Type<namedTypes.TSInferType>;
  TSTypeParameter: Type<namedTypes.TSTypeParameter>;
  TSParenthesizedType: Type<namedTypes.TSParenthesizedType>;
  TSFunctionType: Type<namedTypes.TSFunctionType>;
  TSConstructorType: Type<namedTypes.TSConstructorType>;
  TSDeclareFunction: Type<namedTypes.TSDeclareFunction>;
  TSDeclareMethod: Type<namedTypes.TSDeclareMethod>;
  TSMappedType: Type<namedTypes.TSMappedType>;
  TSTupleType: Type<namedTypes.TSTupleType>;
  TSNamedTupleMember: Type<namedTypes.TSNamedTupleMember>;
  TSRestType: Type<namedTypes.TSRestType>;
  TSOptionalType: Type<namedTypes.TSOptionalType>;
  TSIndexedAccessType: Type<namedTypes.TSIndexedAccessType>;
  TSTypeOperator: Type<namedTypes.TSTypeOperator>;
  TSTypeElement: Type<namedTypes.TSTypeElement>;
  TSIndexSignature: Type<namedTypes.TSIndexSignature>;
  TSPropertySignature: Type<namedTypes.TSPropertySignature>;
  TSMethodSignature: Type<namedTypes.TSMethodSignature>;
  TSTypePredicate: Type<namedTypes.TSTypePredicate>;
  TSCallSignatureDeclaration: Type<namedTypes.TSCallSignatureDeclaration>;
  TSConstructSignatureDeclaration: Type<namedTypes.TSConstructSignatureDeclaration>;
  TSEnumMember: Type<namedTypes.TSEnumMember>;
  TSTypeQuery: Type<namedTypes.TSTypeQuery>;
  TSImportType: Type<namedTypes.TSImportType>;
  TSTypeLiteral: Type<namedTypes.TSTypeLiteral>;
  TSTypeAssertion: Type<namedTypes.TSTypeAssertion>;
  TSEnumDeclaration: Type<namedTypes.TSEnumDeclaration>;
  TSTypeAliasDeclaration: Type<namedTypes.TSTypeAliasDeclaration>;
  TSModuleBlock: Type<namedTypes.TSModuleBlock>;
  TSModuleDeclaration: Type<namedTypes.TSModuleDeclaration>;
  TSImportEqualsDeclaration: Type<namedTypes.TSImportEqualsDeclaration>;
  TSExternalModuleReference: Type<namedTypes.TSExternalModuleReference>;
  TSExportAssignment: Type<namedTypes.TSExportAssignment>;
  TSNamespaceExportDeclaration: Type<namedTypes.TSNamespaceExportDeclaration>;
  TSInterfaceBody: Type<namedTypes.TSInterfaceBody>;
  TSInterfaceDeclaration: Type<namedTypes.TSInterfaceDeclaration>;
  TSParameterProperty: Type<namedTypes.TSParameterProperty>;
}
