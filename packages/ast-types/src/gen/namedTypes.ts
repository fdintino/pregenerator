// !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!!
import { Omit } from "../types";
import { Type } from "../lib/types";
import * as K from "./kinds";
export namespace namedTypes {
  export interface Printable {
    loc?: K.SourceLocationKind | null;
  }
  export interface SourceLocation {
    start: K.PositionKind;
    end: K.PositionKind;
    source?: string | null;
  }
  export interface Node extends Printable {
    type: string;
    comments?: K.CommentKind[] | null;
  }
  export interface Comment extends Printable {
    value: string;
    leading?: boolean;
    trailing?: boolean;
  }
  export interface Position {
    line: number;
    column: number;
  }
  export interface File extends Omit<Node, "type"> {
    type: "File";
    program: K.ProgramKind;
    name?: string | null;
  }
  export interface Program extends Omit<Node, "type"> {
    type: "Program";
    body: K.StatementKind[];
    directives?: K.DirectiveKind[];
    interpreter?: K.InterpreterDirectiveKind | null;
  }
  export interface Statement extends Node {}
  export interface Function extends Node {
    id?: K.IdentifierKind | null;
    params: K.PatternLikeKind[];
    body: K.BlockStatementKind;
    generator?: boolean;
    async?: boolean;
    expression?: boolean;
    defaults?: (K.ExpressionKind | null)[];
    rest?: K.IdentifierKind | null;
    returnType?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
    typeParameters?:
      | K.TypeParameterDeclarationKind
      | K.TSTypeParameterDeclarationKind
      | null;
    predicate?: K.FlowPredicateKind | null;
  }
  export interface Expression extends Node {}
  export interface PatternLike extends Node {}
  export interface LVal extends Node {}
  export interface Identifier
    extends Omit<Expression, "type">,
      Omit<PatternLike, "type">,
      Omit<LVal, "type"> {
    type: "Identifier";
    name: string;
    optional?: boolean;
    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
  }
  export interface BlockStatement extends Omit<Statement, "type"> {
    type: "BlockStatement";
    body: K.StatementKind[];
    directives?: K.DirectiveKind[];
  }
  export interface EmptyStatement extends Omit<Statement, "type"> {
    type: "EmptyStatement";
  }
  export interface ExpressionStatement extends Omit<Statement, "type"> {
    type: "ExpressionStatement";
    expression: K.ExpressionKind;
  }
  export interface IfStatement extends Omit<Statement, "type"> {
    type: "IfStatement";
    test: K.ExpressionKind;
    consequent: K.StatementKind;
    alternate?: K.StatementKind | null;
  }
  export interface LabeledStatement extends Omit<Statement, "type"> {
    type: "LabeledStatement";
    label: K.IdentifierKind;
    body: K.StatementKind;
  }
  export interface BreakStatement extends Omit<Statement, "type"> {
    type: "BreakStatement";
    label?: K.IdentifierKind | null;
  }
  export interface ContinueStatement extends Omit<Statement, "type"> {
    type: "ContinueStatement";
    label?: K.IdentifierKind | null;
  }
  export interface WithStatement extends Omit<Statement, "type"> {
    type: "WithStatement";
    object: K.ExpressionKind;
    body: K.StatementKind;
  }
  export interface SwitchStatement extends Omit<Statement, "type"> {
    type: "SwitchStatement";
    discriminant: K.ExpressionKind;
    cases: K.SwitchCaseKind[];
    lexical?: boolean;
  }
  export interface SwitchCase extends Omit<Node, "type"> {
    type: "SwitchCase";
    test: K.ExpressionKind | null;
    consequent: K.StatementKind[];
  }
  export interface ReturnStatement extends Omit<Statement, "type"> {
    type: "ReturnStatement";
    argument: K.ExpressionKind | null;
  }
  export interface ThrowStatement extends Omit<Statement, "type"> {
    type: "ThrowStatement";
    argument: K.ExpressionKind;
  }
  export interface TryStatement extends Omit<Statement, "type"> {
    type: "TryStatement";
    block: K.BlockStatementKind;
    handler?: K.CatchClauseKind | null;
    handlers?: K.CatchClauseKind[];
    guardedHandlers?: K.CatchClauseKind[];
    finalizer?: K.BlockStatementKind | null;
  }
  export interface CatchClause extends Omit<Node, "type"> {
    type: "CatchClause";
    param?: K.IdentifierKind | K.ArrayPatternKind | K.ObjectPatternKind | null;
    guard?: K.ExpressionKind | null;
    body: K.BlockStatementKind;
  }
  export interface WhileStatement extends Omit<Statement, "type"> {
    type: "WhileStatement";
    test: K.ExpressionKind;
    body: K.StatementKind;
  }
  export interface DoWhileStatement extends Omit<Statement, "type"> {
    type: "DoWhileStatement";
    body: K.StatementKind;
    test: K.ExpressionKind;
  }
  export interface ForStatement extends Omit<Statement, "type"> {
    type: "ForStatement";
    init: K.VariableDeclarationKind | K.ExpressionKind | null;
    test: K.ExpressionKind | null;
    update: K.ExpressionKind | null;
    body: K.StatementKind;
  }
  export interface Declaration extends Statement {}
  export interface VariableDeclaration extends Omit<Declaration, "type"> {
    type: "VariableDeclaration";
    kind: "var" | "let" | "const";
    declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[];
  }
  export interface ForInStatement extends Omit<Statement, "type"> {
    type: "ForInStatement";
    left: K.VariableDeclarationKind | K.LValKind;
    right: K.ExpressionKind;
    body: K.StatementKind;
  }
  export interface DebuggerStatement extends Omit<Statement, "type"> {
    type: "DebuggerStatement";
  }
  export interface FunctionDeclaration
    extends Omit<Function, "type" | "id">,
      Omit<Declaration, "type"> {
    type: "FunctionDeclaration";
    id: K.IdentifierKind | null;
  }
  export interface FunctionExpression
    extends Omit<Function, "type">,
      Omit<Expression, "type"> {
    type: "FunctionExpression";
  }
  export interface VariableDeclarator extends Omit<Node, "type"> {
    type: "VariableDeclarator";
    id: K.LValKind;
    init?: K.ExpressionKind | null;
  }
  export interface ThisExpression extends Omit<Expression, "type"> {
    type: "ThisExpression";
  }
  export interface ArrayExpression extends Omit<Expression, "type"> {
    type: "ArrayExpression";
    elements: (K.ExpressionKind | K.SpreadElementKind | null)[];
  }
  export interface ObjectExpression extends Omit<Expression, "type"> {
    type: "ObjectExpression";
    properties: (
      | K.PropertyKind
      | K.ObjectMethodKind
      | K.ObjectPropertyKind
      | K.SpreadPropertyKind
      | K.SpreadElementKind
    )[];
  }
  export interface Property extends Omit<Node, "type"> {
    type: "Property";
    kind: "init" | "get" | "set";
    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
    value: K.ExpressionKind | K.PatternLikeKind;
    method?: boolean;
    shorthand?: boolean;
    computed?: boolean;
    decorators?: K.DecoratorKind[] | null;
  }
  export interface Literal extends Omit<Expression, "type"> {
    type: "Literal";
    value: string | boolean | null | number | RegExp;
    regex?: { pattern: string; flags: string } | null;
  }
  export interface SequenceExpression extends Omit<Expression, "type"> {
    type: "SequenceExpression";
    expressions: K.ExpressionKind[];
  }
  export interface UnaryExpression extends Omit<Expression, "type"> {
    type: "UnaryExpression";
    operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";
    argument: K.ExpressionKind;
    prefix?: boolean;
  }
  export interface BinaryExpression extends Omit<Expression, "type"> {
    type: "BinaryExpression";
    operator:
      | "=="
      | "!="
      | "==="
      | "!=="
      | "<"
      | "<="
      | ">"
      | ">="
      | "<<"
      | ">>"
      | ">>>"
      | "+"
      | "-"
      | "*"
      | "/"
      | "%"
      | "&"
      | "|"
      | "^"
      | "in"
      | "instanceof"
      | "**";
    left: K.ExpressionKind;
    right: K.ExpressionKind;
  }
  export interface AssignmentExpression extends Omit<Expression, "type"> {
    type: "AssignmentExpression";
    operator:
      | "="
      | "+="
      | "-="
      | "*="
      | "/="
      | "%="
      | "<<="
      | ">>="
      | ">>>="
      | "|="
      | "^="
      | "&="
      | "**=";
    left: K.LValKind;
    right: K.ExpressionKind;
  }
  export interface UpdateExpression extends Omit<Expression, "type"> {
    type: "UpdateExpression";
    operator: "++" | "--";
    argument: K.ExpressionKind;
    prefix: boolean;
  }
  export interface LogicalExpression extends Omit<Expression, "type"> {
    type: "LogicalExpression";
    operator: "||" | "&&" | "??";
    left: K.ExpressionKind;
    right: K.ExpressionKind;
  }
  export interface ConditionalExpression extends Omit<Expression, "type"> {
    type: "ConditionalExpression";
    test: K.ExpressionKind;
    consequent: K.ExpressionKind;
    alternate: K.ExpressionKind;
  }
  export interface NewExpression extends Omit<Expression, "type"> {
    type: "NewExpression";
    callee: K.ExpressionKind;
    arguments: (K.ExpressionKind | K.SpreadElementKind)[];
    typeArguments?: null | K.TypeParameterInstantiationKind;
  }
  export interface ChainElement extends Node {
    optional?: boolean;
  }
  export interface CallExpression
    extends Omit<Expression, "type">,
      Omit<ChainElement, "type"> {
    type: "CallExpression";
    callee: K.ExpressionKind;
    arguments: (K.ExpressionKind | K.SpreadElementKind)[];
    typeArguments?: null | K.TypeParameterInstantiationKind;
  }
  export interface MemberExpression
    extends Omit<Expression, "type">,
      Omit<LVal, "type">,
      Omit<ChainElement, "type"> {
    type: "MemberExpression";
    object: K.ExpressionKind;
    property: K.IdentifierKind | K.ExpressionKind;
    computed?: boolean;
  }
  export interface Pattern extends Node {}
  export interface RestElement
    extends Omit<PatternLike, "type">,
      Omit<LVal, "type"> {
    type: "RestElement";
    argument: K.LValKind;
    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
  }
  export interface ArrowFunctionExpression
    extends Omit<Function, "type" | "id" | "body" | "generator">,
      Omit<Expression, "type"> {
    type: "ArrowFunctionExpression";
    id?: null;
    body: K.BlockStatementKind | K.ExpressionKind;
    generator?: false;
  }
  export interface ForOfStatement extends Omit<Statement, "type"> {
    type: "ForOfStatement";
    left: K.VariableDeclarationKind | K.LValKind;
    right: K.ExpressionKind;
    body: K.StatementKind;
    await?: boolean;
  }
  export interface YieldExpression extends Omit<Expression, "type"> {
    type: "YieldExpression";
    argument: K.ExpressionKind | null;
    delegate?: boolean;
  }
  export interface GeneratorExpression extends Omit<Expression, "type"> {
    type: "GeneratorExpression";
    body: K.ExpressionKind;
    blocks: K.ComprehensionBlockKind[];
    filter: K.ExpressionKind | null;
  }
  export interface ComprehensionBlock extends Omit<Node, "type"> {
    type: "ComprehensionBlock";
    left: K.PatternKind;
    right: K.ExpressionKind;
    each: boolean;
  }
  export interface ComprehensionExpression extends Omit<Expression, "type"> {
    type: "ComprehensionExpression";
    body: K.ExpressionKind;
    blocks: K.ComprehensionBlockKind[];
    filter: K.ExpressionKind | null;
  }
  export interface ObjectProperty extends Omit<Node, "type"> {
    shorthand?: boolean;
    type: "ObjectProperty";
    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
    value: K.ExpressionKind | K.PatternLikeKind;
    accessibility?: K.LiteralKind | null;
    computed?: boolean;
  }
  export interface ArrayPattern
    extends Omit<Pattern, "type">,
      Omit<PatternLike, "type">,
      Omit<LVal, "type"> {
    type: "ArrayPattern";
    elements: (K.PatternLikeKind | null)[];
  }
  export interface ObjectPattern
    extends Omit<Pattern, "type">,
      Omit<PatternLike, "type">,
      Omit<LVal, "type"> {
    type: "ObjectPattern";
    properties: (K.PropertyKind | K.ObjectPropertyKind | K.RestPropertyKind)[];
    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
    decorators?: K.DecoratorKind[] | null;
  }
  export interface SpreadElement extends Omit<Node, "type"> {
    type: "SpreadElement";
    argument: K.ExpressionKind;
  }
  export interface AssignmentPattern
    extends Omit<Pattern, "type">,
      Omit<PatternLike, "type">,
      Omit<LVal, "type"> {
    type: "AssignmentPattern";
    left:
      | K.IdentifierKind
      | K.ObjectPatternKind
      | K.ArrayPatternKind
      | K.MemberExpressionKind;
    right: K.ExpressionKind;
  }
  export interface MethodDefinition extends Omit<Declaration, "type"> {
    type: "MethodDefinition";
    kind: "constructor" | "method" | "get" | "set";
    key: K.ExpressionKind;
    value: K.FunctionKind;
    computed?: boolean;
    static?: boolean;
    decorators?: K.DecoratorKind[] | null;
  }
  export interface ClassPropertyDefinition extends Omit<Declaration, "type"> {
    type: "ClassPropertyDefinition";
    definition:
      | K.MethodDefinitionKind
      | K.VariableDeclaratorKind
      | K.ClassPropertyDefinitionKind
      | K.ClassPropertyKind;
  }
  export interface ClassProperty extends Omit<Declaration, "type"> {
    type: "ClassProperty";
    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
    computed?: boolean;
    value: K.ExpressionKind | null;
    static?: boolean;
    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
    variance?: K.VarianceKind | "plus" | "minus" | null;
    access?: "public" | "private" | "protected" | undefined;
  }
  export interface ClassBody
    extends Omit<Declaration, "type">,
      Omit<Node, "type"> {
    type: "ClassBody";
    body: (
      | K.MethodDefinitionKind
      | K.VariableDeclaratorKind
      | K.ClassPropertyDefinitionKind
      | K.ClassPropertyKind
      | K.ClassPrivatePropertyKind
      | K.ClassMethodKind
      | K.ClassPrivateMethodKind
      | K.TSDeclareMethodKind
      | (
          | K.TSCallSignatureDeclarationKind
          | K.TSConstructSignatureDeclarationKind
          | K.TSIndexSignatureKind
          | K.TSMethodSignatureKind
          | K.TSPropertySignatureKind
        )
    )[];
  }
  export interface ClassDeclaration extends Omit<Declaration, "type"> {
    type: "ClassDeclaration";
    id: K.IdentifierKind | null;
    body: K.ClassBodyKind;
    superClass?: K.ExpressionKind | null;
    typeParameters?:
      | K.TypeParameterDeclarationKind
      | K.TSTypeParameterDeclarationKind
      | null;
    superTypeParameters?:
      | K.TypeParameterInstantiationKind
      | K.TSTypeParameterInstantiationKind
      | null;
    implements?:
      | K.ClassImplementsKind[]
      | K.TSExpressionWithTypeArgumentsKind[];
  }
  export interface ClassExpression extends Omit<Expression, "type"> {
    type: "ClassExpression";
    id?: K.IdentifierKind | null;
    body: K.ClassBodyKind;
    superClass?: K.ExpressionKind | null;
    typeParameters?:
      | K.TypeParameterDeclarationKind
      | K.TSTypeParameterDeclarationKind
      | null;
    superTypeParameters?:
      | K.TypeParameterInstantiationKind
      | K.TSTypeParameterInstantiationKind
      | null;
    implements?:
      | K.ClassImplementsKind[]
      | K.TSExpressionWithTypeArgumentsKind[];
  }
  export interface Super extends Omit<Expression, "type"> {
    type: "Super";
  }
  export interface Specifier extends Node {}
  export interface ModuleSpecifier extends Specifier {
    local?: K.IdentifierKind | null;
    id?: K.IdentifierKind | null;
    name?: K.IdentifierKind | null;
  }
  export interface ImportSpecifier extends Omit<ModuleSpecifier, "type"> {
    type: "ImportSpecifier";
    imported: K.IdentifierKind;
  }
  export interface ImportDefaultSpecifier
    extends Omit<ModuleSpecifier, "type"> {
    type: "ImportDefaultSpecifier";
  }
  export interface ImportNamespaceSpecifier
    extends Omit<ModuleSpecifier, "type"> {
    type: "ImportNamespaceSpecifier";
  }
  export interface ImportDeclaration extends Omit<Declaration, "type"> {
    type: "ImportDeclaration";
    specifiers?: (
      | K.ImportSpecifierKind
      | K.ImportNamespaceSpecifierKind
      | K.ImportDefaultSpecifierKind
    )[];
    source: K.LiteralKind;
    importKind?: "value" | "type" | "typeof";
  }
  export interface ExportNamedDeclaration extends Omit<Declaration, "type"> {
    type: "ExportNamedDeclaration";
    declaration: K.DeclarationKind | null;
    specifiers?: K.ExportSpecifierKind[];
    source?: K.LiteralKind | null;
  }
  export interface ExportSpecifier extends Omit<ModuleSpecifier, "type"> {
    type: "ExportSpecifier";
    exported: K.IdentifierKind;
  }
  export interface ExportDefaultDeclaration extends Omit<Declaration, "type"> {
    type: "ExportDefaultDeclaration";
    declaration: K.DeclarationKind | K.ExpressionKind;
  }
  export interface ExportAllDeclaration extends Omit<Declaration, "type"> {
    type: "ExportAllDeclaration";
    source: K.LiteralKind;
    exported: K.IdentifierKind | null;
  }
  export interface TaggedTemplateExpression extends Omit<Expression, "type"> {
    type: "TaggedTemplateExpression";
    tag: K.ExpressionKind;
    quasi: K.TemplateLiteralKind;
  }
  export interface TemplateLiteral extends Omit<Expression, "type"> {
    type: "TemplateLiteral";
    quasis: K.TemplateElementKind[];
    expressions: K.ExpressionKind[];
  }
  export interface TemplateElement extends Omit<Node, "type"> {
    type: "TemplateElement";
    value: { cooked: string | null; raw: string };
    tail: boolean;
  }
  export interface MetaProperty extends Omit<Expression, "type"> {
    type: "MetaProperty";
    meta: K.IdentifierKind;
    property: K.IdentifierKind;
  }
  export interface AwaitExpression extends Omit<Expression, "type"> {
    type: "AwaitExpression";
    argument: K.ExpressionKind | null;
    all?: boolean;
  }
  export interface SpreadProperty extends SpreadElement {
    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
  }
  export interface ObjectMethod
    extends Omit<Node, "type">,
      Omit<Function, "type" | "params" | "body" | "generator" | "async"> {
    type: "ObjectMethod";
    kind: "method" | "get" | "set";
    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
    params: K.PatternLikeKind[];
    body: K.BlockStatementKind;
    computed?: boolean;
    generator?: boolean;
    async?: boolean;
    accessibility?: K.LiteralKind | null;
    decorators?: K.DecoratorKind[] | null;
  }
  export interface ImportExpression extends Omit<Expression, "type"> {
    type: "ImportExpression";
    source: K.ExpressionKind;
  }
  export interface ChainExpression extends Omit<Expression, "type"> {
    type: "ChainExpression";
    expression: K.ChainElementKind;
  }
  export interface OptionalCallExpression extends Omit<Expression, "type"> {
    type: "OptionalCallExpression";
    callee: K.ExpressionKind;
    arguments: K.ExpressionKind[];
    optional?: boolean;
  }
  export interface OptionalMemberExpression
    extends Omit<Expression, "type">,
      Omit<LVal, "type"> {
    type: "OptionalMemberExpression";
    object: K.ExpressionKind;
    property: K.IdentifierKind | K.ExpressionKind;
    computed?: boolean;
    optional?: boolean;
  }
  export interface JSX extends Node {}
  export interface JSXAttribute extends Omit<JSX, "type"> {
    type: "JSXAttribute";
    name: K.JSXIdentifierKind | K.JSXNamespacedNameKind;
    value?:
      | K.LiteralKind
      | K.JSXExpressionContainerKind
      | K.JSXElementKind
      | K.JSXFragmentKind
      | null;
  }
  export interface JSXIdentifier extends Omit<JSX, "type"> {
    type: "JSXIdentifier";
    name: string;
  }
  export interface JSXNamespacedName extends Omit<JSX, "type"> {
    type: "JSXNamespacedName";
    namespace: K.JSXIdentifierKind;
    name: K.JSXIdentifierKind;
  }
  export interface JSXExpressionContainer extends Omit<JSX, "type"> {
    type: "JSXExpressionContainer";
    expression: K.ExpressionKind | K.JSXEmptyExpressionKind;
  }
  export interface JSXElement
    extends Omit<JSX, "type">,
      Omit<Expression, "type"> {
    type: "JSXElement";
    openingElement: K.JSXOpeningElementKind;
    closingElement?: K.JSXClosingElementKind | null;
    children?: (
      | K.JSXTextKind
      | K.JSXExpressionContainerKind
      | K.JSXSpreadChildKind
      | K.JSXElementKind
      | K.JSXFragmentKind
      | K.LiteralKind
    )[];
    name?:
      | K.JSXIdentifierKind
      | K.JSXNamespacedNameKind
      | K.JSXMemberExpressionKind;
    selfClosing?: boolean;
    attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[];
  }
  export interface JSXFragment
    extends Omit<JSX, "type">,
      Omit<Expression, "type"> {
    type: "JSXFragment";
    openingFragment: K.JSXOpeningFragmentKind;
    closingFragment: K.JSXClosingFragmentKind;
    children?: (
      | K.JSXTextKind
      | K.JSXExpressionContainerKind
      | K.JSXSpreadChildKind
      | K.JSXElementKind
      | K.JSXFragmentKind
      | K.LiteralKind
    )[];
  }
  export interface JSXMemberExpression extends Omit<JSX, "type"> {
    type: "JSXMemberExpression";
    object: K.JSXIdentifierKind | K.JSXMemberExpressionKind;
    property: K.JSXIdentifierKind;
    computed?: boolean;
  }
  export interface JSXSpreadAttribute extends Omit<JSX, "type"> {
    type: "JSXSpreadAttribute";
    argument: K.ExpressionKind;
  }
  export interface JSXEmptyExpression extends Omit<JSX, "type"> {
    type: "JSXEmptyExpression";
  }
  export interface JSXText extends Omit<JSX, "type"> {
    type: "JSXText";
    value: string;
    raw?: string;
  }
  export interface JSXSpreadChild extends Omit<JSX, "type"> {
    type: "JSXSpreadChild";
    expression: K.ExpressionKind;
  }
  export interface JSXOpeningElement extends Omit<JSX, "type"> {
    type: "JSXOpeningElement";
    name:
      | K.JSXIdentifierKind
      | K.JSXNamespacedNameKind
      | K.JSXMemberExpressionKind;
    attributes?: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[];
    selfClosing?: boolean;
  }
  export interface JSXClosingElement extends Omit<JSX, "type"> {
    type: "JSXClosingElement";
    name:
      | K.JSXIdentifierKind
      | K.JSXNamespacedNameKind
      | K.JSXMemberExpressionKind;
  }
  export interface JSXOpeningFragment extends Omit<JSX, "type"> {
    type: "JSXOpeningFragment";
  }
  export interface JSXClosingFragment extends Omit<JSX, "type"> {
    type: "JSXClosingFragment";
  }
  export interface Decorator extends Omit<Node, "type"> {
    type: "Decorator";
    expression: K.ExpressionKind;
  }
  export interface PrivateName extends Omit<Expression, "type"> {
    type: "PrivateName";
    id: K.IdentifierKind;
  }
  export interface ClassPrivateProperty
    extends Omit<ClassProperty, "type" | "key" | "value"> {
    type: "ClassPrivateProperty";
    key: K.PrivateNameKind;
    value?: K.ExpressionKind | null;
  }
  export interface TypeAnnotation extends Omit<Node, "type"> {
    type: "TypeAnnotation";
    typeAnnotation: K.FlowTypeKind;
  }
  export interface TSTypeAnnotation extends Omit<Node, "type"> {
    type: "TSTypeAnnotation";
    typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind;
  }
  export interface TypeParameterDeclaration extends Omit<Node, "type"> {
    type: "TypeParameterDeclaration";
    params: K.TypeParameterKind[];
  }
  export interface TSTypeParameterDeclaration
    extends Omit<Declaration, "type"> {
    type: "TSTypeParameterDeclaration";
    params: K.TSTypeParameterKind[];
  }
  export interface TypeParameterInstantiation extends Omit<Node, "type"> {
    type: "TypeParameterInstantiation";
    params: K.FlowTypeKind[];
  }
  export interface TSTypeParameterInstantiation extends Omit<Node, "type"> {
    type: "TSTypeParameterInstantiation";
    params: K.TSTypeKind[];
  }
  export interface ClassImplements extends Omit<Node, "type"> {
    type: "ClassImplements";
    id: K.IdentifierKind;
    superClass?: K.ExpressionKind | null;
    typeParameters?: K.TypeParameterInstantiationKind | null;
  }
  export interface TSType extends Node {}
  export interface TSHasOptionalTypeParameterInstantiation {
    typeParameters?: K.TSTypeParameterInstantiationKind | null;
  }
  export interface TSExpressionWithTypeArguments
    extends Omit<TSType, "type">,
      TSHasOptionalTypeParameterInstantiation {
    type: "TSExpressionWithTypeArguments";
    expression: K.IdentifierKind | K.TSQualifiedNameKind;
  }
  export interface Flow extends Node {}
  export interface FlowType extends Flow {}
  export interface AnyTypeAnnotation extends Omit<FlowType, "type"> {
    type: "AnyTypeAnnotation";
  }
  export interface EmptyTypeAnnotation extends Omit<FlowType, "type"> {
    type: "EmptyTypeAnnotation";
  }
  export interface MixedTypeAnnotation extends Omit<FlowType, "type"> {
    type: "MixedTypeAnnotation";
  }
  export interface VoidTypeAnnotation extends Omit<FlowType, "type"> {
    type: "VoidTypeAnnotation";
  }
  export interface SymbolTypeAnnotation extends Omit<FlowType, "type"> {
    type: "SymbolTypeAnnotation";
  }
  export interface NumberTypeAnnotation extends Omit<FlowType, "type"> {
    type: "NumberTypeAnnotation";
  }
  export interface BigIntTypeAnnotation extends Omit<FlowType, "type"> {
    type: "BigIntTypeAnnotation";
  }
  export interface NumberLiteralTypeAnnotation extends Omit<FlowType, "type"> {
    type: "NumberLiteralTypeAnnotation";
    value: number;
    raw: string;
  }
  export interface NumericLiteralTypeAnnotation extends Omit<FlowType, "type"> {
    type: "NumericLiteralTypeAnnotation";
    value: number;
    raw: string;
  }
  export interface BigIntLiteralTypeAnnotation extends Omit<FlowType, "type"> {
    type: "BigIntLiteralTypeAnnotation";
    value: null;
    raw: string;
  }
  export interface StringTypeAnnotation extends Omit<FlowType, "type"> {
    type: "StringTypeAnnotation";
  }
  export interface StringLiteralTypeAnnotation extends Omit<FlowType, "type"> {
    type: "StringLiteralTypeAnnotation";
    value: string;
    raw: string;
  }
  export interface BooleanTypeAnnotation extends Omit<FlowType, "type"> {
    type: "BooleanTypeAnnotation";
  }
  export interface BooleanLiteralTypeAnnotation extends Omit<FlowType, "type"> {
    type: "BooleanLiteralTypeAnnotation";
    value: boolean;
    raw: string;
  }
  export interface NullableTypeAnnotation extends Omit<FlowType, "type"> {
    type: "NullableTypeAnnotation";
    typeAnnotation: K.FlowTypeKind;
  }
  export interface NullLiteralTypeAnnotation extends Omit<FlowType, "type"> {
    type: "NullLiteralTypeAnnotation";
  }
  export interface NullTypeAnnotation extends Omit<FlowType, "type"> {
    type: "NullTypeAnnotation";
  }
  export interface ThisTypeAnnotation extends Omit<FlowType, "type"> {
    type: "ThisTypeAnnotation";
  }
  export interface ExistsTypeAnnotation extends Omit<FlowType, "type"> {
    type: "ExistsTypeAnnotation";
  }
  export interface ExistentialTypeParam extends Omit<FlowType, "type"> {
    type: "ExistentialTypeParam";
  }
  export interface FunctionTypeAnnotation extends Omit<FlowType, "type"> {
    type: "FunctionTypeAnnotation";
    params: K.FunctionTypeParamKind[];
    returnType: K.FlowTypeKind;
    rest: K.FunctionTypeParamKind | null;
    typeParameters: K.TypeParameterDeclarationKind | null;
  }
  export interface FunctionTypeParam extends Omit<Node, "type"> {
    type: "FunctionTypeParam";
    name: K.IdentifierKind | null;
    typeAnnotation: K.FlowTypeKind;
    optional: boolean;
  }
  export interface ArrayTypeAnnotation extends Omit<FlowType, "type"> {
    type: "ArrayTypeAnnotation";
    elementType: K.FlowTypeKind;
  }
  export interface ObjectTypeAnnotation extends Omit<FlowType, "type"> {
    type: "ObjectTypeAnnotation";
    properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[];
    indexers?: K.ObjectTypeIndexerKind[];
    callProperties?: K.ObjectTypeCallPropertyKind[];
    inexact?: boolean | undefined;
    exact?: boolean;
    internalSlots?: K.ObjectTypeInternalSlotKind[];
  }
  export interface ObjectTypeProperty extends Omit<Node, "type"> {
    type: "ObjectTypeProperty";
    key: K.LiteralKind | K.IdentifierKind;
    value: K.FlowTypeKind;
    optional: boolean;
    variance?: K.VarianceKind | "plus" | "minus" | null;
  }
  export interface ObjectTypeSpreadProperty extends Omit<Node, "type"> {
    type: "ObjectTypeSpreadProperty";
    argument: K.FlowTypeKind;
  }
  export interface ObjectTypeIndexer extends Omit<Node, "type"> {
    type: "ObjectTypeIndexer";
    id: K.IdentifierKind;
    key: K.FlowTypeKind;
    value: K.FlowTypeKind;
    variance?: K.VarianceKind | "plus" | "minus" | null;
    static?: boolean;
  }
  export interface ObjectTypeCallProperty extends Omit<Node, "type"> {
    type: "ObjectTypeCallProperty";
    value: K.FunctionTypeAnnotationKind;
    static?: boolean;
  }
  export interface ObjectTypeInternalSlot extends Omit<Node, "type"> {
    type: "ObjectTypeInternalSlot";
    id: K.IdentifierKind;
    value: K.FlowTypeKind;
    optional: boolean;
    static: boolean;
    method: boolean;
  }
  export interface Variance extends Omit<Node, "type"> {
    type: "Variance";
    kind: "plus" | "minus";
  }
  export interface QualifiedTypeIdentifier extends Omit<Node, "type"> {
    type: "QualifiedTypeIdentifier";
    qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
    id: K.IdentifierKind;
  }
  export interface GenericTypeAnnotation extends Omit<FlowType, "type"> {
    type: "GenericTypeAnnotation";
    id: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
    typeParameters: K.TypeParameterInstantiationKind | null;
  }
  export interface MemberTypeAnnotation extends Omit<FlowType, "type"> {
    type: "MemberTypeAnnotation";
    object: K.IdentifierKind;
    property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind;
  }
  export interface UnionTypeAnnotation extends Omit<FlowType, "type"> {
    type: "UnionTypeAnnotation";
    types: K.FlowTypeKind[];
  }
  export interface IntersectionTypeAnnotation extends Omit<FlowType, "type"> {
    type: "IntersectionTypeAnnotation";
    types: K.FlowTypeKind[];
  }
  export interface TypeofTypeAnnotation extends Omit<FlowType, "type"> {
    type: "TypeofTypeAnnotation";
    argument: K.FlowTypeKind;
  }
  export interface TypeParameter extends Omit<FlowType, "type"> {
    type: "TypeParameter";
    name: string;
    variance?: K.VarianceKind | "plus" | "minus" | null;
    bound?: K.TypeAnnotationKind | null;
    default?: K.FlowTypeKind | null;
  }
  export interface InterfaceTypeAnnotation extends Omit<FlowType, "type"> {
    type: "InterfaceTypeAnnotation";
    body: K.ObjectTypeAnnotationKind;
    extends?: K.InterfaceExtendsKind[] | null;
  }
  export interface InterfaceExtends extends Omit<Node, "type"> {
    type: "InterfaceExtends";
    id: K.IdentifierKind;
    typeParameters?: K.TypeParameterInstantiationKind | null;
  }
  export interface InterfaceDeclaration extends Omit<Declaration, "type"> {
    type: "InterfaceDeclaration";
    id: K.IdentifierKind;
    typeParameters?: K.TypeParameterDeclarationKind | null;
    body: K.ObjectTypeAnnotationKind;
    extends: K.InterfaceExtendsKind[];
  }
  export interface DeclareInterface extends Omit<InterfaceDeclaration, "type"> {
    type: "DeclareInterface";
  }
  export interface TypeAlias extends Omit<Declaration, "type"> {
    type: "TypeAlias";
    id: K.IdentifierKind;
    typeParameters: K.TypeParameterDeclarationKind | null;
    right: K.FlowTypeKind;
  }
  export interface DeclareTypeAlias extends Omit<TypeAlias, "type"> {
    type: "DeclareTypeAlias";
  }
  export interface OpaqueType extends Omit<Declaration, "type"> {
    type: "OpaqueType";
    id: K.IdentifierKind;
    typeParameters: K.TypeParameterDeclarationKind | null;
    impltype: K.FlowTypeKind;
    supertype: K.FlowTypeKind | null;
  }
  export interface DeclareOpaqueType
    extends Omit<OpaqueType, "type" | "impltype"> {
    type: "DeclareOpaqueType";
    impltype: K.FlowTypeKind | null;
  }
  export interface TypeCastExpression extends Omit<Expression, "type"> {
    type: "TypeCastExpression";
    expression: K.ExpressionKind;
    typeAnnotation: K.TypeAnnotationKind;
  }
  export interface TupleTypeAnnotation extends Omit<FlowType, "type"> {
    type: "TupleTypeAnnotation";
    types: K.FlowTypeKind[];
  }
  export interface DeclareVariable extends Omit<Statement, "type"> {
    type: "DeclareVariable";
    id: K.IdentifierKind;
  }
  export interface DeclareFunction extends Omit<Statement, "type"> {
    type: "DeclareFunction";
    id: K.IdentifierKind;
    predicate?: K.FlowPredicateKind | null;
  }
  export interface FlowPredicate extends Flow {}
  export interface DeclareClass extends Omit<InterfaceDeclaration, "type"> {
    type: "DeclareClass";
  }
  export interface DeclareModule extends Omit<Statement, "type"> {
    type: "DeclareModule";
    id: K.IdentifierKind | K.LiteralKind;
    body: K.BlockStatementKind;
  }
  export interface DeclareModuleExports extends Omit<Statement, "type"> {
    type: "DeclareModuleExports";
    typeAnnotation: K.TypeAnnotationKind;
  }
  export interface DeclareExportDeclaration extends Omit<Declaration, "type"> {
    type: "DeclareExportDeclaration";
    default: boolean;
    declaration:
      | K.DeclareVariableKind
      | K.DeclareFunctionKind
      | K.DeclareClassKind
      | K.FlowTypeKind
      | K.TypeAliasKind
      | K.DeclareOpaqueTypeKind
      | K.InterfaceDeclarationKind
      | null;
    specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
    source?: K.LiteralKind | null;
  }
  export interface ExportBatchSpecifier extends Omit<Specifier, "type"> {
    type: "ExportBatchSpecifier";
  }
  export interface DeclareExportAllDeclaration
    extends Omit<Declaration, "type"> {
    type: "DeclareExportAllDeclaration";
    source?: K.LiteralKind | null;
  }
  export interface InferredPredicate extends Omit<FlowPredicate, "type"> {
    type: "InferredPredicate";
  }
  export interface DeclaredPredicate extends Omit<FlowPredicate, "type"> {
    type: "DeclaredPredicate";
    value: K.ExpressionKind;
  }
  export interface EnumDeclaration extends Omit<Declaration, "type"> {
    type: "EnumDeclaration";
    id: K.IdentifierKind;
    body:
      | K.EnumBooleanBodyKind
      | K.EnumNumberBodyKind
      | K.EnumStringBodyKind
      | K.EnumSymbolBodyKind;
  }
  export interface EnumBooleanBody {
    type: "EnumBooleanBody";
    members: K.EnumBooleanMemberKind[];
    explicitType: boolean;
  }
  export interface EnumNumberBody {
    type: "EnumNumberBody";
    members: K.EnumNumberMemberKind[];
    explicitType: boolean;
  }
  export interface EnumStringBody {
    type: "EnumStringBody";
    members: K.EnumStringMemberKind[] | K.EnumDefaultedMemberKind[];
    explicitType: boolean;
  }
  export interface EnumSymbolBody {
    type: "EnumSymbolBody";
    members: K.EnumDefaultedMemberKind[];
  }
  export interface EnumBooleanMember {
    type: "EnumBooleanMember";
    id: K.IdentifierKind;
    init: K.LiteralKind | boolean;
  }
  export interface EnumNumberMember {
    type: "EnumNumberMember";
    id: K.IdentifierKind;
    init: K.LiteralKind;
  }
  export interface EnumStringMember {
    type: "EnumStringMember";
    id: K.IdentifierKind;
    init: K.LiteralKind;
  }
  export interface EnumDefaultedMember {
    type: "EnumDefaultedMember";
    id: K.IdentifierKind;
  }
  export interface ExportDeclaration extends Omit<Declaration, "type"> {
    type: "ExportDeclaration";
    default: boolean;
    declaration: K.DeclarationKind | K.ExpressionKind | null;
    specifiers?: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
    source?: K.LiteralKind | null;
  }
  export interface Block extends Comment {
    type: "Block";
  }
  export interface Line extends Comment {
    type: "Line";
  }
  export interface Noop extends Omit<Statement, "type"> {
    type: "Noop";
  }
  export interface DoExpression extends Omit<Expression, "type"> {
    type: "DoExpression";
    body: K.StatementKind[];
  }
  export interface BindExpression extends Omit<Expression, "type"> {
    type: "BindExpression";
    object: K.ExpressionKind | null;
    callee: K.ExpressionKind;
  }
  export interface ParenthesizedExpression extends Omit<Expression, "type"> {
    type: "ParenthesizedExpression";
    expression: K.ExpressionKind;
  }
  export interface ExportNamespaceSpecifier extends Omit<Specifier, "type"> {
    type: "ExportNamespaceSpecifier";
    exported: K.IdentifierKind;
  }
  export interface ExportDefaultSpecifier extends Omit<Specifier, "type"> {
    type: "ExportDefaultSpecifier";
    exported: K.IdentifierKind;
  }
  export interface CommentBlock extends Comment {
    type: "CommentBlock";
  }
  export interface CommentLine extends Comment {
    type: "CommentLine";
  }
  export interface Directive extends Omit<Node, "type"> {
    type: "Directive";
    value: K.DirectiveLiteralKind;
  }
  export interface DirectiveLiteral
    extends Omit<Node, "type">,
      Omit<Expression, "type"> {
    type: "DirectiveLiteral";
    value?: string;
  }
  export interface InterpreterDirective extends Omit<Node, "type"> {
    type: "InterpreterDirective";
    value: string;
  }
  export interface StringLiteral extends Omit<Literal, "type" | "value"> {
    type: "StringLiteral";
    value: string;
  }
  export interface NumericLiteral extends Omit<Literal, "type" | "value"> {
    type: "NumericLiteral";
    value: number;
    raw?: string | null;
    extra?: { rawValue: number; raw: string };
  }
  export interface BigIntLiteral extends Omit<Literal, "type" | "value"> {
    type: "BigIntLiteral";
    value: string | number;
    extra?: { rawValue: string; raw: string };
  }
  export interface NullLiteral extends Omit<Literal, "type" | "value"> {
    type: "NullLiteral";
    value?: null;
  }
  export interface BooleanLiteral extends Omit<Literal, "type" | "value"> {
    type: "BooleanLiteral";
    value: boolean;
  }
  export interface RegExpLiteral extends Omit<Literal, "type" | "value"> {
    type: "RegExpLiteral";
    pattern: string;
    flags: string;
    value?: RegExp;
  }
  export interface ClassMethod extends Omit<Function, "type" | "body"> {
    type: "ClassMethod";
    key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
    kind?: "get" | "set" | "method" | "constructor";
    body: K.BlockStatementKind;
    computed?: boolean;
    static?: boolean | null;
    abstract?: boolean | null;
    access?: "public" | "private" | "protected" | null;
    accessibility?: "public" | "private" | "protected" | null;
    decorators?: K.DecoratorKind[] | null;
    optional?: boolean | null;
  }
  export interface ClassPrivateMethod extends Omit<Function, "type" | "body"> {
    type: "ClassPrivateMethod";
    key: K.PrivateNameKind;
    kind?: "get" | "set" | "method" | "constructor";
    body: K.BlockStatementKind;
    computed?: boolean;
    static?: boolean | null;
    abstract?: boolean | null;
    access?: "public" | "private" | "protected" | null;
    accessibility?: "public" | "private" | "protected" | null;
    decorators?: K.DecoratorKind[] | null;
    optional?: boolean | null;
  }
  export interface RestProperty extends Omit<RestElement, "typeAnnotation"> {
    typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
  }
  export interface ForAwaitStatement extends Omit<Statement, "type"> {
    type: "ForAwaitStatement";
    left: K.VariableDeclarationKind | K.ExpressionKind;
    right: K.ExpressionKind;
    body: K.StatementKind;
  }
  export interface Import extends Omit<Expression, "type"> {
    type: "Import";
  }
  export interface TSQualifiedName extends Omit<Node, "type"> {
    type: "TSQualifiedName";
    left: K.IdentifierKind | K.TSQualifiedNameKind;
    right: K.IdentifierKind | K.TSQualifiedNameKind;
  }
  export interface TSTypeReference
    extends Omit<TSType, "type">,
      TSHasOptionalTypeParameterInstantiation {
    type: "TSTypeReference";
    typeName: K.IdentifierKind | K.TSQualifiedNameKind;
  }
  export interface TSHasOptionalTypeParameters {
    typeParameters?: K.TSTypeParameterDeclarationKind | null | undefined;
  }
  export interface TSHasOptionalTypeAnnotation {
    typeAnnotation?: K.TSTypeAnnotationKind | null;
  }
  export interface TSAsExpression extends Omit<Expression, "type"> {
    type: "TSAsExpression";
    expression: K.ExpressionKind;
    typeAnnotation: K.TSTypeKind;
    extra?: { parenthesized: boolean } | null;
  }
  export interface TSNonNullExpression extends Omit<Expression, "type"> {
    type: "TSNonNullExpression";
    expression: K.ExpressionKind;
  }
  export interface TSAnyKeyword extends Omit<TSType, "type"> {
    type: "TSAnyKeyword";
  }
  export interface TSBigIntKeyword extends Omit<TSType, "type"> {
    type: "TSBigIntKeyword";
  }
  export interface TSBooleanKeyword extends Omit<TSType, "type"> {
    type: "TSBooleanKeyword";
  }
  export interface TSNeverKeyword extends Omit<TSType, "type"> {
    type: "TSNeverKeyword";
  }
  export interface TSNullKeyword extends Omit<TSType, "type"> {
    type: "TSNullKeyword";
  }
  export interface TSNumberKeyword extends Omit<TSType, "type"> {
    type: "TSNumberKeyword";
  }
  export interface TSObjectKeyword extends Omit<TSType, "type"> {
    type: "TSObjectKeyword";
  }
  export interface TSStringKeyword extends Omit<TSType, "type"> {
    type: "TSStringKeyword";
  }
  export interface TSSymbolKeyword extends Omit<TSType, "type"> {
    type: "TSSymbolKeyword";
  }
  export interface TSUndefinedKeyword extends Omit<TSType, "type"> {
    type: "TSUndefinedKeyword";
  }
  export interface TSUnknownKeyword extends Omit<TSType, "type"> {
    type: "TSUnknownKeyword";
  }
  export interface TSVoidKeyword extends Omit<TSType, "type"> {
    type: "TSVoidKeyword";
  }
  export interface TSThisType extends Omit<TSType, "type"> {
    type: "TSThisType";
  }
  export interface TSArrayType extends Omit<TSType, "type"> {
    type: "TSArrayType";
    elementType: K.TSTypeKind;
  }
  export interface TSLiteralType extends Omit<TSType, "type"> {
    type: "TSLiteralType";
    literal:
      | K.NumericLiteralKind
      | K.StringLiteralKind
      | K.BooleanLiteralKind
      | K.TemplateLiteralKind
      | K.UnaryExpressionKind;
  }
  export interface TSUnionType extends Omit<TSType, "type"> {
    type: "TSUnionType";
    types: K.TSTypeKind[];
  }
  export interface TSIntersectionType extends Omit<TSType, "type"> {
    type: "TSIntersectionType";
    types: K.TSTypeKind[];
  }
  export interface TSConditionalType extends Omit<TSType, "type"> {
    type: "TSConditionalType";
    checkType: K.TSTypeKind;
    extendsType: K.TSTypeKind;
    trueType: K.TSTypeKind;
    falseType: K.TSTypeKind;
  }
  export interface TSInferType extends Omit<TSType, "type"> {
    type: "TSInferType";
    typeParameter: K.TSTypeParameterKind;
  }
  export interface TSTypeParameter extends Omit<Node, "type"> {
    type: "TSTypeParameter";
    name: string;
    constraint?: K.TSTypeKind | undefined;
    default?: K.TSTypeKind | undefined;
  }
  export interface TSParenthesizedType extends Omit<TSType, "type"> {
    type: "TSParenthesizedType";
    typeAnnotation: K.TSTypeKind;
  }
  export interface TSFunctionType
    extends Omit<TSType, "type">,
      TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    type: "TSFunctionType";
    parameters: (
      | K.IdentifierKind
      | K.RestElementKind
      | K.ArrayPatternKind
      | K.ObjectPatternKind
    )[];
  }
  export interface TSConstructorType
    extends Omit<TSType, "type">,
      TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    type: "TSConstructorType";
    parameters: (
      | K.IdentifierKind
      | K.RestElementKind
      | K.ArrayPatternKind
      | K.ObjectPatternKind
    )[];
  }
  export interface TSDeclareFunction
    extends Omit<Declaration, "type">,
      TSHasOptionalTypeParameters,
      Omit<Statement, "type"> {
    type: "TSDeclareFunction";
    declare?: boolean;
    async?: boolean;
    generator?: boolean;
    id?: K.IdentifierKind | null;
    params: K.PatternLikeKind[];
    returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
  }
  export interface TSDeclareMethod extends Omit<Node, "type"> {
    type: "TSDeclareMethod";
    async?: boolean;
    generator?: boolean;
    params: K.PatternLikeKind[];
    abstract?: boolean;
    accessibility?: "public" | "private" | "protected" | undefined;
    static?: boolean;
    computed?: boolean;
    optional?: boolean;
    key:
      | K.IdentifierKind
      | K.StringLiteralKind
      | K.NumericLiteralKind
      | K.ExpressionKind;
    kind?: "get" | "set" | "method" | "constructor";
    access?: "public" | "private" | "protected" | undefined;
    decorators?: K.DecoratorKind[] | null;
    returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
  }
  export interface TSMappedType extends Omit<TSType, "type"> {
    type: "TSMappedType";
    readonly?: boolean | "+" | "-";
    typeParameter: K.TSTypeParameterKind;
    optional?: boolean | "+" | "-";
    typeAnnotation?: K.TSTypeKind | null;
  }
  export interface TSTupleType extends Omit<TSType, "type"> {
    type: "TSTupleType";
    elementTypes: (K.TSTypeKind | K.TSNamedTupleMemberKind)[];
  }
  export interface TSNamedTupleMember extends Omit<TSType, "type"> {
    type: "TSNamedTupleMember";
    label: K.IdentifierKind;
    optional?: boolean;
    elementType: K.TSTypeKind;
  }
  export interface TSRestType extends Omit<TSType, "type"> {
    type: "TSRestType";
    typeAnnotation: K.TSTypeKind;
  }
  export interface TSOptionalType extends Omit<TSType, "type"> {
    type: "TSOptionalType";
    typeAnnotation: K.TSTypeKind;
  }
  export interface TSIndexedAccessType extends Omit<TSType, "type"> {
    type: "TSIndexedAccessType";
    objectType: K.TSTypeKind;
    indexType: K.TSTypeKind;
  }
  export interface TSTypeOperator extends Omit<TSType, "type"> {
    type: "TSTypeOperator";
    operator: string;
    typeAnnotation: K.TSTypeKind;
  }
  export interface TSTypeElement extends Node {}
  export interface TSIndexSignature
    extends Omit<TSTypeElement, "type">,
      TSHasOptionalTypeAnnotation {
    type: "TSIndexSignature";
    parameters: K.IdentifierKind[];
    readonly?: boolean;
  }
  export interface TSPropertySignature
    extends Omit<TSTypeElement, "type">,
      TSHasOptionalTypeAnnotation {
    type: "TSPropertySignature";
    key: K.ExpressionKind;
    computed?: boolean;
    readonly?: boolean;
    optional?: boolean;
    initializer?: K.ExpressionKind | null;
  }
  export interface TSMethodSignature
    extends Omit<TSTypeElement, "type">,
      TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    type: "TSMethodSignature";
    key: K.ExpressionKind;
    computed?: boolean;
    optional?: boolean;
    parameters: (
      | K.IdentifierKind
      | K.RestElementKind
      | K.ArrayPatternKind
      | K.ObjectPatternKind
    )[];
  }
  export interface TSTypePredicate
    extends Omit<TSTypeAnnotation, "type" | "typeAnnotation">,
      Omit<TSType, "type"> {
    type: "TSTypePredicate";
    parameterName: K.IdentifierKind | K.TSThisTypeKind;
    typeAnnotation?: K.TSTypeAnnotationKind | null;
    asserts?: boolean;
  }
  export interface TSCallSignatureDeclaration
    extends Omit<TSTypeElement, "type">,
      TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    type: "TSCallSignatureDeclaration";
    parameters: (
      | K.IdentifierKind
      | K.RestElementKind
      | K.ArrayPatternKind
      | K.ObjectPatternKind
    )[];
  }
  export interface TSConstructSignatureDeclaration
    extends Omit<TSTypeElement, "type">,
      TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    type: "TSConstructSignatureDeclaration";
    parameters: (
      | K.IdentifierKind
      | K.RestElementKind
      | K.ArrayPatternKind
      | K.ObjectPatternKind
    )[];
  }
  export interface TSEnumMember extends Omit<Node, "type"> {
    type: "TSEnumMember";
    id: K.IdentifierKind | K.StringLiteralKind;
    initializer?: K.ExpressionKind | null;
  }
  export interface TSTypeQuery extends Omit<TSType, "type"> {
    type: "TSTypeQuery";
    exprName: (K.IdentifierKind | K.TSQualifiedNameKind) | K.TSImportTypeKind;
  }
  export interface TSImportType
    extends Omit<TSType, "type">,
      TSHasOptionalTypeParameterInstantiation {
    type: "TSImportType";
    argument: K.StringLiteralKind;
    qualifier?: (K.IdentifierKind | K.TSQualifiedNameKind) | undefined;
  }
  export interface TSTypeLiteral extends Omit<TSType, "type"> {
    type: "TSTypeLiteral";
    members: (
      | K.TSCallSignatureDeclarationKind
      | K.TSConstructSignatureDeclarationKind
      | K.TSIndexSignatureKind
      | K.TSMethodSignatureKind
      | K.TSPropertySignatureKind
    )[];
  }
  export interface TSTypeAssertion extends Omit<Expression, "type"> {
    type: "TSTypeAssertion";
    typeAnnotation: K.TSTypeKind;
    expression: K.ExpressionKind;
    extra?: { parenthesized: boolean } | null;
  }
  export interface TSEnumDeclaration
    extends Omit<Declaration, "type">,
      Omit<Statement, "type"> {
    type: "TSEnumDeclaration";
    id: K.IdentifierKind;
    const?: boolean;
    declare?: boolean;
    members: K.TSEnumMemberKind[];
    initializer?: K.ExpressionKind | null;
  }
  export interface TSTypeAliasDeclaration
    extends Omit<Declaration, "type">,
      Omit<Statement, "type">,
      TSHasOptionalTypeParameters {
    type: "TSTypeAliasDeclaration";
    id: K.IdentifierKind;
    declare?: boolean;
    typeAnnotation: K.TSTypeKind;
  }
  export interface TSModuleBlock extends Omit<Node, "type"> {
    type: "TSModuleBlock";
    body: K.StatementKind[];
  }
  export interface TSModuleDeclaration
    extends Omit<Declaration, "type">,
      Omit<Statement, "type"> {
    type: "TSModuleDeclaration";
    id: K.StringLiteralKind | (K.IdentifierKind | K.TSQualifiedNameKind);
    declare?: boolean;
    global?: boolean;
    body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null;
  }
  export interface TSImportEqualsDeclaration extends Omit<Statement, "type"> {
    type: "TSImportEqualsDeclaration";
    id: K.IdentifierKind;
    isExport?: boolean;
    moduleReference:
      | (K.IdentifierKind | K.TSQualifiedNameKind)
      | K.TSExternalModuleReferenceKind;
  }
  export interface TSExternalModuleReference extends Omit<Node, "type"> {
    type: "TSExternalModuleReference";
    expression: K.StringLiteralKind;
  }
  export interface TSExportAssignment extends Omit<Statement, "type"> {
    type: "TSExportAssignment";
    expression: K.ExpressionKind;
  }
  export interface TSNamespaceExportDeclaration
    extends Omit<Statement, "type"> {
    type: "TSNamespaceExportDeclaration";
    id: K.IdentifierKind;
  }
  export interface TSInterfaceBody extends Omit<Node, "type"> {
    type: "TSInterfaceBody";
    body: (
      | K.TSCallSignatureDeclarationKind
      | K.TSConstructSignatureDeclarationKind
      | K.TSIndexSignatureKind
      | K.TSMethodSignatureKind
      | K.TSPropertySignatureKind
    )[];
  }
  export interface TSInterfaceDeclaration
    extends Omit<Declaration, "type">,
      Omit<Statement, "type">,
      TSHasOptionalTypeParameters {
    type: "TSInterfaceDeclaration";
    id: K.IdentifierKind | K.TSQualifiedNameKind;
    declare?: boolean;
    extends?: K.TSExpressionWithTypeArgumentsKind[] | null;
    body: K.TSInterfaceBodyKind;
  }
  export interface TSParameterProperty extends Omit<LVal, "type"> {
    type: "TSParameterProperty";
    accessibility?: "public" | "private" | "protected" | undefined;
    readonly?: boolean;
    parameter: K.IdentifierKind | K.AssignmentPatternKind;
  }
  export type ASTNode =
    | File
    | Program
    | Identifier
    | BlockStatement
    | EmptyStatement
    | ExpressionStatement
    | IfStatement
    | LabeledStatement
    | BreakStatement
    | ContinueStatement
    | WithStatement
    | SwitchStatement
    | SwitchCase
    | ReturnStatement
    | ThrowStatement
    | TryStatement
    | CatchClause
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | VariableDeclaration
    | ForInStatement
    | DebuggerStatement
    | FunctionDeclaration
    | FunctionExpression
    | VariableDeclarator
    | ThisExpression
    | ArrayExpression
    | ObjectExpression
    | Property
    | Literal
    | SequenceExpression
    | UnaryExpression
    | BinaryExpression
    | AssignmentExpression
    | UpdateExpression
    | LogicalExpression
    | ConditionalExpression
    | NewExpression
    | CallExpression
    | MemberExpression
    | RestElement
    | ArrowFunctionExpression
    | ForOfStatement
    | YieldExpression
    | GeneratorExpression
    | ComprehensionBlock
    | ComprehensionExpression
    | ObjectProperty
    | ArrayPattern
    | ObjectPattern
    | SpreadElement
    | AssignmentPattern
    | MethodDefinition
    | ClassPropertyDefinition
    | ClassProperty
    | ClassBody
    | ClassDeclaration
    | ClassExpression
    | Super
    | ImportSpecifier
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportDeclaration
    | ExportNamedDeclaration
    | ExportSpecifier
    | ExportDefaultDeclaration
    | ExportAllDeclaration
    | TaggedTemplateExpression
    | TemplateLiteral
    | TemplateElement
    | MetaProperty
    | AwaitExpression
    | ObjectMethod
    | ImportExpression
    | ChainExpression
    | OptionalCallExpression
    | OptionalMemberExpression
    | JSXAttribute
    | JSXIdentifier
    | JSXNamespacedName
    | JSXExpressionContainer
    | JSXElement
    | JSXFragment
    | JSXMemberExpression
    | JSXSpreadAttribute
    | JSXEmptyExpression
    | JSXText
    | JSXSpreadChild
    | JSXOpeningElement
    | JSXClosingElement
    | JSXOpeningFragment
    | JSXClosingFragment
    | Decorator
    | PrivateName
    | ClassPrivateProperty
    | TypeAnnotation
    | TSTypeAnnotation
    | TypeParameterDeclaration
    | TSTypeParameterDeclaration
    | TypeParameterInstantiation
    | TSTypeParameterInstantiation
    | ClassImplements
    | TSExpressionWithTypeArguments
    | AnyTypeAnnotation
    | EmptyTypeAnnotation
    | MixedTypeAnnotation
    | VoidTypeAnnotation
    | SymbolTypeAnnotation
    | NumberTypeAnnotation
    | BigIntTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumericLiteralTypeAnnotation
    | BigIntLiteralTypeAnnotation
    | StringTypeAnnotation
    | StringLiteralTypeAnnotation
    | BooleanTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | NullableTypeAnnotation
    | NullLiteralTypeAnnotation
    | NullTypeAnnotation
    | ThisTypeAnnotation
    | ExistsTypeAnnotation
    | ExistentialTypeParam
    | FunctionTypeAnnotation
    | FunctionTypeParam
    | ArrayTypeAnnotation
    | ObjectTypeAnnotation
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty
    | ObjectTypeIndexer
    | ObjectTypeCallProperty
    | ObjectTypeInternalSlot
    | Variance
    | QualifiedTypeIdentifier
    | GenericTypeAnnotation
    | MemberTypeAnnotation
    | UnionTypeAnnotation
    | IntersectionTypeAnnotation
    | TypeofTypeAnnotation
    | TypeParameter
    | InterfaceTypeAnnotation
    | InterfaceExtends
    | InterfaceDeclaration
    | DeclareInterface
    | TypeAlias
    | DeclareTypeAlias
    | OpaqueType
    | DeclareOpaqueType
    | TypeCastExpression
    | TupleTypeAnnotation
    | DeclareVariable
    | DeclareFunction
    | DeclareClass
    | DeclareModule
    | DeclareModuleExports
    | DeclareExportDeclaration
    | ExportBatchSpecifier
    | DeclareExportAllDeclaration
    | InferredPredicate
    | DeclaredPredicate
    | EnumDeclaration
    | EnumBooleanBody
    | EnumNumberBody
    | EnumStringBody
    | EnumSymbolBody
    | EnumBooleanMember
    | EnumNumberMember
    | EnumStringMember
    | EnumDefaultedMember
    | ExportDeclaration
    | Block
    | Line
    | Noop
    | DoExpression
    | BindExpression
    | ParenthesizedExpression
    | ExportNamespaceSpecifier
    | ExportDefaultSpecifier
    | CommentBlock
    | CommentLine
    | Directive
    | DirectiveLiteral
    | InterpreterDirective
    | StringLiteral
    | NumericLiteral
    | BigIntLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | ClassMethod
    | ClassPrivateMethod
    | ForAwaitStatement
    | Import
    | TSQualifiedName
    | TSTypeReference
    | TSAsExpression
    | TSNonNullExpression
    | TSAnyKeyword
    | TSBigIntKeyword
    | TSBooleanKeyword
    | TSNeverKeyword
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSUndefinedKeyword
    | TSUnknownKeyword
    | TSVoidKeyword
    | TSThisType
    | TSArrayType
    | TSLiteralType
    | TSUnionType
    | TSIntersectionType
    | TSConditionalType
    | TSInferType
    | TSTypeParameter
    | TSParenthesizedType
    | TSFunctionType
    | TSConstructorType
    | TSDeclareFunction
    | TSDeclareMethod
    | TSMappedType
    | TSTupleType
    | TSNamedTupleMember
    | TSRestType
    | TSOptionalType
    | TSIndexedAccessType
    | TSTypeOperator
    | TSIndexSignature
    | TSPropertySignature
    | TSMethodSignature
    | TSTypePredicate
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSEnumMember
    | TSTypeQuery
    | TSImportType
    | TSTypeLiteral
    | TSTypeAssertion
    | TSEnumDeclaration
    | TSTypeAliasDeclaration
    | TSModuleBlock
    | TSModuleDeclaration
    | TSImportEqualsDeclaration
    | TSExternalModuleReference
    | TSExportAssignment
    | TSNamespaceExportDeclaration
    | TSInterfaceBody
    | TSInterfaceDeclaration
    | TSParameterProperty;
  export let Printable: Type<K.PrintableKind>;
  export let SourceLocation: Type<K.SourceLocationKind>;
  export let Node: Type<K.NodeKind>;
  export let Comment: Type<K.CommentKind>;
  export let Position: Type<K.PositionKind>;
  export let File: Type<K.FileKind>;
  export let Program: Type<K.ProgramKind>;
  export let Statement: Type<K.StatementKind>;
  export let Function: Type<K.FunctionKind>;
  export let Expression: Type<K.ExpressionKind>;
  export let PatternLike: Type<K.PatternLikeKind>;
  export let LVal: Type<K.LValKind>;
  export let Identifier: Type<K.IdentifierKind>;
  export let BlockStatement: Type<K.BlockStatementKind>;
  export let EmptyStatement: Type<K.EmptyStatementKind>;
  export let ExpressionStatement: Type<K.ExpressionStatementKind>;
  export let IfStatement: Type<K.IfStatementKind>;
  export let LabeledStatement: Type<K.LabeledStatementKind>;
  export let BreakStatement: Type<K.BreakStatementKind>;
  export let ContinueStatement: Type<K.ContinueStatementKind>;
  export let WithStatement: Type<K.WithStatementKind>;
  export let SwitchStatement: Type<K.SwitchStatementKind>;
  export let SwitchCase: Type<K.SwitchCaseKind>;
  export let ReturnStatement: Type<K.ReturnStatementKind>;
  export let ThrowStatement: Type<K.ThrowStatementKind>;
  export let TryStatement: Type<K.TryStatementKind>;
  export let CatchClause: Type<K.CatchClauseKind>;
  export let WhileStatement: Type<K.WhileStatementKind>;
  export let DoWhileStatement: Type<K.DoWhileStatementKind>;
  export let ForStatement: Type<K.ForStatementKind>;
  export let Declaration: Type<K.DeclarationKind>;
  export let VariableDeclaration: Type<K.VariableDeclarationKind>;
  export let ForInStatement: Type<K.ForInStatementKind>;
  export let DebuggerStatement: Type<K.DebuggerStatementKind>;
  export let FunctionDeclaration: Type<K.FunctionDeclarationKind>;
  export let FunctionExpression: Type<K.FunctionExpressionKind>;
  export let VariableDeclarator: Type<K.VariableDeclaratorKind>;
  export let ThisExpression: Type<K.ThisExpressionKind>;
  export let ArrayExpression: Type<K.ArrayExpressionKind>;
  export let ObjectExpression: Type<K.ObjectExpressionKind>;
  export let Property: Type<K.PropertyKind>;
  export let Literal: Type<K.LiteralKind>;
  export let SequenceExpression: Type<K.SequenceExpressionKind>;
  export let UnaryExpression: Type<K.UnaryExpressionKind>;
  export let BinaryExpression: Type<K.BinaryExpressionKind>;
  export let AssignmentExpression: Type<K.AssignmentExpressionKind>;
  export let UpdateExpression: Type<K.UpdateExpressionKind>;
  export let LogicalExpression: Type<K.LogicalExpressionKind>;
  export let ConditionalExpression: Type<K.ConditionalExpressionKind>;
  export let NewExpression: Type<K.NewExpressionKind>;
  export let ChainElement: Type<K.ChainElementKind>;
  export let CallExpression: Type<K.CallExpressionKind>;
  export let MemberExpression: Type<K.MemberExpressionKind>;
  export let Pattern: Type<K.PatternKind>;
  export let RestElement: Type<K.RestElementKind>;
  export let ArrowFunctionExpression: Type<K.ArrowFunctionExpressionKind>;
  export let ForOfStatement: Type<K.ForOfStatementKind>;
  export let YieldExpression: Type<K.YieldExpressionKind>;
  export let GeneratorExpression: Type<K.GeneratorExpressionKind>;
  export let ComprehensionBlock: Type<K.ComprehensionBlockKind>;
  export let ComprehensionExpression: Type<K.ComprehensionExpressionKind>;
  export let ObjectProperty: Type<K.ObjectPropertyKind>;
  export let ArrayPattern: Type<K.ArrayPatternKind>;
  export let ObjectPattern: Type<K.ObjectPatternKind>;
  export let SpreadElement: Type<K.SpreadElementKind>;
  export let AssignmentPattern: Type<K.AssignmentPatternKind>;
  export let MethodDefinition: Type<K.MethodDefinitionKind>;
  export let ClassPropertyDefinition: Type<K.ClassPropertyDefinitionKind>;
  export let ClassProperty: Type<K.ClassPropertyKind>;
  export let ClassBody: Type<K.ClassBodyKind>;
  export let ClassDeclaration: Type<K.ClassDeclarationKind>;
  export let ClassExpression: Type<K.ClassExpressionKind>;
  export let Super: Type<K.SuperKind>;
  export let Specifier: Type<K.SpecifierKind>;
  export let ModuleSpecifier: Type<K.ModuleSpecifierKind>;
  export let ImportSpecifier: Type<K.ImportSpecifierKind>;
  export let ImportDefaultSpecifier: Type<K.ImportDefaultSpecifierKind>;
  export let ImportNamespaceSpecifier: Type<K.ImportNamespaceSpecifierKind>;
  export let ImportDeclaration: Type<K.ImportDeclarationKind>;
  export let ExportNamedDeclaration: Type<K.ExportNamedDeclarationKind>;
  export let ExportSpecifier: Type<K.ExportSpecifierKind>;
  export let ExportDefaultDeclaration: Type<K.ExportDefaultDeclarationKind>;
  export let ExportAllDeclaration: Type<K.ExportAllDeclarationKind>;
  export let TaggedTemplateExpression: Type<K.TaggedTemplateExpressionKind>;
  export let TemplateLiteral: Type<K.TemplateLiteralKind>;
  export let TemplateElement: Type<K.TemplateElementKind>;
  export let MetaProperty: Type<K.MetaPropertyKind>;
  export let AwaitExpression: Type<K.AwaitExpressionKind>;
  export let SpreadProperty: Type<K.SpreadPropertyKind>;
  export let ObjectMethod: Type<K.ObjectMethodKind>;
  export let ImportExpression: Type<K.ImportExpressionKind>;
  export let ChainExpression: Type<K.ChainExpressionKind>;
  export let OptionalCallExpression: Type<K.OptionalCallExpressionKind>;
  export let OptionalMemberExpression: Type<K.OptionalMemberExpressionKind>;
  export let JSX: Type<K.JSXKind>;
  export let JSXAttribute: Type<K.JSXAttributeKind>;
  export let JSXIdentifier: Type<K.JSXIdentifierKind>;
  export let JSXNamespacedName: Type<K.JSXNamespacedNameKind>;
  export let JSXExpressionContainer: Type<K.JSXExpressionContainerKind>;
  export let JSXElement: Type<K.JSXElementKind>;
  export let JSXFragment: Type<K.JSXFragmentKind>;
  export let JSXMemberExpression: Type<K.JSXMemberExpressionKind>;
  export let JSXSpreadAttribute: Type<K.JSXSpreadAttributeKind>;
  export let JSXEmptyExpression: Type<K.JSXEmptyExpressionKind>;
  export let JSXText: Type<K.JSXTextKind>;
  export let JSXSpreadChild: Type<K.JSXSpreadChildKind>;
  export let JSXOpeningElement: Type<K.JSXOpeningElementKind>;
  export let JSXClosingElement: Type<K.JSXClosingElementKind>;
  export let JSXOpeningFragment: Type<K.JSXOpeningFragmentKind>;
  export let JSXClosingFragment: Type<K.JSXClosingFragmentKind>;
  export let Decorator: Type<K.DecoratorKind>;
  export let PrivateName: Type<K.PrivateNameKind>;
  export let ClassPrivateProperty: Type<K.ClassPrivatePropertyKind>;
  export let TypeAnnotation: Type<K.TypeAnnotationKind>;
  export let TSTypeAnnotation: Type<K.TSTypeAnnotationKind>;
  export let TypeParameterDeclaration: Type<K.TypeParameterDeclarationKind>;
  export let TSTypeParameterDeclaration: Type<K.TSTypeParameterDeclarationKind>;
  export let TypeParameterInstantiation: Type<K.TypeParameterInstantiationKind>;
  export let TSTypeParameterInstantiation: Type<K.TSTypeParameterInstantiationKind>;
  export let ClassImplements: Type<K.ClassImplementsKind>;
  export let TSType: Type<K.TSTypeKind>;
  export let TSHasOptionalTypeParameterInstantiation: Type<K.TSHasOptionalTypeParameterInstantiationKind>;
  export let TSExpressionWithTypeArguments: Type<K.TSExpressionWithTypeArgumentsKind>;
  export let Flow: Type<K.FlowKind>;
  export let FlowType: Type<K.FlowTypeKind>;
  export let AnyTypeAnnotation: Type<K.AnyTypeAnnotationKind>;
  export let EmptyTypeAnnotation: Type<K.EmptyTypeAnnotationKind>;
  export let MixedTypeAnnotation: Type<K.MixedTypeAnnotationKind>;
  export let VoidTypeAnnotation: Type<K.VoidTypeAnnotationKind>;
  export let SymbolTypeAnnotation: Type<K.SymbolTypeAnnotationKind>;
  export let NumberTypeAnnotation: Type<K.NumberTypeAnnotationKind>;
  export let BigIntTypeAnnotation: Type<K.BigIntTypeAnnotationKind>;
  export let NumberLiteralTypeAnnotation: Type<K.NumberLiteralTypeAnnotationKind>;
  export let NumericLiteralTypeAnnotation: Type<K.NumericLiteralTypeAnnotationKind>;
  export let BigIntLiteralTypeAnnotation: Type<K.BigIntLiteralTypeAnnotationKind>;
  export let StringTypeAnnotation: Type<K.StringTypeAnnotationKind>;
  export let StringLiteralTypeAnnotation: Type<K.StringLiteralTypeAnnotationKind>;
  export let BooleanTypeAnnotation: Type<K.BooleanTypeAnnotationKind>;
  export let BooleanLiteralTypeAnnotation: Type<K.BooleanLiteralTypeAnnotationKind>;
  export let NullableTypeAnnotation: Type<K.NullableTypeAnnotationKind>;
  export let NullLiteralTypeAnnotation: Type<K.NullLiteralTypeAnnotationKind>;
  export let NullTypeAnnotation: Type<K.NullTypeAnnotationKind>;
  export let ThisTypeAnnotation: Type<K.ThisTypeAnnotationKind>;
  export let ExistsTypeAnnotation: Type<K.ExistsTypeAnnotationKind>;
  export let ExistentialTypeParam: Type<K.ExistentialTypeParamKind>;
  export let FunctionTypeAnnotation: Type<K.FunctionTypeAnnotationKind>;
  export let FunctionTypeParam: Type<K.FunctionTypeParamKind>;
  export let ArrayTypeAnnotation: Type<K.ArrayTypeAnnotationKind>;
  export let ObjectTypeAnnotation: Type<K.ObjectTypeAnnotationKind>;
  export let ObjectTypeProperty: Type<K.ObjectTypePropertyKind>;
  export let ObjectTypeSpreadProperty: Type<K.ObjectTypeSpreadPropertyKind>;
  export let ObjectTypeIndexer: Type<K.ObjectTypeIndexerKind>;
  export let ObjectTypeCallProperty: Type<K.ObjectTypeCallPropertyKind>;
  export let ObjectTypeInternalSlot: Type<K.ObjectTypeInternalSlotKind>;
  export let Variance: Type<K.VarianceKind>;
  export let QualifiedTypeIdentifier: Type<K.QualifiedTypeIdentifierKind>;
  export let GenericTypeAnnotation: Type<K.GenericTypeAnnotationKind>;
  export let MemberTypeAnnotation: Type<K.MemberTypeAnnotationKind>;
  export let UnionTypeAnnotation: Type<K.UnionTypeAnnotationKind>;
  export let IntersectionTypeAnnotation: Type<K.IntersectionTypeAnnotationKind>;
  export let TypeofTypeAnnotation: Type<K.TypeofTypeAnnotationKind>;
  export let TypeParameter: Type<K.TypeParameterKind>;
  export let InterfaceTypeAnnotation: Type<K.InterfaceTypeAnnotationKind>;
  export let InterfaceExtends: Type<K.InterfaceExtendsKind>;
  export let InterfaceDeclaration: Type<K.InterfaceDeclarationKind>;
  export let DeclareInterface: Type<K.DeclareInterfaceKind>;
  export let TypeAlias: Type<K.TypeAliasKind>;
  export let DeclareTypeAlias: Type<K.DeclareTypeAliasKind>;
  export let OpaqueType: Type<K.OpaqueTypeKind>;
  export let DeclareOpaqueType: Type<K.DeclareOpaqueTypeKind>;
  export let TypeCastExpression: Type<K.TypeCastExpressionKind>;
  export let TupleTypeAnnotation: Type<K.TupleTypeAnnotationKind>;
  export let DeclareVariable: Type<K.DeclareVariableKind>;
  export let DeclareFunction: Type<K.DeclareFunctionKind>;
  export let FlowPredicate: Type<K.FlowPredicateKind>;
  export let DeclareClass: Type<K.DeclareClassKind>;
  export let DeclareModule: Type<K.DeclareModuleKind>;
  export let DeclareModuleExports: Type<K.DeclareModuleExportsKind>;
  export let DeclareExportDeclaration: Type<K.DeclareExportDeclarationKind>;
  export let ExportBatchSpecifier: Type<K.ExportBatchSpecifierKind>;
  export let DeclareExportAllDeclaration: Type<K.DeclareExportAllDeclarationKind>;
  export let InferredPredicate: Type<K.InferredPredicateKind>;
  export let DeclaredPredicate: Type<K.DeclaredPredicateKind>;
  export let EnumDeclaration: Type<K.EnumDeclarationKind>;
  export let EnumBooleanBody: Type<K.EnumBooleanBodyKind>;
  export let EnumNumberBody: Type<K.EnumNumberBodyKind>;
  export let EnumStringBody: Type<K.EnumStringBodyKind>;
  export let EnumSymbolBody: Type<K.EnumSymbolBodyKind>;
  export let EnumBooleanMember: Type<K.EnumBooleanMemberKind>;
  export let EnumNumberMember: Type<K.EnumNumberMemberKind>;
  export let EnumStringMember: Type<K.EnumStringMemberKind>;
  export let EnumDefaultedMember: Type<K.EnumDefaultedMemberKind>;
  export let ExportDeclaration: Type<K.ExportDeclarationKind>;
  export let Block: Type<K.BlockKind>;
  export let Line: Type<K.LineKind>;
  export let Noop: Type<K.NoopKind>;
  export let DoExpression: Type<K.DoExpressionKind>;
  export let BindExpression: Type<K.BindExpressionKind>;
  export let ParenthesizedExpression: Type<K.ParenthesizedExpressionKind>;
  export let ExportNamespaceSpecifier: Type<K.ExportNamespaceSpecifierKind>;
  export let ExportDefaultSpecifier: Type<K.ExportDefaultSpecifierKind>;
  export let CommentBlock: Type<K.CommentBlockKind>;
  export let CommentLine: Type<K.CommentLineKind>;
  export let Directive: Type<K.DirectiveKind>;
  export let DirectiveLiteral: Type<K.DirectiveLiteralKind>;
  export let InterpreterDirective: Type<K.InterpreterDirectiveKind>;
  export let StringLiteral: Type<K.StringLiteralKind>;
  export let NumericLiteral: Type<K.NumericLiteralKind>;
  export let BigIntLiteral: Type<K.BigIntLiteralKind>;
  export let NullLiteral: Type<K.NullLiteralKind>;
  export let BooleanLiteral: Type<K.BooleanLiteralKind>;
  export let RegExpLiteral: Type<K.RegExpLiteralKind>;
  export let ClassMethod: Type<K.ClassMethodKind>;
  export let ClassPrivateMethod: Type<K.ClassPrivateMethodKind>;
  export let RestProperty: Type<K.RestPropertyKind>;
  export let ForAwaitStatement: Type<K.ForAwaitStatementKind>;
  export let Import: Type<K.ImportKind>;
  export let TSQualifiedName: Type<K.TSQualifiedNameKind>;
  export let TSTypeReference: Type<K.TSTypeReferenceKind>;
  export let TSHasOptionalTypeParameters: Type<K.TSHasOptionalTypeParametersKind>;
  export let TSHasOptionalTypeAnnotation: Type<K.TSHasOptionalTypeAnnotationKind>;
  export let TSAsExpression: Type<K.TSAsExpressionKind>;
  export let TSNonNullExpression: Type<K.TSNonNullExpressionKind>;
  export let TSAnyKeyword: Type<K.TSAnyKeywordKind>;
  export let TSBigIntKeyword: Type<K.TSBigIntKeywordKind>;
  export let TSBooleanKeyword: Type<K.TSBooleanKeywordKind>;
  export let TSNeverKeyword: Type<K.TSNeverKeywordKind>;
  export let TSNullKeyword: Type<K.TSNullKeywordKind>;
  export let TSNumberKeyword: Type<K.TSNumberKeywordKind>;
  export let TSObjectKeyword: Type<K.TSObjectKeywordKind>;
  export let TSStringKeyword: Type<K.TSStringKeywordKind>;
  export let TSSymbolKeyword: Type<K.TSSymbolKeywordKind>;
  export let TSUndefinedKeyword: Type<K.TSUndefinedKeywordKind>;
  export let TSUnknownKeyword: Type<K.TSUnknownKeywordKind>;
  export let TSVoidKeyword: Type<K.TSVoidKeywordKind>;
  export let TSThisType: Type<K.TSThisTypeKind>;
  export let TSArrayType: Type<K.TSArrayTypeKind>;
  export let TSLiteralType: Type<K.TSLiteralTypeKind>;
  export let TSUnionType: Type<K.TSUnionTypeKind>;
  export let TSIntersectionType: Type<K.TSIntersectionTypeKind>;
  export let TSConditionalType: Type<K.TSConditionalTypeKind>;
  export let TSInferType: Type<K.TSInferTypeKind>;
  export let TSTypeParameter: Type<K.TSTypeParameterKind>;
  export let TSParenthesizedType: Type<K.TSParenthesizedTypeKind>;
  export let TSFunctionType: Type<K.TSFunctionTypeKind>;
  export let TSConstructorType: Type<K.TSConstructorTypeKind>;
  export let TSDeclareFunction: Type<K.TSDeclareFunctionKind>;
  export let TSDeclareMethod: Type<K.TSDeclareMethodKind>;
  export let TSMappedType: Type<K.TSMappedTypeKind>;
  export let TSTupleType: Type<K.TSTupleTypeKind>;
  export let TSNamedTupleMember: Type<K.TSNamedTupleMemberKind>;
  export let TSRestType: Type<K.TSRestTypeKind>;
  export let TSOptionalType: Type<K.TSOptionalTypeKind>;
  export let TSIndexedAccessType: Type<K.TSIndexedAccessTypeKind>;
  export let TSTypeOperator: Type<K.TSTypeOperatorKind>;
  export let TSTypeElement: Type<K.TSTypeElementKind>;
  export let TSIndexSignature: Type<K.TSIndexSignatureKind>;
  export let TSPropertySignature: Type<K.TSPropertySignatureKind>;
  export let TSMethodSignature: Type<K.TSMethodSignatureKind>;
  export let TSTypePredicate: Type<K.TSTypePredicateKind>;
  export let TSCallSignatureDeclaration: Type<K.TSCallSignatureDeclarationKind>;
  export let TSConstructSignatureDeclaration: Type<K.TSConstructSignatureDeclarationKind>;
  export let TSEnumMember: Type<K.TSEnumMemberKind>;
  export let TSTypeQuery: Type<K.TSTypeQueryKind>;
  export let TSImportType: Type<K.TSImportTypeKind>;
  export let TSTypeLiteral: Type<K.TSTypeLiteralKind>;
  export let TSTypeAssertion: Type<K.TSTypeAssertionKind>;
  export let TSEnumDeclaration: Type<K.TSEnumDeclarationKind>;
  export let TSTypeAliasDeclaration: Type<K.TSTypeAliasDeclarationKind>;
  export let TSModuleBlock: Type<K.TSModuleBlockKind>;
  export let TSModuleDeclaration: Type<K.TSModuleDeclarationKind>;
  export let TSImportEqualsDeclaration: Type<K.TSImportEqualsDeclarationKind>;
  export let TSExternalModuleReference: Type<K.TSExternalModuleReferenceKind>;
  export let TSExportAssignment: Type<K.TSExportAssignmentKind>;
  export let TSNamespaceExportDeclaration: Type<K.TSNamespaceExportDeclarationKind>;
  export let TSInterfaceBody: Type<K.TSInterfaceBodyKind>;
  export let TSInterfaceDeclaration: Type<K.TSInterfaceDeclarationKind>;
  export let TSParameterProperty: Type<K.TSParameterPropertyKind>;
  export function assertPrintable(x: unknown): asserts x is K.PrintableKind {
    Printable.assert(x);
  }
  export function assertSourceLocation(
    x: unknown
  ): asserts x is K.SourceLocationKind {
    SourceLocation.assert(x);
  }
  export function assertNode(x: unknown): asserts x is K.NodeKind {
    Node.assert(x);
  }
  export function assertComment(x: unknown): asserts x is K.CommentKind {
    Comment.assert(x);
  }
  export function assertPosition(x: unknown): asserts x is K.PositionKind {
    Position.assert(x);
  }
  export function assertFile(x: unknown): asserts x is K.FileKind {
    File.assert(x);
  }
  export function assertProgram(x: unknown): asserts x is K.ProgramKind {
    Program.assert(x);
  }
  export function assertStatement(x: unknown): asserts x is K.StatementKind {
    Statement.assert(x);
  }
  export function assertFunction(x: unknown): asserts x is K.FunctionKind {
    Function.assert(x);
  }
  export function assertExpression(x: unknown): asserts x is K.ExpressionKind {
    Expression.assert(x);
  }
  export function assertPatternLike(
    x: unknown
  ): asserts x is K.PatternLikeKind {
    PatternLike.assert(x);
  }
  export function assertLVal(x: unknown): asserts x is K.LValKind {
    LVal.assert(x);
  }
  export function assertIdentifier(x: unknown): asserts x is K.IdentifierKind {
    Identifier.assert(x);
  }
  export function assertBlockStatement(
    x: unknown
  ): asserts x is K.BlockStatementKind {
    BlockStatement.assert(x);
  }
  export function assertEmptyStatement(
    x: unknown
  ): asserts x is K.EmptyStatementKind {
    EmptyStatement.assert(x);
  }
  export function assertExpressionStatement(
    x: unknown
  ): asserts x is K.ExpressionStatementKind {
    ExpressionStatement.assert(x);
  }
  export function assertIfStatement(
    x: unknown
  ): asserts x is K.IfStatementKind {
    IfStatement.assert(x);
  }
  export function assertLabeledStatement(
    x: unknown
  ): asserts x is K.LabeledStatementKind {
    LabeledStatement.assert(x);
  }
  export function assertBreakStatement(
    x: unknown
  ): asserts x is K.BreakStatementKind {
    BreakStatement.assert(x);
  }
  export function assertContinueStatement(
    x: unknown
  ): asserts x is K.ContinueStatementKind {
    ContinueStatement.assert(x);
  }
  export function assertWithStatement(
    x: unknown
  ): asserts x is K.WithStatementKind {
    WithStatement.assert(x);
  }
  export function assertSwitchStatement(
    x: unknown
  ): asserts x is K.SwitchStatementKind {
    SwitchStatement.assert(x);
  }
  export function assertSwitchCase(x: unknown): asserts x is K.SwitchCaseKind {
    SwitchCase.assert(x);
  }
  export function assertReturnStatement(
    x: unknown
  ): asserts x is K.ReturnStatementKind {
    ReturnStatement.assert(x);
  }
  export function assertThrowStatement(
    x: unknown
  ): asserts x is K.ThrowStatementKind {
    ThrowStatement.assert(x);
  }
  export function assertTryStatement(
    x: unknown
  ): asserts x is K.TryStatementKind {
    TryStatement.assert(x);
  }
  export function assertCatchClause(
    x: unknown
  ): asserts x is K.CatchClauseKind {
    CatchClause.assert(x);
  }
  export function assertWhileStatement(
    x: unknown
  ): asserts x is K.WhileStatementKind {
    WhileStatement.assert(x);
  }
  export function assertDoWhileStatement(
    x: unknown
  ): asserts x is K.DoWhileStatementKind {
    DoWhileStatement.assert(x);
  }
  export function assertForStatement(
    x: unknown
  ): asserts x is K.ForStatementKind {
    ForStatement.assert(x);
  }
  export function assertDeclaration(
    x: unknown
  ): asserts x is K.DeclarationKind {
    Declaration.assert(x);
  }
  export function assertVariableDeclaration(
    x: unknown
  ): asserts x is K.VariableDeclarationKind {
    VariableDeclaration.assert(x);
  }
  export function assertForInStatement(
    x: unknown
  ): asserts x is K.ForInStatementKind {
    ForInStatement.assert(x);
  }
  export function assertDebuggerStatement(
    x: unknown
  ): asserts x is K.DebuggerStatementKind {
    DebuggerStatement.assert(x);
  }
  export function assertFunctionDeclaration(
    x: unknown
  ): asserts x is K.FunctionDeclarationKind {
    FunctionDeclaration.assert(x);
  }
  export function assertFunctionExpression(
    x: unknown
  ): asserts x is K.FunctionExpressionKind {
    FunctionExpression.assert(x);
  }
  export function assertVariableDeclarator(
    x: unknown
  ): asserts x is K.VariableDeclaratorKind {
    VariableDeclarator.assert(x);
  }
  export function assertThisExpression(
    x: unknown
  ): asserts x is K.ThisExpressionKind {
    ThisExpression.assert(x);
  }
  export function assertArrayExpression(
    x: unknown
  ): asserts x is K.ArrayExpressionKind {
    ArrayExpression.assert(x);
  }
  export function assertObjectExpression(
    x: unknown
  ): asserts x is K.ObjectExpressionKind {
    ObjectExpression.assert(x);
  }
  export function assertProperty(x: unknown): asserts x is K.PropertyKind {
    Property.assert(x);
  }
  export function assertLiteral(x: unknown): asserts x is K.LiteralKind {
    Literal.assert(x);
  }
  export function assertSequenceExpression(
    x: unknown
  ): asserts x is K.SequenceExpressionKind {
    SequenceExpression.assert(x);
  }
  export function assertUnaryExpression(
    x: unknown
  ): asserts x is K.UnaryExpressionKind {
    UnaryExpression.assert(x);
  }
  export function assertBinaryExpression(
    x: unknown
  ): asserts x is K.BinaryExpressionKind {
    BinaryExpression.assert(x);
  }
  export function assertAssignmentExpression(
    x: unknown
  ): asserts x is K.AssignmentExpressionKind {
    AssignmentExpression.assert(x);
  }
  export function assertUpdateExpression(
    x: unknown
  ): asserts x is K.UpdateExpressionKind {
    UpdateExpression.assert(x);
  }
  export function assertLogicalExpression(
    x: unknown
  ): asserts x is K.LogicalExpressionKind {
    LogicalExpression.assert(x);
  }
  export function assertConditionalExpression(
    x: unknown
  ): asserts x is K.ConditionalExpressionKind {
    ConditionalExpression.assert(x);
  }
  export function assertNewExpression(
    x: unknown
  ): asserts x is K.NewExpressionKind {
    NewExpression.assert(x);
  }
  export function assertChainElement(
    x: unknown
  ): asserts x is K.ChainElementKind {
    ChainElement.assert(x);
  }
  export function assertCallExpression(
    x: unknown
  ): asserts x is K.CallExpressionKind {
    CallExpression.assert(x);
  }
  export function assertMemberExpression(
    x: unknown
  ): asserts x is K.MemberExpressionKind {
    MemberExpression.assert(x);
  }
  export function assertPattern(x: unknown): asserts x is K.PatternKind {
    Pattern.assert(x);
  }
  export function assertRestElement(
    x: unknown
  ): asserts x is K.RestElementKind {
    RestElement.assert(x);
  }
  export function assertArrowFunctionExpression(
    x: unknown
  ): asserts x is K.ArrowFunctionExpressionKind {
    ArrowFunctionExpression.assert(x);
  }
  export function assertForOfStatement(
    x: unknown
  ): asserts x is K.ForOfStatementKind {
    ForOfStatement.assert(x);
  }
  export function assertYieldExpression(
    x: unknown
  ): asserts x is K.YieldExpressionKind {
    YieldExpression.assert(x);
  }
  export function assertGeneratorExpression(
    x: unknown
  ): asserts x is K.GeneratorExpressionKind {
    GeneratorExpression.assert(x);
  }
  export function assertComprehensionBlock(
    x: unknown
  ): asserts x is K.ComprehensionBlockKind {
    ComprehensionBlock.assert(x);
  }
  export function assertComprehensionExpression(
    x: unknown
  ): asserts x is K.ComprehensionExpressionKind {
    ComprehensionExpression.assert(x);
  }
  export function assertObjectProperty(
    x: unknown
  ): asserts x is K.ObjectPropertyKind {
    ObjectProperty.assert(x);
  }
  export function assertArrayPattern(
    x: unknown
  ): asserts x is K.ArrayPatternKind {
    ArrayPattern.assert(x);
  }
  export function assertObjectPattern(
    x: unknown
  ): asserts x is K.ObjectPatternKind {
    ObjectPattern.assert(x);
  }
  export function assertSpreadElement(
    x: unknown
  ): asserts x is K.SpreadElementKind {
    SpreadElement.assert(x);
  }
  export function assertAssignmentPattern(
    x: unknown
  ): asserts x is K.AssignmentPatternKind {
    AssignmentPattern.assert(x);
  }
  export function assertMethodDefinition(
    x: unknown
  ): asserts x is K.MethodDefinitionKind {
    MethodDefinition.assert(x);
  }
  export function assertClassPropertyDefinition(
    x: unknown
  ): asserts x is K.ClassPropertyDefinitionKind {
    ClassPropertyDefinition.assert(x);
  }
  export function assertClassProperty(
    x: unknown
  ): asserts x is K.ClassPropertyKind {
    ClassProperty.assert(x);
  }
  export function assertClassBody(x: unknown): asserts x is K.ClassBodyKind {
    ClassBody.assert(x);
  }
  export function assertClassDeclaration(
    x: unknown
  ): asserts x is K.ClassDeclarationKind {
    ClassDeclaration.assert(x);
  }
  export function assertClassExpression(
    x: unknown
  ): asserts x is K.ClassExpressionKind {
    ClassExpression.assert(x);
  }
  export function assertSuper(x: unknown): asserts x is K.SuperKind {
    Super.assert(x);
  }
  export function assertSpecifier(x: unknown): asserts x is K.SpecifierKind {
    Specifier.assert(x);
  }
  export function assertModuleSpecifier(
    x: unknown
  ): asserts x is K.ModuleSpecifierKind {
    ModuleSpecifier.assert(x);
  }
  export function assertImportSpecifier(
    x: unknown
  ): asserts x is K.ImportSpecifierKind {
    ImportSpecifier.assert(x);
  }
  export function assertImportDefaultSpecifier(
    x: unknown
  ): asserts x is K.ImportDefaultSpecifierKind {
    ImportDefaultSpecifier.assert(x);
  }
  export function assertImportNamespaceSpecifier(
    x: unknown
  ): asserts x is K.ImportNamespaceSpecifierKind {
    ImportNamespaceSpecifier.assert(x);
  }
  export function assertImportDeclaration(
    x: unknown
  ): asserts x is K.ImportDeclarationKind {
    ImportDeclaration.assert(x);
  }
  export function assertExportNamedDeclaration(
    x: unknown
  ): asserts x is K.ExportNamedDeclarationKind {
    ExportNamedDeclaration.assert(x);
  }
  export function assertExportSpecifier(
    x: unknown
  ): asserts x is K.ExportSpecifierKind {
    ExportSpecifier.assert(x);
  }
  export function assertExportDefaultDeclaration(
    x: unknown
  ): asserts x is K.ExportDefaultDeclarationKind {
    ExportDefaultDeclaration.assert(x);
  }
  export function assertExportAllDeclaration(
    x: unknown
  ): asserts x is K.ExportAllDeclarationKind {
    ExportAllDeclaration.assert(x);
  }
  export function assertTaggedTemplateExpression(
    x: unknown
  ): asserts x is K.TaggedTemplateExpressionKind {
    TaggedTemplateExpression.assert(x);
  }
  export function assertTemplateLiteral(
    x: unknown
  ): asserts x is K.TemplateLiteralKind {
    TemplateLiteral.assert(x);
  }
  export function assertTemplateElement(
    x: unknown
  ): asserts x is K.TemplateElementKind {
    TemplateElement.assert(x);
  }
  export function assertMetaProperty(
    x: unknown
  ): asserts x is K.MetaPropertyKind {
    MetaProperty.assert(x);
  }
  export function assertAwaitExpression(
    x: unknown
  ): asserts x is K.AwaitExpressionKind {
    AwaitExpression.assert(x);
  }
  export function assertSpreadProperty(
    x: unknown
  ): asserts x is K.SpreadPropertyKind {
    SpreadProperty.assert(x);
  }
  export function assertObjectMethod(
    x: unknown
  ): asserts x is K.ObjectMethodKind {
    ObjectMethod.assert(x);
  }
  export function assertImportExpression(
    x: unknown
  ): asserts x is K.ImportExpressionKind {
    ImportExpression.assert(x);
  }
  export function assertChainExpression(
    x: unknown
  ): asserts x is K.ChainExpressionKind {
    ChainExpression.assert(x);
  }
  export function assertOptionalCallExpression(
    x: unknown
  ): asserts x is K.OptionalCallExpressionKind {
    OptionalCallExpression.assert(x);
  }
  export function assertOptionalMemberExpression(
    x: unknown
  ): asserts x is K.OptionalMemberExpressionKind {
    OptionalMemberExpression.assert(x);
  }
  export function assertJSX(x: unknown): asserts x is K.JSXKind {
    JSX.assert(x);
  }
  export function assertJSXAttribute(
    x: unknown
  ): asserts x is K.JSXAttributeKind {
    JSXAttribute.assert(x);
  }
  export function assertJSXIdentifier(
    x: unknown
  ): asserts x is K.JSXIdentifierKind {
    JSXIdentifier.assert(x);
  }
  export function assertJSXNamespacedName(
    x: unknown
  ): asserts x is K.JSXNamespacedNameKind {
    JSXNamespacedName.assert(x);
  }
  export function assertJSXExpressionContainer(
    x: unknown
  ): asserts x is K.JSXExpressionContainerKind {
    JSXExpressionContainer.assert(x);
  }
  export function assertJSXElement(x: unknown): asserts x is K.JSXElementKind {
    JSXElement.assert(x);
  }
  export function assertJSXFragment(
    x: unknown
  ): asserts x is K.JSXFragmentKind {
    JSXFragment.assert(x);
  }
  export function assertJSXMemberExpression(
    x: unknown
  ): asserts x is K.JSXMemberExpressionKind {
    JSXMemberExpression.assert(x);
  }
  export function assertJSXSpreadAttribute(
    x: unknown
  ): asserts x is K.JSXSpreadAttributeKind {
    JSXSpreadAttribute.assert(x);
  }
  export function assertJSXEmptyExpression(
    x: unknown
  ): asserts x is K.JSXEmptyExpressionKind {
    JSXEmptyExpression.assert(x);
  }
  export function assertJSXText(x: unknown): asserts x is K.JSXTextKind {
    JSXText.assert(x);
  }
  export function assertJSXSpreadChild(
    x: unknown
  ): asserts x is K.JSXSpreadChildKind {
    JSXSpreadChild.assert(x);
  }
  export function assertJSXOpeningElement(
    x: unknown
  ): asserts x is K.JSXOpeningElementKind {
    JSXOpeningElement.assert(x);
  }
  export function assertJSXClosingElement(
    x: unknown
  ): asserts x is K.JSXClosingElementKind {
    JSXClosingElement.assert(x);
  }
  export function assertJSXOpeningFragment(
    x: unknown
  ): asserts x is K.JSXOpeningFragmentKind {
    JSXOpeningFragment.assert(x);
  }
  export function assertJSXClosingFragment(
    x: unknown
  ): asserts x is K.JSXClosingFragmentKind {
    JSXClosingFragment.assert(x);
  }
  export function assertDecorator(x: unknown): asserts x is K.DecoratorKind {
    Decorator.assert(x);
  }
  export function assertPrivateName(
    x: unknown
  ): asserts x is K.PrivateNameKind {
    PrivateName.assert(x);
  }
  export function assertClassPrivateProperty(
    x: unknown
  ): asserts x is K.ClassPrivatePropertyKind {
    ClassPrivateProperty.assert(x);
  }
  export function assertTypeAnnotation(
    x: unknown
  ): asserts x is K.TypeAnnotationKind {
    TypeAnnotation.assert(x);
  }
  export function assertTSTypeAnnotation(
    x: unknown
  ): asserts x is K.TSTypeAnnotationKind {
    TSTypeAnnotation.assert(x);
  }
  export function assertTypeParameterDeclaration(
    x: unknown
  ): asserts x is K.TypeParameterDeclarationKind {
    TypeParameterDeclaration.assert(x);
  }
  export function assertTSTypeParameterDeclaration(
    x: unknown
  ): asserts x is K.TSTypeParameterDeclarationKind {
    TSTypeParameterDeclaration.assert(x);
  }
  export function assertTypeParameterInstantiation(
    x: unknown
  ): asserts x is K.TypeParameterInstantiationKind {
    TypeParameterInstantiation.assert(x);
  }
  export function assertTSTypeParameterInstantiation(
    x: unknown
  ): asserts x is K.TSTypeParameterInstantiationKind {
    TSTypeParameterInstantiation.assert(x);
  }
  export function assertClassImplements(
    x: unknown
  ): asserts x is K.ClassImplementsKind {
    ClassImplements.assert(x);
  }
  export function assertTSType(x: unknown): asserts x is K.TSTypeKind {
    TSType.assert(x);
  }
  export function assertTSHasOptionalTypeParameterInstantiation(
    x: unknown
  ): asserts x is K.TSHasOptionalTypeParameterInstantiationKind {
    TSHasOptionalTypeParameterInstantiation.assert(x);
  }
  export function assertTSExpressionWithTypeArguments(
    x: unknown
  ): asserts x is K.TSExpressionWithTypeArgumentsKind {
    TSExpressionWithTypeArguments.assert(x);
  }
  export function assertFlow(x: unknown): asserts x is K.FlowKind {
    Flow.assert(x);
  }
  export function assertFlowType(x: unknown): asserts x is K.FlowTypeKind {
    FlowType.assert(x);
  }
  export function assertAnyTypeAnnotation(
    x: unknown
  ): asserts x is K.AnyTypeAnnotationKind {
    AnyTypeAnnotation.assert(x);
  }
  export function assertEmptyTypeAnnotation(
    x: unknown
  ): asserts x is K.EmptyTypeAnnotationKind {
    EmptyTypeAnnotation.assert(x);
  }
  export function assertMixedTypeAnnotation(
    x: unknown
  ): asserts x is K.MixedTypeAnnotationKind {
    MixedTypeAnnotation.assert(x);
  }
  export function assertVoidTypeAnnotation(
    x: unknown
  ): asserts x is K.VoidTypeAnnotationKind {
    VoidTypeAnnotation.assert(x);
  }
  export function assertSymbolTypeAnnotation(
    x: unknown
  ): asserts x is K.SymbolTypeAnnotationKind {
    SymbolTypeAnnotation.assert(x);
  }
  export function assertNumberTypeAnnotation(
    x: unknown
  ): asserts x is K.NumberTypeAnnotationKind {
    NumberTypeAnnotation.assert(x);
  }
  export function assertBigIntTypeAnnotation(
    x: unknown
  ): asserts x is K.BigIntTypeAnnotationKind {
    BigIntTypeAnnotation.assert(x);
  }
  export function assertNumberLiteralTypeAnnotation(
    x: unknown
  ): asserts x is K.NumberLiteralTypeAnnotationKind {
    NumberLiteralTypeAnnotation.assert(x);
  }
  export function assertNumericLiteralTypeAnnotation(
    x: unknown
  ): asserts x is K.NumericLiteralTypeAnnotationKind {
    NumericLiteralTypeAnnotation.assert(x);
  }
  export function assertBigIntLiteralTypeAnnotation(
    x: unknown
  ): asserts x is K.BigIntLiteralTypeAnnotationKind {
    BigIntLiteralTypeAnnotation.assert(x);
  }
  export function assertStringTypeAnnotation(
    x: unknown
  ): asserts x is K.StringTypeAnnotationKind {
    StringTypeAnnotation.assert(x);
  }
  export function assertStringLiteralTypeAnnotation(
    x: unknown
  ): asserts x is K.StringLiteralTypeAnnotationKind {
    StringLiteralTypeAnnotation.assert(x);
  }
  export function assertBooleanTypeAnnotation(
    x: unknown
  ): asserts x is K.BooleanTypeAnnotationKind {
    BooleanTypeAnnotation.assert(x);
  }
  export function assertBooleanLiteralTypeAnnotation(
    x: unknown
  ): asserts x is K.BooleanLiteralTypeAnnotationKind {
    BooleanLiteralTypeAnnotation.assert(x);
  }
  export function assertNullableTypeAnnotation(
    x: unknown
  ): asserts x is K.NullableTypeAnnotationKind {
    NullableTypeAnnotation.assert(x);
  }
  export function assertNullLiteralTypeAnnotation(
    x: unknown
  ): asserts x is K.NullLiteralTypeAnnotationKind {
    NullLiteralTypeAnnotation.assert(x);
  }
  export function assertNullTypeAnnotation(
    x: unknown
  ): asserts x is K.NullTypeAnnotationKind {
    NullTypeAnnotation.assert(x);
  }
  export function assertThisTypeAnnotation(
    x: unknown
  ): asserts x is K.ThisTypeAnnotationKind {
    ThisTypeAnnotation.assert(x);
  }
  export function assertExistsTypeAnnotation(
    x: unknown
  ): asserts x is K.ExistsTypeAnnotationKind {
    ExistsTypeAnnotation.assert(x);
  }
  export function assertExistentialTypeParam(
    x: unknown
  ): asserts x is K.ExistentialTypeParamKind {
    ExistentialTypeParam.assert(x);
  }
  export function assertFunctionTypeAnnotation(
    x: unknown
  ): asserts x is K.FunctionTypeAnnotationKind {
    FunctionTypeAnnotation.assert(x);
  }
  export function assertFunctionTypeParam(
    x: unknown
  ): asserts x is K.FunctionTypeParamKind {
    FunctionTypeParam.assert(x);
  }
  export function assertArrayTypeAnnotation(
    x: unknown
  ): asserts x is K.ArrayTypeAnnotationKind {
    ArrayTypeAnnotation.assert(x);
  }
  export function assertObjectTypeAnnotation(
    x: unknown
  ): asserts x is K.ObjectTypeAnnotationKind {
    ObjectTypeAnnotation.assert(x);
  }
  export function assertObjectTypeProperty(
    x: unknown
  ): asserts x is K.ObjectTypePropertyKind {
    ObjectTypeProperty.assert(x);
  }
  export function assertObjectTypeSpreadProperty(
    x: unknown
  ): asserts x is K.ObjectTypeSpreadPropertyKind {
    ObjectTypeSpreadProperty.assert(x);
  }
  export function assertObjectTypeIndexer(
    x: unknown
  ): asserts x is K.ObjectTypeIndexerKind {
    ObjectTypeIndexer.assert(x);
  }
  export function assertObjectTypeCallProperty(
    x: unknown
  ): asserts x is K.ObjectTypeCallPropertyKind {
    ObjectTypeCallProperty.assert(x);
  }
  export function assertObjectTypeInternalSlot(
    x: unknown
  ): asserts x is K.ObjectTypeInternalSlotKind {
    ObjectTypeInternalSlot.assert(x);
  }
  export function assertVariance(x: unknown): asserts x is K.VarianceKind {
    Variance.assert(x);
  }
  export function assertQualifiedTypeIdentifier(
    x: unknown
  ): asserts x is K.QualifiedTypeIdentifierKind {
    QualifiedTypeIdentifier.assert(x);
  }
  export function assertGenericTypeAnnotation(
    x: unknown
  ): asserts x is K.GenericTypeAnnotationKind {
    GenericTypeAnnotation.assert(x);
  }
  export function assertMemberTypeAnnotation(
    x: unknown
  ): asserts x is K.MemberTypeAnnotationKind {
    MemberTypeAnnotation.assert(x);
  }
  export function assertUnionTypeAnnotation(
    x: unknown
  ): asserts x is K.UnionTypeAnnotationKind {
    UnionTypeAnnotation.assert(x);
  }
  export function assertIntersectionTypeAnnotation(
    x: unknown
  ): asserts x is K.IntersectionTypeAnnotationKind {
    IntersectionTypeAnnotation.assert(x);
  }
  export function assertTypeofTypeAnnotation(
    x: unknown
  ): asserts x is K.TypeofTypeAnnotationKind {
    TypeofTypeAnnotation.assert(x);
  }
  export function assertTypeParameter(
    x: unknown
  ): asserts x is K.TypeParameterKind {
    TypeParameter.assert(x);
  }
  export function assertInterfaceTypeAnnotation(
    x: unknown
  ): asserts x is K.InterfaceTypeAnnotationKind {
    InterfaceTypeAnnotation.assert(x);
  }
  export function assertInterfaceExtends(
    x: unknown
  ): asserts x is K.InterfaceExtendsKind {
    InterfaceExtends.assert(x);
  }
  export function assertInterfaceDeclaration(
    x: unknown
  ): asserts x is K.InterfaceDeclarationKind {
    InterfaceDeclaration.assert(x);
  }
  export function assertDeclareInterface(
    x: unknown
  ): asserts x is K.DeclareInterfaceKind {
    DeclareInterface.assert(x);
  }
  export function assertTypeAlias(x: unknown): asserts x is K.TypeAliasKind {
    TypeAlias.assert(x);
  }
  export function assertDeclareTypeAlias(
    x: unknown
  ): asserts x is K.DeclareTypeAliasKind {
    DeclareTypeAlias.assert(x);
  }
  export function assertOpaqueType(x: unknown): asserts x is K.OpaqueTypeKind {
    OpaqueType.assert(x);
  }
  export function assertDeclareOpaqueType(
    x: unknown
  ): asserts x is K.DeclareOpaqueTypeKind {
    DeclareOpaqueType.assert(x);
  }
  export function assertTypeCastExpression(
    x: unknown
  ): asserts x is K.TypeCastExpressionKind {
    TypeCastExpression.assert(x);
  }
  export function assertTupleTypeAnnotation(
    x: unknown
  ): asserts x is K.TupleTypeAnnotationKind {
    TupleTypeAnnotation.assert(x);
  }
  export function assertDeclareVariable(
    x: unknown
  ): asserts x is K.DeclareVariableKind {
    DeclareVariable.assert(x);
  }
  export function assertDeclareFunction(
    x: unknown
  ): asserts x is K.DeclareFunctionKind {
    DeclareFunction.assert(x);
  }
  export function assertFlowPredicate(
    x: unknown
  ): asserts x is K.FlowPredicateKind {
    FlowPredicate.assert(x);
  }
  export function assertDeclareClass(
    x: unknown
  ): asserts x is K.DeclareClassKind {
    DeclareClass.assert(x);
  }
  export function assertDeclareModule(
    x: unknown
  ): asserts x is K.DeclareModuleKind {
    DeclareModule.assert(x);
  }
  export function assertDeclareModuleExports(
    x: unknown
  ): asserts x is K.DeclareModuleExportsKind {
    DeclareModuleExports.assert(x);
  }
  export function assertDeclareExportDeclaration(
    x: unknown
  ): asserts x is K.DeclareExportDeclarationKind {
    DeclareExportDeclaration.assert(x);
  }
  export function assertExportBatchSpecifier(
    x: unknown
  ): asserts x is K.ExportBatchSpecifierKind {
    ExportBatchSpecifier.assert(x);
  }
  export function assertDeclareExportAllDeclaration(
    x: unknown
  ): asserts x is K.DeclareExportAllDeclarationKind {
    DeclareExportAllDeclaration.assert(x);
  }
  export function assertInferredPredicate(
    x: unknown
  ): asserts x is K.InferredPredicateKind {
    InferredPredicate.assert(x);
  }
  export function assertDeclaredPredicate(
    x: unknown
  ): asserts x is K.DeclaredPredicateKind {
    DeclaredPredicate.assert(x);
  }
  export function assertEnumDeclaration(
    x: unknown
  ): asserts x is K.EnumDeclarationKind {
    EnumDeclaration.assert(x);
  }
  export function assertEnumBooleanBody(
    x: unknown
  ): asserts x is K.EnumBooleanBodyKind {
    EnumBooleanBody.assert(x);
  }
  export function assertEnumNumberBody(
    x: unknown
  ): asserts x is K.EnumNumberBodyKind {
    EnumNumberBody.assert(x);
  }
  export function assertEnumStringBody(
    x: unknown
  ): asserts x is K.EnumStringBodyKind {
    EnumStringBody.assert(x);
  }
  export function assertEnumSymbolBody(
    x: unknown
  ): asserts x is K.EnumSymbolBodyKind {
    EnumSymbolBody.assert(x);
  }
  export function assertEnumBooleanMember(
    x: unknown
  ): asserts x is K.EnumBooleanMemberKind {
    EnumBooleanMember.assert(x);
  }
  export function assertEnumNumberMember(
    x: unknown
  ): asserts x is K.EnumNumberMemberKind {
    EnumNumberMember.assert(x);
  }
  export function assertEnumStringMember(
    x: unknown
  ): asserts x is K.EnumStringMemberKind {
    EnumStringMember.assert(x);
  }
  export function assertEnumDefaultedMember(
    x: unknown
  ): asserts x is K.EnumDefaultedMemberKind {
    EnumDefaultedMember.assert(x);
  }
  export function assertExportDeclaration(
    x: unknown
  ): asserts x is K.ExportDeclarationKind {
    ExportDeclaration.assert(x);
  }
  export function assertBlock(x: unknown): asserts x is K.BlockKind {
    Block.assert(x);
  }
  export function assertLine(x: unknown): asserts x is K.LineKind {
    Line.assert(x);
  }
  export function assertNoop(x: unknown): asserts x is K.NoopKind {
    Noop.assert(x);
  }
  export function assertDoExpression(
    x: unknown
  ): asserts x is K.DoExpressionKind {
    DoExpression.assert(x);
  }
  export function assertBindExpression(
    x: unknown
  ): asserts x is K.BindExpressionKind {
    BindExpression.assert(x);
  }
  export function assertParenthesizedExpression(
    x: unknown
  ): asserts x is K.ParenthesizedExpressionKind {
    ParenthesizedExpression.assert(x);
  }
  export function assertExportNamespaceSpecifier(
    x: unknown
  ): asserts x is K.ExportNamespaceSpecifierKind {
    ExportNamespaceSpecifier.assert(x);
  }
  export function assertExportDefaultSpecifier(
    x: unknown
  ): asserts x is K.ExportDefaultSpecifierKind {
    ExportDefaultSpecifier.assert(x);
  }
  export function assertCommentBlock(
    x: unknown
  ): asserts x is K.CommentBlockKind {
    CommentBlock.assert(x);
  }
  export function assertCommentLine(
    x: unknown
  ): asserts x is K.CommentLineKind {
    CommentLine.assert(x);
  }
  export function assertDirective(x: unknown): asserts x is K.DirectiveKind {
    Directive.assert(x);
  }
  export function assertDirectiveLiteral(
    x: unknown
  ): asserts x is K.DirectiveLiteralKind {
    DirectiveLiteral.assert(x);
  }
  export function assertInterpreterDirective(
    x: unknown
  ): asserts x is K.InterpreterDirectiveKind {
    InterpreterDirective.assert(x);
  }
  export function assertStringLiteral(
    x: unknown
  ): asserts x is K.StringLiteralKind {
    StringLiteral.assert(x);
  }
  export function assertNumericLiteral(
    x: unknown
  ): asserts x is K.NumericLiteralKind {
    NumericLiteral.assert(x);
  }
  export function assertBigIntLiteral(
    x: unknown
  ): asserts x is K.BigIntLiteralKind {
    BigIntLiteral.assert(x);
  }
  export function assertNullLiteral(
    x: unknown
  ): asserts x is K.NullLiteralKind {
    NullLiteral.assert(x);
  }
  export function assertBooleanLiteral(
    x: unknown
  ): asserts x is K.BooleanLiteralKind {
    BooleanLiteral.assert(x);
  }
  export function assertRegExpLiteral(
    x: unknown
  ): asserts x is K.RegExpLiteralKind {
    RegExpLiteral.assert(x);
  }
  export function assertClassMethod(
    x: unknown
  ): asserts x is K.ClassMethodKind {
    ClassMethod.assert(x);
  }
  export function assertClassPrivateMethod(
    x: unknown
  ): asserts x is K.ClassPrivateMethodKind {
    ClassPrivateMethod.assert(x);
  }
  export function assertRestProperty(
    x: unknown
  ): asserts x is K.RestPropertyKind {
    RestProperty.assert(x);
  }
  export function assertForAwaitStatement(
    x: unknown
  ): asserts x is K.ForAwaitStatementKind {
    ForAwaitStatement.assert(x);
  }
  export function assertImport(x: unknown): asserts x is K.ImportKind {
    Import.assert(x);
  }
  export function assertTSQualifiedName(
    x: unknown
  ): asserts x is K.TSQualifiedNameKind {
    TSQualifiedName.assert(x);
  }
  export function assertTSTypeReference(
    x: unknown
  ): asserts x is K.TSTypeReferenceKind {
    TSTypeReference.assert(x);
  }
  export function assertTSHasOptionalTypeParameters(
    x: unknown
  ): asserts x is K.TSHasOptionalTypeParametersKind {
    TSHasOptionalTypeParameters.assert(x);
  }
  export function assertTSHasOptionalTypeAnnotation(
    x: unknown
  ): asserts x is K.TSHasOptionalTypeAnnotationKind {
    TSHasOptionalTypeAnnotation.assert(x);
  }
  export function assertTSAsExpression(
    x: unknown
  ): asserts x is K.TSAsExpressionKind {
    TSAsExpression.assert(x);
  }
  export function assertTSNonNullExpression(
    x: unknown
  ): asserts x is K.TSNonNullExpressionKind {
    TSNonNullExpression.assert(x);
  }
  export function assertTSAnyKeyword(
    x: unknown
  ): asserts x is K.TSAnyKeywordKind {
    TSAnyKeyword.assert(x);
  }
  export function assertTSBigIntKeyword(
    x: unknown
  ): asserts x is K.TSBigIntKeywordKind {
    TSBigIntKeyword.assert(x);
  }
  export function assertTSBooleanKeyword(
    x: unknown
  ): asserts x is K.TSBooleanKeywordKind {
    TSBooleanKeyword.assert(x);
  }
  export function assertTSNeverKeyword(
    x: unknown
  ): asserts x is K.TSNeverKeywordKind {
    TSNeverKeyword.assert(x);
  }
  export function assertTSNullKeyword(
    x: unknown
  ): asserts x is K.TSNullKeywordKind {
    TSNullKeyword.assert(x);
  }
  export function assertTSNumberKeyword(
    x: unknown
  ): asserts x is K.TSNumberKeywordKind {
    TSNumberKeyword.assert(x);
  }
  export function assertTSObjectKeyword(
    x: unknown
  ): asserts x is K.TSObjectKeywordKind {
    TSObjectKeyword.assert(x);
  }
  export function assertTSStringKeyword(
    x: unknown
  ): asserts x is K.TSStringKeywordKind {
    TSStringKeyword.assert(x);
  }
  export function assertTSSymbolKeyword(
    x: unknown
  ): asserts x is K.TSSymbolKeywordKind {
    TSSymbolKeyword.assert(x);
  }
  export function assertTSUndefinedKeyword(
    x: unknown
  ): asserts x is K.TSUndefinedKeywordKind {
    TSUndefinedKeyword.assert(x);
  }
  export function assertTSUnknownKeyword(
    x: unknown
  ): asserts x is K.TSUnknownKeywordKind {
    TSUnknownKeyword.assert(x);
  }
  export function assertTSVoidKeyword(
    x: unknown
  ): asserts x is K.TSVoidKeywordKind {
    TSVoidKeyword.assert(x);
  }
  export function assertTSThisType(x: unknown): asserts x is K.TSThisTypeKind {
    TSThisType.assert(x);
  }
  export function assertTSArrayType(
    x: unknown
  ): asserts x is K.TSArrayTypeKind {
    TSArrayType.assert(x);
  }
  export function assertTSLiteralType(
    x: unknown
  ): asserts x is K.TSLiteralTypeKind {
    TSLiteralType.assert(x);
  }
  export function assertTSUnionType(
    x: unknown
  ): asserts x is K.TSUnionTypeKind {
    TSUnionType.assert(x);
  }
  export function assertTSIntersectionType(
    x: unknown
  ): asserts x is K.TSIntersectionTypeKind {
    TSIntersectionType.assert(x);
  }
  export function assertTSConditionalType(
    x: unknown
  ): asserts x is K.TSConditionalTypeKind {
    TSConditionalType.assert(x);
  }
  export function assertTSInferType(
    x: unknown
  ): asserts x is K.TSInferTypeKind {
    TSInferType.assert(x);
  }
  export function assertTSTypeParameter(
    x: unknown
  ): asserts x is K.TSTypeParameterKind {
    TSTypeParameter.assert(x);
  }
  export function assertTSParenthesizedType(
    x: unknown
  ): asserts x is K.TSParenthesizedTypeKind {
    TSParenthesizedType.assert(x);
  }
  export function assertTSFunctionType(
    x: unknown
  ): asserts x is K.TSFunctionTypeKind {
    TSFunctionType.assert(x);
  }
  export function assertTSConstructorType(
    x: unknown
  ): asserts x is K.TSConstructorTypeKind {
    TSConstructorType.assert(x);
  }
  export function assertTSDeclareFunction(
    x: unknown
  ): asserts x is K.TSDeclareFunctionKind {
    TSDeclareFunction.assert(x);
  }
  export function assertTSDeclareMethod(
    x: unknown
  ): asserts x is K.TSDeclareMethodKind {
    TSDeclareMethod.assert(x);
  }
  export function assertTSMappedType(
    x: unknown
  ): asserts x is K.TSMappedTypeKind {
    TSMappedType.assert(x);
  }
  export function assertTSTupleType(
    x: unknown
  ): asserts x is K.TSTupleTypeKind {
    TSTupleType.assert(x);
  }
  export function assertTSNamedTupleMember(
    x: unknown
  ): asserts x is K.TSNamedTupleMemberKind {
    TSNamedTupleMember.assert(x);
  }
  export function assertTSRestType(x: unknown): asserts x is K.TSRestTypeKind {
    TSRestType.assert(x);
  }
  export function assertTSOptionalType(
    x: unknown
  ): asserts x is K.TSOptionalTypeKind {
    TSOptionalType.assert(x);
  }
  export function assertTSIndexedAccessType(
    x: unknown
  ): asserts x is K.TSIndexedAccessTypeKind {
    TSIndexedAccessType.assert(x);
  }
  export function assertTSTypeOperator(
    x: unknown
  ): asserts x is K.TSTypeOperatorKind {
    TSTypeOperator.assert(x);
  }
  export function assertTSTypeElement(
    x: unknown
  ): asserts x is K.TSTypeElementKind {
    TSTypeElement.assert(x);
  }
  export function assertTSIndexSignature(
    x: unknown
  ): asserts x is K.TSIndexSignatureKind {
    TSIndexSignature.assert(x);
  }
  export function assertTSPropertySignature(
    x: unknown
  ): asserts x is K.TSPropertySignatureKind {
    TSPropertySignature.assert(x);
  }
  export function assertTSMethodSignature(
    x: unknown
  ): asserts x is K.TSMethodSignatureKind {
    TSMethodSignature.assert(x);
  }
  export function assertTSTypePredicate(
    x: unknown
  ): asserts x is K.TSTypePredicateKind {
    TSTypePredicate.assert(x);
  }
  export function assertTSCallSignatureDeclaration(
    x: unknown
  ): asserts x is K.TSCallSignatureDeclarationKind {
    TSCallSignatureDeclaration.assert(x);
  }
  export function assertTSConstructSignatureDeclaration(
    x: unknown
  ): asserts x is K.TSConstructSignatureDeclarationKind {
    TSConstructSignatureDeclaration.assert(x);
  }
  export function assertTSEnumMember(
    x: unknown
  ): asserts x is K.TSEnumMemberKind {
    TSEnumMember.assert(x);
  }
  export function assertTSTypeQuery(
    x: unknown
  ): asserts x is K.TSTypeQueryKind {
    TSTypeQuery.assert(x);
  }
  export function assertTSImportType(
    x: unknown
  ): asserts x is K.TSImportTypeKind {
    TSImportType.assert(x);
  }
  export function assertTSTypeLiteral(
    x: unknown
  ): asserts x is K.TSTypeLiteralKind {
    TSTypeLiteral.assert(x);
  }
  export function assertTSTypeAssertion(
    x: unknown
  ): asserts x is K.TSTypeAssertionKind {
    TSTypeAssertion.assert(x);
  }
  export function assertTSEnumDeclaration(
    x: unknown
  ): asserts x is K.TSEnumDeclarationKind {
    TSEnumDeclaration.assert(x);
  }
  export function assertTSTypeAliasDeclaration(
    x: unknown
  ): asserts x is K.TSTypeAliasDeclarationKind {
    TSTypeAliasDeclaration.assert(x);
  }
  export function assertTSModuleBlock(
    x: unknown
  ): asserts x is K.TSModuleBlockKind {
    TSModuleBlock.assert(x);
  }
  export function assertTSModuleDeclaration(
    x: unknown
  ): asserts x is K.TSModuleDeclarationKind {
    TSModuleDeclaration.assert(x);
  }
  export function assertTSImportEqualsDeclaration(
    x: unknown
  ): asserts x is K.TSImportEqualsDeclarationKind {
    TSImportEqualsDeclaration.assert(x);
  }
  export function assertTSExternalModuleReference(
    x: unknown
  ): asserts x is K.TSExternalModuleReferenceKind {
    TSExternalModuleReference.assert(x);
  }
  export function assertTSExportAssignment(
    x: unknown
  ): asserts x is K.TSExportAssignmentKind {
    TSExportAssignment.assert(x);
  }
  export function assertTSNamespaceExportDeclaration(
    x: unknown
  ): asserts x is K.TSNamespaceExportDeclarationKind {
    TSNamespaceExportDeclaration.assert(x);
  }
  export function assertTSInterfaceBody(
    x: unknown
  ): asserts x is K.TSInterfaceBodyKind {
    TSInterfaceBody.assert(x);
  }
  export function assertTSInterfaceDeclaration(
    x: unknown
  ): asserts x is K.TSInterfaceDeclarationKind {
    TSInterfaceDeclaration.assert(x);
  }
  export function assertTSParameterProperty(
    x: unknown
  ): asserts x is K.TSParameterPropertyKind {
    TSParameterProperty.assert(x);
  }
}
export interface NamedTypes {
  Printable: Type<namedTypes.Printable>;
  SourceLocation: Type<namedTypes.SourceLocation>;
  Node: Type<namedTypes.Node>;
  Comment: Type<namedTypes.Comment>;
  Position: Type<namedTypes.Position>;
  File: Type<namedTypes.File>;
  Program: Type<namedTypes.Program>;
  Statement: Type<namedTypes.Statement>;
  Function: Type<namedTypes.Function>;
  Expression: Type<namedTypes.Expression>;
  PatternLike: Type<namedTypes.PatternLike>;
  LVal: Type<namedTypes.LVal>;
  Identifier: Type<namedTypes.Identifier>;
  BlockStatement: Type<namedTypes.BlockStatement>;
  EmptyStatement: Type<namedTypes.EmptyStatement>;
  ExpressionStatement: Type<namedTypes.ExpressionStatement>;
  IfStatement: Type<namedTypes.IfStatement>;
  LabeledStatement: Type<namedTypes.LabeledStatement>;
  BreakStatement: Type<namedTypes.BreakStatement>;
  ContinueStatement: Type<namedTypes.ContinueStatement>;
  WithStatement: Type<namedTypes.WithStatement>;
  SwitchStatement: Type<namedTypes.SwitchStatement>;
  SwitchCase: Type<namedTypes.SwitchCase>;
  ReturnStatement: Type<namedTypes.ReturnStatement>;
  ThrowStatement: Type<namedTypes.ThrowStatement>;
  TryStatement: Type<namedTypes.TryStatement>;
  CatchClause: Type<namedTypes.CatchClause>;
  WhileStatement: Type<namedTypes.WhileStatement>;
  DoWhileStatement: Type<namedTypes.DoWhileStatement>;
  ForStatement: Type<namedTypes.ForStatement>;
  Declaration: Type<namedTypes.Declaration>;
  VariableDeclaration: Type<namedTypes.VariableDeclaration>;
  ForInStatement: Type<namedTypes.ForInStatement>;
  DebuggerStatement: Type<namedTypes.DebuggerStatement>;
  FunctionDeclaration: Type<namedTypes.FunctionDeclaration>;
  FunctionExpression: Type<namedTypes.FunctionExpression>;
  VariableDeclarator: Type<namedTypes.VariableDeclarator>;
  ThisExpression: Type<namedTypes.ThisExpression>;
  ArrayExpression: Type<namedTypes.ArrayExpression>;
  ObjectExpression: Type<namedTypes.ObjectExpression>;
  Property: Type<namedTypes.Property>;
  Literal: Type<namedTypes.Literal>;
  SequenceExpression: Type<namedTypes.SequenceExpression>;
  UnaryExpression: Type<namedTypes.UnaryExpression>;
  BinaryExpression: Type<namedTypes.BinaryExpression>;
  AssignmentExpression: Type<namedTypes.AssignmentExpression>;
  UpdateExpression: Type<namedTypes.UpdateExpression>;
  LogicalExpression: Type<namedTypes.LogicalExpression>;
  ConditionalExpression: Type<namedTypes.ConditionalExpression>;
  NewExpression: Type<namedTypes.NewExpression>;
  ChainElement: Type<namedTypes.ChainElement>;
  CallExpression: Type<namedTypes.CallExpression>;
  MemberExpression: Type<namedTypes.MemberExpression>;
  Pattern: Type<namedTypes.Pattern>;
  RestElement: Type<namedTypes.RestElement>;
  ArrowFunctionExpression: Type<namedTypes.ArrowFunctionExpression>;
  ForOfStatement: Type<namedTypes.ForOfStatement>;
  YieldExpression: Type<namedTypes.YieldExpression>;
  GeneratorExpression: Type<namedTypes.GeneratorExpression>;
  ComprehensionBlock: Type<namedTypes.ComprehensionBlock>;
  ComprehensionExpression: Type<namedTypes.ComprehensionExpression>;
  ObjectProperty: Type<namedTypes.ObjectProperty>;
  ArrayPattern: Type<namedTypes.ArrayPattern>;
  ObjectPattern: Type<namedTypes.ObjectPattern>;
  SpreadElement: Type<namedTypes.SpreadElement>;
  AssignmentPattern: Type<namedTypes.AssignmentPattern>;
  MethodDefinition: Type<namedTypes.MethodDefinition>;
  ClassPropertyDefinition: Type<namedTypes.ClassPropertyDefinition>;
  ClassProperty: Type<namedTypes.ClassProperty>;
  ClassBody: Type<namedTypes.ClassBody>;
  ClassDeclaration: Type<namedTypes.ClassDeclaration>;
  ClassExpression: Type<namedTypes.ClassExpression>;
  Super: Type<namedTypes.Super>;
  Specifier: Type<namedTypes.Specifier>;
  ModuleSpecifier: Type<namedTypes.ModuleSpecifier>;
  ImportSpecifier: Type<namedTypes.ImportSpecifier>;
  ImportDefaultSpecifier: Type<namedTypes.ImportDefaultSpecifier>;
  ImportNamespaceSpecifier: Type<namedTypes.ImportNamespaceSpecifier>;
  ImportDeclaration: Type<namedTypes.ImportDeclaration>;
  ExportNamedDeclaration: Type<namedTypes.ExportNamedDeclaration>;
  ExportSpecifier: Type<namedTypes.ExportSpecifier>;
  ExportDefaultDeclaration: Type<namedTypes.ExportDefaultDeclaration>;
  ExportAllDeclaration: Type<namedTypes.ExportAllDeclaration>;
  TaggedTemplateExpression: Type<namedTypes.TaggedTemplateExpression>;
  TemplateLiteral: Type<namedTypes.TemplateLiteral>;
  TemplateElement: Type<namedTypes.TemplateElement>;
  MetaProperty: Type<namedTypes.MetaProperty>;
  AwaitExpression: Type<namedTypes.AwaitExpression>;
  SpreadProperty: Type<namedTypes.SpreadProperty>;
  ObjectMethod: Type<namedTypes.ObjectMethod>;
  ImportExpression: Type<namedTypes.ImportExpression>;
  ChainExpression: Type<namedTypes.ChainExpression>;
  OptionalCallExpression: Type<namedTypes.OptionalCallExpression>;
  OptionalMemberExpression: Type<namedTypes.OptionalMemberExpression>;
  JSX: Type<namedTypes.JSX>;
  JSXAttribute: Type<namedTypes.JSXAttribute>;
  JSXIdentifier: Type<namedTypes.JSXIdentifier>;
  JSXNamespacedName: Type<namedTypes.JSXNamespacedName>;
  JSXExpressionContainer: Type<namedTypes.JSXExpressionContainer>;
  JSXElement: Type<namedTypes.JSXElement>;
  JSXFragment: Type<namedTypes.JSXFragment>;
  JSXMemberExpression: Type<namedTypes.JSXMemberExpression>;
  JSXSpreadAttribute: Type<namedTypes.JSXSpreadAttribute>;
  JSXEmptyExpression: Type<namedTypes.JSXEmptyExpression>;
  JSXText: Type<namedTypes.JSXText>;
  JSXSpreadChild: Type<namedTypes.JSXSpreadChild>;
  JSXOpeningElement: Type<namedTypes.JSXOpeningElement>;
  JSXClosingElement: Type<namedTypes.JSXClosingElement>;
  JSXOpeningFragment: Type<namedTypes.JSXOpeningFragment>;
  JSXClosingFragment: Type<namedTypes.JSXClosingFragment>;
  Decorator: Type<namedTypes.Decorator>;
  PrivateName: Type<namedTypes.PrivateName>;
  ClassPrivateProperty: Type<namedTypes.ClassPrivateProperty>;
  TypeAnnotation: Type<namedTypes.TypeAnnotation>;
  TSTypeAnnotation: Type<namedTypes.TSTypeAnnotation>;
  TypeParameterDeclaration: Type<namedTypes.TypeParameterDeclaration>;
  TSTypeParameterDeclaration: Type<namedTypes.TSTypeParameterDeclaration>;
  TypeParameterInstantiation: Type<namedTypes.TypeParameterInstantiation>;
  TSTypeParameterInstantiation: Type<namedTypes.TSTypeParameterInstantiation>;
  ClassImplements: Type<namedTypes.ClassImplements>;
  TSType: Type<namedTypes.TSType>;
  TSHasOptionalTypeParameterInstantiation: Type<namedTypes.TSHasOptionalTypeParameterInstantiation>;
  TSExpressionWithTypeArguments: Type<namedTypes.TSExpressionWithTypeArguments>;
  Flow: Type<namedTypes.Flow>;
  FlowType: Type<namedTypes.FlowType>;
  AnyTypeAnnotation: Type<namedTypes.AnyTypeAnnotation>;
  EmptyTypeAnnotation: Type<namedTypes.EmptyTypeAnnotation>;
  MixedTypeAnnotation: Type<namedTypes.MixedTypeAnnotation>;
  VoidTypeAnnotation: Type<namedTypes.VoidTypeAnnotation>;
  SymbolTypeAnnotation: Type<namedTypes.SymbolTypeAnnotation>;
  NumberTypeAnnotation: Type<namedTypes.NumberTypeAnnotation>;
  BigIntTypeAnnotation: Type<namedTypes.BigIntTypeAnnotation>;
  NumberLiteralTypeAnnotation: Type<namedTypes.NumberLiteralTypeAnnotation>;
  NumericLiteralTypeAnnotation: Type<namedTypes.NumericLiteralTypeAnnotation>;
  BigIntLiteralTypeAnnotation: Type<namedTypes.BigIntLiteralTypeAnnotation>;
  StringTypeAnnotation: Type<namedTypes.StringTypeAnnotation>;
  StringLiteralTypeAnnotation: Type<namedTypes.StringLiteralTypeAnnotation>;
  BooleanTypeAnnotation: Type<namedTypes.BooleanTypeAnnotation>;
  BooleanLiteralTypeAnnotation: Type<namedTypes.BooleanLiteralTypeAnnotation>;
  NullableTypeAnnotation: Type<namedTypes.NullableTypeAnnotation>;
  NullLiteralTypeAnnotation: Type<namedTypes.NullLiteralTypeAnnotation>;
  NullTypeAnnotation: Type<namedTypes.NullTypeAnnotation>;
  ThisTypeAnnotation: Type<namedTypes.ThisTypeAnnotation>;
  ExistsTypeAnnotation: Type<namedTypes.ExistsTypeAnnotation>;
  ExistentialTypeParam: Type<namedTypes.ExistentialTypeParam>;
  FunctionTypeAnnotation: Type<namedTypes.FunctionTypeAnnotation>;
  FunctionTypeParam: Type<namedTypes.FunctionTypeParam>;
  ArrayTypeAnnotation: Type<namedTypes.ArrayTypeAnnotation>;
  ObjectTypeAnnotation: Type<namedTypes.ObjectTypeAnnotation>;
  ObjectTypeProperty: Type<namedTypes.ObjectTypeProperty>;
  ObjectTypeSpreadProperty: Type<namedTypes.ObjectTypeSpreadProperty>;
  ObjectTypeIndexer: Type<namedTypes.ObjectTypeIndexer>;
  ObjectTypeCallProperty: Type<namedTypes.ObjectTypeCallProperty>;
  ObjectTypeInternalSlot: Type<namedTypes.ObjectTypeInternalSlot>;
  Variance: Type<namedTypes.Variance>;
  QualifiedTypeIdentifier: Type<namedTypes.QualifiedTypeIdentifier>;
  GenericTypeAnnotation: Type<namedTypes.GenericTypeAnnotation>;
  MemberTypeAnnotation: Type<namedTypes.MemberTypeAnnotation>;
  UnionTypeAnnotation: Type<namedTypes.UnionTypeAnnotation>;
  IntersectionTypeAnnotation: Type<namedTypes.IntersectionTypeAnnotation>;
  TypeofTypeAnnotation: Type<namedTypes.TypeofTypeAnnotation>;
  TypeParameter: Type<namedTypes.TypeParameter>;
  InterfaceTypeAnnotation: Type<namedTypes.InterfaceTypeAnnotation>;
  InterfaceExtends: Type<namedTypes.InterfaceExtends>;
  InterfaceDeclaration: Type<namedTypes.InterfaceDeclaration>;
  DeclareInterface: Type<namedTypes.DeclareInterface>;
  TypeAlias: Type<namedTypes.TypeAlias>;
  DeclareTypeAlias: Type<namedTypes.DeclareTypeAlias>;
  OpaqueType: Type<namedTypes.OpaqueType>;
  DeclareOpaqueType: Type<namedTypes.DeclareOpaqueType>;
  TypeCastExpression: Type<namedTypes.TypeCastExpression>;
  TupleTypeAnnotation: Type<namedTypes.TupleTypeAnnotation>;
  DeclareVariable: Type<namedTypes.DeclareVariable>;
  DeclareFunction: Type<namedTypes.DeclareFunction>;
  FlowPredicate: Type<namedTypes.FlowPredicate>;
  DeclareClass: Type<namedTypes.DeclareClass>;
  DeclareModule: Type<namedTypes.DeclareModule>;
  DeclareModuleExports: Type<namedTypes.DeclareModuleExports>;
  DeclareExportDeclaration: Type<namedTypes.DeclareExportDeclaration>;
  ExportBatchSpecifier: Type<namedTypes.ExportBatchSpecifier>;
  DeclareExportAllDeclaration: Type<namedTypes.DeclareExportAllDeclaration>;
  InferredPredicate: Type<namedTypes.InferredPredicate>;
  DeclaredPredicate: Type<namedTypes.DeclaredPredicate>;
  EnumDeclaration: Type<namedTypes.EnumDeclaration>;
  EnumBooleanBody: Type<namedTypes.EnumBooleanBody>;
  EnumNumberBody: Type<namedTypes.EnumNumberBody>;
  EnumStringBody: Type<namedTypes.EnumStringBody>;
  EnumSymbolBody: Type<namedTypes.EnumSymbolBody>;
  EnumBooleanMember: Type<namedTypes.EnumBooleanMember>;
  EnumNumberMember: Type<namedTypes.EnumNumberMember>;
  EnumStringMember: Type<namedTypes.EnumStringMember>;
  EnumDefaultedMember: Type<namedTypes.EnumDefaultedMember>;
  ExportDeclaration: Type<namedTypes.ExportDeclaration>;
  Block: Type<namedTypes.Block>;
  Line: Type<namedTypes.Line>;
  Noop: Type<namedTypes.Noop>;
  DoExpression: Type<namedTypes.DoExpression>;
  BindExpression: Type<namedTypes.BindExpression>;
  ParenthesizedExpression: Type<namedTypes.ParenthesizedExpression>;
  ExportNamespaceSpecifier: Type<namedTypes.ExportNamespaceSpecifier>;
  ExportDefaultSpecifier: Type<namedTypes.ExportDefaultSpecifier>;
  CommentBlock: Type<namedTypes.CommentBlock>;
  CommentLine: Type<namedTypes.CommentLine>;
  Directive: Type<namedTypes.Directive>;
  DirectiveLiteral: Type<namedTypes.DirectiveLiteral>;
  InterpreterDirective: Type<namedTypes.InterpreterDirective>;
  StringLiteral: Type<namedTypes.StringLiteral>;
  NumericLiteral: Type<namedTypes.NumericLiteral>;
  BigIntLiteral: Type<namedTypes.BigIntLiteral>;
  NullLiteral: Type<namedTypes.NullLiteral>;
  BooleanLiteral: Type<namedTypes.BooleanLiteral>;
  RegExpLiteral: Type<namedTypes.RegExpLiteral>;
  ClassMethod: Type<namedTypes.ClassMethod>;
  ClassPrivateMethod: Type<namedTypes.ClassPrivateMethod>;
  RestProperty: Type<namedTypes.RestProperty>;
  ForAwaitStatement: Type<namedTypes.ForAwaitStatement>;
  Import: Type<namedTypes.Import>;
  TSQualifiedName: Type<namedTypes.TSQualifiedName>;
  TSTypeReference: Type<namedTypes.TSTypeReference>;
  TSHasOptionalTypeParameters: Type<namedTypes.TSHasOptionalTypeParameters>;
  TSHasOptionalTypeAnnotation: Type<namedTypes.TSHasOptionalTypeAnnotation>;
  TSAsExpression: Type<namedTypes.TSAsExpression>;
  TSNonNullExpression: Type<namedTypes.TSNonNullExpression>;
  TSAnyKeyword: Type<namedTypes.TSAnyKeyword>;
  TSBigIntKeyword: Type<namedTypes.TSBigIntKeyword>;
  TSBooleanKeyword: Type<namedTypes.TSBooleanKeyword>;
  TSNeverKeyword: Type<namedTypes.TSNeverKeyword>;
  TSNullKeyword: Type<namedTypes.TSNullKeyword>;
  TSNumberKeyword: Type<namedTypes.TSNumberKeyword>;
  TSObjectKeyword: Type<namedTypes.TSObjectKeyword>;
  TSStringKeyword: Type<namedTypes.TSStringKeyword>;
  TSSymbolKeyword: Type<namedTypes.TSSymbolKeyword>;
  TSUndefinedKeyword: Type<namedTypes.TSUndefinedKeyword>;
  TSUnknownKeyword: Type<namedTypes.TSUnknownKeyword>;
  TSVoidKeyword: Type<namedTypes.TSVoidKeyword>;
  TSThisType: Type<namedTypes.TSThisType>;
  TSArrayType: Type<namedTypes.TSArrayType>;
  TSLiteralType: Type<namedTypes.TSLiteralType>;
  TSUnionType: Type<namedTypes.TSUnionType>;
  TSIntersectionType: Type<namedTypes.TSIntersectionType>;
  TSConditionalType: Type<namedTypes.TSConditionalType>;
  TSInferType: Type<namedTypes.TSInferType>;
  TSTypeParameter: Type<namedTypes.TSTypeParameter>;
  TSParenthesizedType: Type<namedTypes.TSParenthesizedType>;
  TSFunctionType: Type<namedTypes.TSFunctionType>;
  TSConstructorType: Type<namedTypes.TSConstructorType>;
  TSDeclareFunction: Type<namedTypes.TSDeclareFunction>;
  TSDeclareMethod: Type<namedTypes.TSDeclareMethod>;
  TSMappedType: Type<namedTypes.TSMappedType>;
  TSTupleType: Type<namedTypes.TSTupleType>;
  TSNamedTupleMember: Type<namedTypes.TSNamedTupleMember>;
  TSRestType: Type<namedTypes.TSRestType>;
  TSOptionalType: Type<namedTypes.TSOptionalType>;
  TSIndexedAccessType: Type<namedTypes.TSIndexedAccessType>;
  TSTypeOperator: Type<namedTypes.TSTypeOperator>;
  TSTypeElement: Type<namedTypes.TSTypeElement>;
  TSIndexSignature: Type<namedTypes.TSIndexSignature>;
  TSPropertySignature: Type<namedTypes.TSPropertySignature>;
  TSMethodSignature: Type<namedTypes.TSMethodSignature>;
  TSTypePredicate: Type<namedTypes.TSTypePredicate>;
  TSCallSignatureDeclaration: Type<namedTypes.TSCallSignatureDeclaration>;
  TSConstructSignatureDeclaration: Type<namedTypes.TSConstructSignatureDeclaration>;
  TSEnumMember: Type<namedTypes.TSEnumMember>;
  TSTypeQuery: Type<namedTypes.TSTypeQuery>;
  TSImportType: Type<namedTypes.TSImportType>;
  TSTypeLiteral: Type<namedTypes.TSTypeLiteral>;
  TSTypeAssertion: Type<namedTypes.TSTypeAssertion>;
  TSEnumDeclaration: Type<namedTypes.TSEnumDeclaration>;
  TSTypeAliasDeclaration: Type<namedTypes.TSTypeAliasDeclaration>;
  TSModuleBlock: Type<namedTypes.TSModuleBlock>;
  TSModuleDeclaration: Type<namedTypes.TSModuleDeclaration>;
  TSImportEqualsDeclaration: Type<namedTypes.TSImportEqualsDeclaration>;
  TSExternalModuleReference: Type<namedTypes.TSExternalModuleReference>;
  TSExportAssignment: Type<namedTypes.TSExportAssignment>;
  TSNamespaceExportDeclaration: Type<namedTypes.TSNamespaceExportDeclaration>;
  TSInterfaceBody: Type<namedTypes.TSInterfaceBody>;
  TSInterfaceDeclaration: Type<namedTypes.TSInterfaceDeclaration>;
  TSParameterProperty: Type<namedTypes.TSParameterProperty>;
}
