// !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!!
import { Omit } from "../types";
import { Type } from "../lib/types";
import * as K from "./kinds";
export namespace namedTypes {
  export type Node =
    | AwaitExpression
    | Decorator
    | Property
    | MethodDefinition
    | PrivateName
    | Identifier
    | ClassPrivateProperty
    | File
    | Program
    | BlockStatement
    | EmptyStatement
    | ExpressionStatement
    | IfStatement
    | LabeledStatement
    | BreakStatement
    | ContinueStatement
    | WithStatement
    | SwitchStatement
    | SwitchCase
    | ReturnStatement
    | ThrowStatement
    | TryStatement
    | CatchClause
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | VariableDeclaration
    | ForInStatement
    | DebuggerStatement
    | FunctionDeclaration
    | FunctionExpression
    | VariableDeclarator
    | ThisExpression
    | ArrayExpression
    | ObjectExpression
    | SequenceExpression
    | UnaryExpression
    | BinaryExpression
    | AssignmentExpression
    | UpdateExpression
    | LogicalExpression
    | ConditionalExpression
    | NewExpression
    | CallExpression
    | MemberExpression
    | Placeholder
    | RestElement
    | ArrowFunctionExpression
    | ForOfStatement
    | YieldExpression
    | GeneratorExpression
    | ComprehensionBlock
    | ComprehensionExpression
    | ObjectProperty
    | ArrayPattern
    | ObjectPattern
    | SpreadElement
    | AssignmentPattern
    | ClassPropertyDefinition
    | ClassProperty
    | ClassBody
    | ClassDeclaration
    | ClassExpression
    | Super
    | ImportSpecifier
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportDeclaration
    | ExportNamedDeclaration
    | ExportSpecifier
    | ExportDefaultDeclaration
    | ExportAllDeclaration
    | TaggedTemplateExpression
    | TemplateLiteral
    | TemplateElement
    | MetaProperty
    | ExportBatchSpecifier
    | ExportDeclaration
    | Noop
    | DoExpression
    | BindExpression
    | ParenthesizedExpression
    | ExportNamespaceSpecifier
    | ExportDefaultSpecifier
    | Directive
    | DirectiveLiteral
    | InterpreterDirective
    | StringLiteral
    | NumericLiteral
    | BigIntLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | ObjectMethod
    | ClassMethod
    | ClassPrivateMethod
    | ForAwaitStatement
    | Import
    | TSTypeAnnotation
    | TSTypeParameterDeclaration
    | TSTypeParameterInstantiation
    | TSExpressionWithTypeArguments
    | TSQualifiedName
    | TSTypeReference
    | TSAsExpression
    | TSNonNullExpression
    | TSAnyKeyword
    | TSBigIntKeyword
    | TSBooleanKeyword
    | TSNeverKeyword
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSUndefinedKeyword
    | TSUnknownKeyword
    | TSVoidKeyword
    | TSThisType
    | TSArrayType
    | TSLiteralType
    | TSUnionType
    | TSIntersectionType
    | TSConditionalType
    | TSInferType
    | TSTypeParameter
    | TSParenthesizedType
    | TSFunctionType
    | TSConstructorType
    | TSDeclareFunction
    | TSDeclareMethod
    | TSMappedType
    | TSTupleType
    | TSNamedTupleMember
    | TSRestType
    | TSOptionalType
    | TSIndexedAccessType
    | TSTypeOperator
    | TSIndexSignature
    | TSPropertySignature
    | TSMethodSignature
    | TSTypePredicate
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSEnumMember
    | TSTypeQuery
    | TSImportType
    | TSTypeLiteral
    | TSTypeAssertion
    | TSEnumDeclaration
    | TSTypeAliasDeclaration
    | TSModuleBlock
    | TSModuleDeclaration
    | TSImportEqualsDeclaration
    | TSExternalModuleReference
    | TSExportAssignment
    | TSNamespaceExportDeclaration
    | TSInterfaceBody
    | TSInterfaceDeclaration
    | TSParameterProperty;
  export type Placeholderable =
    | AwaitExpression
    | MethodDefinition
    | PrivateName
    | Identifier
    | ClassPrivateProperty
    | BlockStatement
    | EmptyStatement
    | ExpressionStatement
    | IfStatement
    | LabeledStatement
    | BreakStatement
    | ContinueStatement
    | WithStatement
    | SwitchStatement
    | ReturnStatement
    | ThrowStatement
    | TryStatement
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | VariableDeclaration
    | ForInStatement
    | DebuggerStatement
    | FunctionDeclaration
    | FunctionExpression
    | ThisExpression
    | ArrayExpression
    | ObjectExpression
    | SequenceExpression
    | UnaryExpression
    | BinaryExpression
    | AssignmentExpression
    | UpdateExpression
    | LogicalExpression
    | ConditionalExpression
    | NewExpression
    | CallExpression
    | MemberExpression
    | ArrowFunctionExpression
    | ForOfStatement
    | YieldExpression
    | GeneratorExpression
    | ComprehensionExpression
    | ArrayPattern
    | ObjectPattern
    | AssignmentPattern
    | ClassPropertyDefinition
    | ClassProperty
    | ClassBody
    | ClassDeclaration
    | ClassExpression
    | Super
    | ImportDeclaration
    | ExportNamedDeclaration
    | ExportDefaultDeclaration
    | ExportAllDeclaration
    | TaggedTemplateExpression
    | TemplateLiteral
    | MetaProperty
    | ExportDeclaration
    | Noop
    | DoExpression
    | BindExpression
    | ParenthesizedExpression
    | DirectiveLiteral
    | StringLiteral
    | NumericLiteral
    | BigIntLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | ForAwaitStatement
    | Import
    | TSTypeParameterDeclaration
    | TSAsExpression
    | TSNonNullExpression
    | TSDeclareFunction
    | TSDeclareMethod
    | TSTypeAssertion
    | TSEnumDeclaration
    | TSTypeAliasDeclaration
    | TSModuleDeclaration
    | TSImportEqualsDeclaration
    | TSExportAssignment
    | TSNamespaceExportDeclaration
    | TSInterfaceDeclaration;
  export type Expression =
    | AwaitExpression
    | PrivateName
    | Identifier
    | FunctionExpression
    | ThisExpression
    | ArrayExpression
    | ObjectExpression
    | SequenceExpression
    | UnaryExpression
    | BinaryExpression
    | AssignmentExpression
    | UpdateExpression
    | LogicalExpression
    | ConditionalExpression
    | NewExpression
    | CallExpression
    | MemberExpression
    | ArrowFunctionExpression
    | YieldExpression
    | GeneratorExpression
    | ComprehensionExpression
    | ClassExpression
    | Super
    | TaggedTemplateExpression
    | TemplateLiteral
    | MetaProperty
    | DoExpression
    | BindExpression
    | ParenthesizedExpression
    | DirectiveLiteral
    | StringLiteral
    | NumericLiteral
    | BigIntLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | Import
    | TSAsExpression
    | TSNonNullExpression
    | TSTypeAssertion;
  export type Statement =
    | MethodDefinition
    | ClassPrivateProperty
    | BlockStatement
    | EmptyStatement
    | ExpressionStatement
    | IfStatement
    | LabeledStatement
    | BreakStatement
    | ContinueStatement
    | WithStatement
    | SwitchStatement
    | ReturnStatement
    | ThrowStatement
    | TryStatement
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | VariableDeclaration
    | ForInStatement
    | DebuggerStatement
    | FunctionDeclaration
    | ForOfStatement
    | ClassPropertyDefinition
    | ClassProperty
    | ClassBody
    | ClassDeclaration
    | ImportDeclaration
    | ExportNamedDeclaration
    | ExportDefaultDeclaration
    | ExportAllDeclaration
    | ExportDeclaration
    | Noop
    | ForAwaitStatement
    | TSTypeParameterDeclaration
    | TSDeclareFunction
    | TSDeclareMethod
    | TSEnumDeclaration
    | TSTypeAliasDeclaration
    | TSModuleDeclaration
    | TSImportEqualsDeclaration
    | TSExportAssignment
    | TSNamespaceExportDeclaration
    | TSInterfaceDeclaration;
  export type Declaration =
    | MethodDefinition
    | ClassPrivateProperty
    | VariableDeclaration
    | FunctionDeclaration
    | ClassPropertyDefinition
    | ClassProperty
    | ClassBody
    | ClassDeclaration
    | ImportDeclaration
    | ExportNamedDeclaration
    | ExportDefaultDeclaration
    | ExportAllDeclaration
    | ExportDeclaration
    | TSTypeParameterDeclaration
    | TSDeclareFunction
    | TSDeclareMethod
    | TSEnumDeclaration
    | TSTypeAliasDeclaration
    | TSModuleDeclaration
    | TSInterfaceDeclaration;
  export type PatternLike =
    | Identifier
    | RestElement
    | ArrayPattern
    | ObjectPattern
    | AssignmentPattern;
  export type LVal =
    | Identifier
    | MemberExpression
    | RestElement
    | ArrayPattern
    | ObjectPattern
    | AssignmentPattern
    | TSParameterProperty;
  export type Comment = Block | Line | CommentBlock | CommentLine;
  export type Scopable =
    | Program
    | BlockStatement
    | SwitchStatement
    | CatchClause
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | ForInStatement
    | FunctionDeclaration
    | FunctionExpression
    | ArrowFunctionExpression
    | ForOfStatement
    | ClassDeclaration
    | ClassExpression
    | ObjectMethod
    | ClassMethod
    | ClassPrivateMethod;
  export type BlockParent =
    | Program
    | BlockStatement
    | SwitchStatement
    | CatchClause
    | FunctionDeclaration
    | FunctionExpression
    | ArrowFunctionExpression
    | ObjectMethod
    | ClassMethod
    | ClassPrivateMethod;
  export type Function =
    | FunctionDeclaration
    | FunctionExpression
    | ArrowFunctionExpression
    | ObjectMethod
    | ClassMethod
    | ClassPrivateMethod;
  export type FunctionParent =
    | FunctionDeclaration
    | FunctionExpression
    | ArrowFunctionExpression
    | ObjectMethod
    | ClassMethod
    | ClassPrivateMethod;
  export type Conditional = IfStatement | ConditionalExpression;
  export type CompletionStatement =
    | BreakStatement
    | ContinueStatement
    | ReturnStatement
    | ThrowStatement;
  export type Loop =
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | ForInStatement
    | ForOfStatement;
  export type While = WhileStatement | DoWhileStatement;
  export type For = ForStatement | ForInStatement | ForOfStatement;
  export type ForX = ForInStatement | ForOfStatement;
  export type Pureish =
    | FunctionDeclaration
    | FunctionExpression
    | StringLiteral
    | NumericLiteral
    | BigIntLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral;
  export type Literal =
    | StringLiteral
    | NumericLiteral
    | BigIntLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral;
  export type Binary = BinaryExpression | LogicalExpression;
  export type Pattern = ArrayPattern | ObjectPattern | AssignmentPattern;
  export type Class = ClassDeclaration | ClassExpression;
  export type Specifier =
    | ImportSpecifier
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ExportSpecifier
    | ExportBatchSpecifier
    | ExportNamespaceSpecifier
    | ExportDefaultSpecifier;
  export type ModuleSpecifier =
    | ImportSpecifier
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ExportSpecifier;
  export type TSType =
    | TSExpressionWithTypeArguments
    | TSTypeReference
    | TSAnyKeyword
    | TSBigIntKeyword
    | TSBooleanKeyword
    | TSNeverKeyword
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSUndefinedKeyword
    | TSUnknownKeyword
    | TSVoidKeyword
    | TSThisType
    | TSArrayType
    | TSLiteralType
    | TSUnionType
    | TSIntersectionType
    | TSConditionalType
    | TSInferType
    | TSParenthesizedType
    | TSFunctionType
    | TSConstructorType
    | TSMappedType
    | TSTupleType
    | TSNamedTupleMember
    | TSRestType
    | TSOptionalType
    | TSIndexedAccessType
    | TSTypeOperator
    | TSTypePredicate
    | TSTypeQuery
    | TSImportType
    | TSTypeLiteral;
  export type TSTypeElement =
    | TSIndexSignature
    | TSPropertySignature
    | TSMethodSignature
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration;
  export interface BaseNode {
    type: string;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }
  export interface AwaitExpression extends BaseNode {
    argument: Expression;
    all?: boolean;
    type: "AwaitExpression";
  }
  export interface Decorator extends BaseNode {
    expression: Expression;
    type: "Decorator";
  }
  export interface Property extends BaseNode {
    decorators?: namedTypes.Decorator[] | null;
    kind: "init" | "get" | "set";
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    value: namedTypes.Expression | namedTypes.PatternLike;
    method?: boolean;
    shorthand?: boolean;
    computed?: boolean;
    type: "Property";
  }
  export interface MethodDefinition extends BaseNode {
    decorators?: namedTypes.Decorator[] | null;
    kind: "constructor" | "method" | "get" | "set";
    key: Expression;
    value: Function;
    computed?: boolean;
    static?: boolean;
    type: "MethodDefinition";
  }
  export interface PrivateName extends BaseNode {
    id: Identifier;
    type: "PrivateName";
  }
  export interface Identifier extends BaseNode {
    name: string;
    optional?: boolean;
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
    type: "Identifier";
  }
  export interface ClassPrivateProperty extends BaseNode {
    key: PrivateName;
    value?: namedTypes.Expression | null;
    computed?: boolean;
    type: "ClassPrivateProperty";
  }
  export interface SourceLocation {
    start: Position;
    end: Position;
    source?: string | null;
  }
  export interface Position {
    line: number;
    column: number;
  }
  export interface File extends BaseNode {
    program: Program;
    name?: string | null;
    type: "File";
  }
  export interface Program extends BaseNode {
    body: namedTypes.Statement[];
    directives: namedTypes.Directive[];
    interpreter?: namedTypes.InterpreterDirective | null;
    type: "Program";
  }
  export interface BaseFunction extends BaseNode {
    id?: namedTypes.Identifier | null;
    params: namedTypes.PatternLike[];
    body: BlockStatement;
    generator?: boolean;
    async?: boolean;
    expression?: boolean;
    defaults: (namedTypes.Expression | null)[];
    rest?: namedTypes.Identifier | null;
  }
  export interface BlockStatement extends BaseNode {
    body: namedTypes.Statement[];
    directives: namedTypes.Directive[];
    type: "BlockStatement";
  }
  export interface EmptyStatement extends BaseNode {
    type: "EmptyStatement";
  }
  export interface ExpressionStatement extends BaseNode {
    expression: Expression;
    type: "ExpressionStatement";
  }
  export interface IfStatement extends BaseNode {
    test: Expression;
    consequent: Statement;
    alternate?: namedTypes.Statement | null;
    type: "IfStatement";
  }
  export interface LabeledStatement extends BaseNode {
    label: Identifier;
    body: Statement;
    type: "LabeledStatement";
  }
  export interface BreakStatement extends BaseNode {
    label?: namedTypes.Identifier | null;
    type: "BreakStatement";
  }
  export interface ContinueStatement extends BaseNode {
    label?: namedTypes.Identifier | null;
    type: "ContinueStatement";
  }
  export interface WithStatement extends BaseNode {
    object: Expression;
    body: Statement;
    type: "WithStatement";
  }
  export interface SwitchStatement extends BaseNode {
    discriminant: Expression;
    cases: namedTypes.SwitchCase[];
    lexical?: boolean;
    type: "SwitchStatement";
  }
  export interface SwitchCase extends BaseNode {
    test: namedTypes.Expression | null;
    consequent: namedTypes.Statement[];
    type: "SwitchCase";
  }
  export interface ReturnStatement extends BaseNode {
    argument: namedTypes.Expression | null;
    type: "ReturnStatement";
  }
  export interface ThrowStatement extends BaseNode {
    argument: Expression;
    type: "ThrowStatement";
  }
  export interface TryStatement extends BaseNode {
    block: BlockStatement;
    handler?: namedTypes.CatchClause | null;
    handlers: namedTypes.CatchClause[];
    guardedHandlers: namedTypes.CatchClause[];
    finalizer?: namedTypes.BlockStatement | null;
    type: "TryStatement";
  }
  export interface CatchClause extends BaseNode {
    param:
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
      | namedTypes.Identifier
      | null;
    guard?: namedTypes.Expression | null;
    body: BlockStatement;
    type: "CatchClause";
  }
  export interface WhileStatement extends BaseNode {
    test: Expression;
    body: Statement;
    type: "WhileStatement";
  }
  export interface DoWhileStatement extends BaseNode {
    body: Statement;
    test: Expression;
    type: "DoWhileStatement";
  }
  export interface ForStatement extends BaseNode {
    init: namedTypes.VariableDeclaration | namedTypes.Expression | null;
    test: namedTypes.Expression | null;
    update: namedTypes.Expression | null;
    body: Statement;
    type: "ForStatement";
  }
  export interface VariableDeclaration extends BaseNode {
    kind: "var" | "let" | "const";
    declarations: (namedTypes.VariableDeclarator | namedTypes.Identifier)[];
    type: "VariableDeclaration";
  }
  export interface ForInStatement extends BaseNode {
    left: namedTypes.VariableDeclaration | namedTypes.LVal;
    right: Expression;
    body: Statement;
    type: "ForInStatement";
  }
  export interface DebuggerStatement extends BaseNode {
    type: "DebuggerStatement";
  }
  export interface FunctionDeclaration extends Omit<BaseFunction, "id"> {
    id: namedTypes.Identifier | null;
    returnType?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
    type: "FunctionDeclaration";
  }
  export interface FunctionExpression extends BaseFunction {
    returnType?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
    type: "FunctionExpression";
  }
  export interface VariableDeclarator extends BaseNode {
    id: LVal;
    init?: namedTypes.Expression | null;
    type: "VariableDeclarator";
  }
  export interface ThisExpression extends BaseNode {
    type: "ThisExpression";
  }
  export interface ArrayExpression extends BaseNode {
    elements: (namedTypes.Expression | namedTypes.SpreadElement | null)[];
    type: "ArrayExpression";
  }
  export interface ObjectExpression extends BaseNode {
    properties: (
      | namedTypes.Property
      | namedTypes.ObjectMethod
      | namedTypes.ObjectProperty
      | namedTypes.SpreadElement
    )[];
    type: "ObjectExpression";
  }
  export interface SequenceExpression extends BaseNode {
    expressions: namedTypes.Expression[];
    type: "SequenceExpression";
  }
  export interface UnaryExpression extends BaseNode {
    operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";
    argument: Expression;
    prefix: boolean;
    type: "UnaryExpression";
  }
  export interface BinaryExpression extends BaseNode {
    operator:
      | "=="
      | "!="
      | "==="
      | "!=="
      | "<"
      | "<="
      | ">"
      | ">="
      | "<<"
      | ">>"
      | ">>>"
      | "+"
      | "-"
      | "*"
      | "/"
      | "%"
      | "&"
      | "|"
      | "^"
      | "in"
      | "instanceof";
    left: Expression;
    right: Expression;
    type: "BinaryExpression";
  }
  export interface AssignmentExpression extends BaseNode {
    operator:
      | "="
      | "+="
      | "-="
      | "*="
      | "/="
      | "%="
      | "<<="
      | ">>="
      | ">>>="
      | "|="
      | "^="
      | "&=";
    left: LVal;
    right: Expression;
    type: "AssignmentExpression";
  }
  export interface UpdateExpression extends BaseNode {
    operator: "++" | "--";
    argument: Expression;
    prefix: boolean;
    type: "UpdateExpression";
  }
  export interface LogicalExpression extends BaseNode {
    operator: "||" | "&&";
    left: Expression;
    right: Expression;
    type: "LogicalExpression";
  }
  export interface ConditionalExpression extends BaseNode {
    test: Expression;
    consequent: Expression;
    alternate: Expression;
    type: "ConditionalExpression";
  }
  export interface NewExpression extends BaseNode {
    callee: Expression;
    arguments: (namedTypes.Expression | namedTypes.SpreadElement)[];
    type: "NewExpression";
  }
  export interface CallExpression extends BaseNode {
    callee: Expression;
    arguments: (namedTypes.Expression | namedTypes.SpreadElement)[];
    type: "CallExpression";
  }
  export interface MemberExpression extends BaseNode {
    object: Expression;
    property: namedTypes.Identifier | namedTypes.Expression;
    computed?: boolean;
    type: "MemberExpression";
  }
  export interface BaseComment {
    loc?: namedTypes.SourceLocation | null;
    value: string;
    leading: boolean;
    trailing?: boolean;
  }
  export interface Placeholder extends BaseNode {
    name: Identifier;
    expectedNode:
      | "Identifier"
      | "StringLiteral"
      | "Expression"
      | "Statement"
      | "Declaration"
      | "BlockStatement"
      | "ClassBody"
      | "Pattern";
    type: "Placeholder";
  }
  export interface RestElement extends BaseNode {
    argument: LVal;
    type: "RestElement";
  }
  export interface ArrowFunctionExpression
    extends Omit<BaseFunction, "id" | "body" | "generator"> {
    id?: null;
    body: namedTypes.BlockStatement | namedTypes.Expression;
    generator?: false;
    returnType?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
    type: "ArrowFunctionExpression";
  }
  export interface ForOfStatement extends BaseNode {
    left: namedTypes.VariableDeclaration | namedTypes.LVal;
    right: Expression;
    body: Statement;
    type: "ForOfStatement";
  }
  export interface YieldExpression extends BaseNode {
    argument: namedTypes.Expression | null;
    delegate?: boolean;
    type: "YieldExpression";
  }
  export interface GeneratorExpression extends BaseNode {
    body: Expression;
    blocks: namedTypes.ComprehensionBlock[];
    filter: namedTypes.Expression | null;
    type: "GeneratorExpression";
  }
  export interface ComprehensionBlock extends BaseNode {
    left: Pattern;
    right: Expression;
    each: boolean;
    type: "ComprehensionBlock";
  }
  export interface ComprehensionExpression extends BaseNode {
    body: Expression;
    blocks: namedTypes.ComprehensionBlock[];
    filter: namedTypes.Expression | null;
    type: "ComprehensionExpression";
  }
  export interface ObjectProperty extends BaseNode {
    shorthand?: boolean;
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    value: namedTypes.Expression | namedTypes.PatternLike;
    accessibility?: namedTypes.Literal | null;
    computed?: boolean;
    type: "ObjectProperty";
  }
  export interface ArrayPattern extends BaseNode {
    elements: (namedTypes.PatternLike | null)[];
    type: "ArrayPattern";
  }
  export interface ObjectPattern extends BaseNode {
    properties: (namedTypes.Property | namedTypes.ObjectProperty)[];
    decorators?: namedTypes.Decorator[] | null;
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
    type: "ObjectPattern";
  }
  export interface SpreadElement extends BaseNode {
    argument: Expression;
    type: "SpreadElement";
  }
  export interface AssignmentPattern extends BaseNode {
    left:
      | namedTypes.Identifier
      | namedTypes.ObjectPattern
      | namedTypes.ArrayPattern
      | namedTypes.MemberExpression;
    right: Expression;
    type: "AssignmentPattern";
  }
  export interface ClassPropertyDefinition extends BaseNode {
    definition:
      | namedTypes.MethodDefinition
      | namedTypes.VariableDeclarator
      | namedTypes.ClassPropertyDefinition
      | namedTypes.ClassProperty;
    type: "ClassPropertyDefinition";
  }
  export interface ClassProperty extends BaseNode {
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    computed?: boolean;
    value: namedTypes.Expression | null;
    static?: boolean;
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
    access?: "public" | "private" | "protected" | undefined;
    type: "ClassProperty";
  }
  export interface ClassBody extends BaseNode {
    body: (
      | namedTypes.MethodDefinition
      | namedTypes.VariableDeclarator
      | namedTypes.ClassPropertyDefinition
      | namedTypes.ClassProperty
      | namedTypes.ClassPrivateProperty
      | namedTypes.ClassMethod
      | namedTypes.ClassPrivateMethod
      | namedTypes.TSDeclareMethod
      | (
          | namedTypes.TSCallSignatureDeclaration
          | namedTypes.TSConstructSignatureDeclaration
          | namedTypes.TSIndexSignature
          | namedTypes.TSMethodSignature
          | namedTypes.TSPropertySignature
        )
    )[];
    type: "ClassBody";
  }
  export interface ClassDeclaration extends BaseNode {
    id: namedTypes.Identifier | null;
    body: ClassBody;
    superClass?: namedTypes.Expression | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
    superTypeParameters?: namedTypes.TSTypeParameterInstantiation | null;
    implements: TSExpressionWithTypeArguments;
    type: "ClassDeclaration";
  }
  export interface ClassExpression extends BaseNode {
    id?: namedTypes.Identifier | null;
    body: ClassBody;
    superClass?: namedTypes.Expression | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
    superTypeParameters?: namedTypes.TSTypeParameterInstantiation | null;
    implements: TSExpressionWithTypeArguments;
    type: "ClassExpression";
  }
  export interface Super extends BaseNode {
    type: "Super";
  }
  export interface ImportSpecifier extends BaseNode {
    local?: namedTypes.Identifier | null;
    id?: namedTypes.Identifier | null;
    name?: namedTypes.Identifier | null;
    imported: Identifier;
    type: "ImportSpecifier";
  }
  export interface ImportDefaultSpecifier extends BaseNode {
    local?: namedTypes.Identifier | null;
    id?: namedTypes.Identifier | null;
    name?: namedTypes.Identifier | null;
    type: "ImportDefaultSpecifier";
  }
  export interface ImportNamespaceSpecifier extends BaseNode {
    local?: namedTypes.Identifier | null;
    id?: namedTypes.Identifier | null;
    name?: namedTypes.Identifier | null;
    type: "ImportNamespaceSpecifier";
  }
  export interface ImportDeclaration extends BaseNode {
    specifiers: (
      | namedTypes.ImportSpecifier
      | namedTypes.ImportNamespaceSpecifier
      | namedTypes.ImportDefaultSpecifier
    )[];
    source: Literal;
    importKind: "value" | "type";
    type: "ImportDeclaration";
  }
  export interface ExportNamedDeclaration extends BaseNode {
    declaration: namedTypes.Declaration | null;
    specifiers: namedTypes.ExportSpecifier[];
    source?: namedTypes.Literal | null;
    type: "ExportNamedDeclaration";
  }
  export interface ExportSpecifier extends BaseNode {
    local?: namedTypes.Identifier | null;
    id?: namedTypes.Identifier | null;
    name?: namedTypes.Identifier | null;
    exported: Identifier;
    type: "ExportSpecifier";
  }
  export interface ExportDefaultDeclaration extends BaseNode {
    declaration: namedTypes.Declaration | namedTypes.Expression;
    type: "ExportDefaultDeclaration";
  }
  export interface ExportAllDeclaration extends BaseNode {
    source: Literal;
    type: "ExportAllDeclaration";
  }
  export interface TaggedTemplateExpression extends BaseNode {
    tag: Expression;
    quasi: TemplateLiteral;
    type: "TaggedTemplateExpression";
  }
  export interface TemplateLiteral extends BaseNode {
    quasis: namedTypes.TemplateElement[];
    expressions: namedTypes.Expression[];
    type: "TemplateLiteral";
  }
  export interface TemplateElement extends BaseNode {
    value: { cooked: string; raw: string };
    tail: boolean;
    type: "TemplateElement";
  }
  export interface MetaProperty extends BaseNode {
    meta: Identifier;
    property: Identifier;
    type: "MetaProperty";
  }
  export interface ExportBatchSpecifier extends BaseNode {
    type: "ExportBatchSpecifier";
  }
  export interface ExportDeclaration extends BaseNode {
    default: boolean;
    declaration: namedTypes.Declaration | namedTypes.Expression | null;
    specifiers: (
      | namedTypes.ExportSpecifier
      | namedTypes.ExportBatchSpecifier
    )[];
    source?: namedTypes.Literal | null;
    type: "ExportDeclaration";
  }
  export interface Block extends BaseComment {}
  export interface Line extends BaseComment {}
  export interface Noop extends BaseNode {
    type: "Noop";
  }
  export interface DoExpression extends BaseNode {
    body: namedTypes.Statement[];
    type: "DoExpression";
  }
  export interface BindExpression extends BaseNode {
    object: namedTypes.Expression | null;
    callee: Expression;
    type: "BindExpression";
  }
  export interface ParenthesizedExpression extends BaseNode {
    expression: Expression;
    type: "ParenthesizedExpression";
  }
  export interface ExportNamespaceSpecifier extends BaseNode {
    exported: Identifier;
    type: "ExportNamespaceSpecifier";
  }
  export interface ExportDefaultSpecifier extends BaseNode {
    exported: Identifier;
    type: "ExportDefaultSpecifier";
  }
  export interface CommentBlock extends BaseComment {
    type: string;
  }
  export interface CommentLine extends BaseComment {
    type: string;
  }
  export interface Directive extends BaseNode {
    value: DirectiveLiteral;
    type: "Directive";
  }
  export interface DirectiveLiteral extends BaseNode {
    value: string;
    type: "DirectiveLiteral";
  }
  export interface InterpreterDirective extends BaseNode {
    value: string;
    type: "InterpreterDirective";
  }
  export interface StringLiteral extends BaseNode {
    value: string;
    raw?: string;
    extra: { rawValue: string; raw: string };
    type: "StringLiteral";
  }
  export interface NumericLiteral extends BaseNode {
    value: number;
    raw?: string;
    extra: { rawValue: number; raw: string };
    type: "NumericLiteral";
  }
  export interface BigIntLiteral extends BaseNode {
    value: string | number;
    raw: string;
    extra: { rawValue: string; raw: string };
    type: "BigIntLiteral";
  }
  export interface NullLiteral extends BaseNode {
    value: null;
    raw: string;
    extra: { rawValue: null; raw: string };
    type: "NullLiteral";
  }
  export interface BooleanLiteral extends BaseNode {
    value: boolean;
    raw: string;
    extra: { rawValue: boolean; raw: string };
    type: "BooleanLiteral";
  }
  export interface RegExpLiteral extends BaseNode {
    pattern: string;
    flags: string;
    value: RegExp;
    raw: string;
    extra: { rawValue: RegExp; raw: string };
    type: "RegExpLiteral";
  }
  export interface ObjectMethod
    extends Omit<BaseFunction, "params" | "body" | "generator" | "async"> {
    kind: "method" | "get" | "set";
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    params: namedTypes.PatternLike[];
    body: BlockStatement;
    computed?: boolean;
    generator?: boolean;
    async?: boolean;
    accessibility?: namedTypes.Literal | null;
    decorators?: namedTypes.Decorator[] | null;
    returnType?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
    type: "ObjectMethod";
  }
  export interface ClassMethod extends Omit<BaseFunction, "body"> {
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    kind: "get" | "set" | "method" | "constructor";
    body: BlockStatement;
    computed?: boolean;
    static?: boolean | null;
    abstract?: boolean | null;
    access?: "public" | "private" | "protected" | null;
    accessibility?: "public" | "private" | "protected" | null;
    decorators?: namedTypes.Decorator[] | null;
    optional?: boolean | null;
    returnType?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
    type: "ClassMethod";
  }
  export interface ClassPrivateMethod extends Omit<BaseFunction, "body"> {
    key: PrivateName;
    kind: "get" | "set" | "method" | "constructor";
    body: BlockStatement;
    computed?: boolean;
    static?: boolean | null;
    abstract?: boolean | null;
    access?: "public" | "private" | "protected" | null;
    accessibility?: "public" | "private" | "protected" | null;
    decorators?: namedTypes.Decorator[] | null;
    optional?: boolean | null;
    returnType?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
    type: "ClassPrivateMethod";
  }
  export interface ForAwaitStatement extends BaseNode {
    left: namedTypes.VariableDeclaration | namedTypes.Expression;
    right: Expression;
    body: Statement;
    type: "ForAwaitStatement";
  }
  export interface Import extends BaseNode {
    type: "Import";
  }
  export interface TSTypeAnnotation extends BaseNode {
    typeAnnotation: namedTypes.TSType | namedTypes.TSTypeAnnotation;
    type: "TSTypeAnnotation";
  }
  export interface TSTypeParameterDeclaration extends BaseNode {
    params: namedTypes.TSTypeParameter[];
    type: "TSTypeParameterDeclaration";
  }
  export interface TSTypeParameterInstantiation extends BaseNode {
    params: namedTypes.TSType[];
    type: "TSTypeParameterInstantiation";
  }
  export interface TSHasOptionalTypeParameterInstantiation extends BaseNode {
    typeParameters?: namedTypes.TSTypeParameterInstantiation | null;
  }
  export interface TSExpressionWithTypeArguments
    extends TSHasOptionalTypeParameterInstantiation {
    expression: namedTypes.Identifier | namedTypes.TSQualifiedName;
    type: "TSExpressionWithTypeArguments";
  }
  export interface TSQualifiedName extends BaseNode {
    left: namedTypes.Identifier | namedTypes.TSQualifiedName;
    right: namedTypes.Identifier | namedTypes.TSQualifiedName;
    type: "TSQualifiedName";
  }
  export interface TSTypeReference
    extends TSHasOptionalTypeParameterInstantiation {
    typeName: namedTypes.Identifier | namedTypes.TSQualifiedName;
    type: "TSTypeReference";
  }
  export interface TSHasOptionalTypeParameters extends BaseNode {
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null | undefined;
  }
  export interface TSHasOptionalTypeAnnotation extends BaseNode {
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
  }
  export interface TSAsExpression extends BaseNode {
    expression: Expression;
    typeAnnotation: TSType;
    extra?: { parenthesized: boolean } | null;
    type: "TSAsExpression";
  }
  export interface TSNonNullExpression extends BaseNode {
    expression: Expression;
    type: "TSNonNullExpression";
  }
  export interface TSAnyKeyword extends BaseNode {
    type: "TSAnyKeyword";
  }
  export interface TSBigIntKeyword extends BaseNode {
    type: "TSBigIntKeyword";
  }
  export interface TSBooleanKeyword extends BaseNode {
    type: "TSBooleanKeyword";
  }
  export interface TSNeverKeyword extends BaseNode {
    type: "TSNeverKeyword";
  }
  export interface TSNullKeyword extends BaseNode {
    type: "TSNullKeyword";
  }
  export interface TSNumberKeyword extends BaseNode {
    type: "TSNumberKeyword";
  }
  export interface TSObjectKeyword extends BaseNode {
    type: "TSObjectKeyword";
  }
  export interface TSStringKeyword extends BaseNode {
    type: "TSStringKeyword";
  }
  export interface TSSymbolKeyword extends BaseNode {
    type: "TSSymbolKeyword";
  }
  export interface TSUndefinedKeyword extends BaseNode {
    type: "TSUndefinedKeyword";
  }
  export interface TSUnknownKeyword extends BaseNode {
    type: "TSUnknownKeyword";
  }
  export interface TSVoidKeyword extends BaseNode {
    type: "TSVoidKeyword";
  }
  export interface TSThisType extends BaseNode {
    type: "TSThisType";
  }
  export interface TSArrayType extends BaseNode {
    elementType: TSType;
    type: "TSArrayType";
  }
  export interface TSLiteralType extends BaseNode {
    literal:
      | namedTypes.NumericLiteral
      | namedTypes.StringLiteral
      | namedTypes.BooleanLiteral
      | namedTypes.TemplateLiteral
      | namedTypes.UnaryExpression;
    type: "TSLiteralType";
  }
  export interface TSUnionType extends BaseNode {
    types: namedTypes.TSType[];
    type: "TSUnionType";
  }
  export interface TSIntersectionType extends BaseNode {
    types: namedTypes.TSType[];
    type: "TSIntersectionType";
  }
  export interface TSConditionalType extends BaseNode {
    checkType: TSType;
    extendsType: TSType;
    trueType: TSType;
    falseType: TSType;
    type: "TSConditionalType";
  }
  export interface TSInferType extends BaseNode {
    typeParameter: TSTypeParameter;
    type: "TSInferType";
  }
  export interface TSTypeParameter extends BaseNode {
    name: string;
    constraint?: namedTypes.TSType | undefined;
    default?: namedTypes.TSType | undefined;
    type: "TSTypeParameter";
  }
  export interface TSParenthesizedType extends BaseNode {
    typeAnnotation: TSType;
    type: "TSParenthesizedType";
  }
  export interface TSFunctionType
    extends TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    type: "TSFunctionType";
  }
  export interface TSConstructorType
    extends TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    type: "TSConstructorType";
  }
  export interface TSDeclareFunction extends TSHasOptionalTypeParameters {
    declare?: boolean;
    async?: boolean;
    generator?: boolean;
    id?: namedTypes.Identifier | null;
    params: namedTypes.PatternLike[];
    returnType?: namedTypes.TSTypeAnnotation | namedTypes.Noop | null;
    type: "TSDeclareFunction";
  }
  export interface TSDeclareMethod extends TSHasOptionalTypeParameters {
    async?: boolean;
    generator?: boolean;
    params: namedTypes.PatternLike[];
    abstract?: boolean;
    accessibility?: "public" | "private" | "protected" | undefined;
    static?: boolean;
    computed?: boolean;
    optional?: boolean;
    key:
      | namedTypes.Identifier
      | namedTypes.StringLiteral
      | namedTypes.NumericLiteral
      | namedTypes.Expression;
    kind: "get" | "set" | "method" | "constructor";
    access?: "public" | "private" | "protected" | undefined;
    decorators?: namedTypes.Decorator[] | null;
    returnType?: namedTypes.TSTypeAnnotation | namedTypes.Noop | null;
    type: "TSDeclareMethod";
  }
  export interface TSMappedType extends BaseNode {
    readonly?: boolean | "+" | "-";
    typeParameter: TSTypeParameter;
    optional?: boolean | "+" | "-";
    typeAnnotation?: namedTypes.TSType | null;
    type: "TSMappedType";
  }
  export interface TSTupleType extends BaseNode {
    elementTypes: (namedTypes.TSType | namedTypes.TSNamedTupleMember)[];
    type: "TSTupleType";
  }
  export interface TSNamedTupleMember extends BaseNode {
    label: Identifier;
    optional?: boolean;
    elementType: TSType;
    type: "TSNamedTupleMember";
  }
  export interface TSRestType extends BaseNode {
    typeAnnotation: TSType;
    type: "TSRestType";
  }
  export interface TSOptionalType extends BaseNode {
    typeAnnotation: TSType;
    type: "TSOptionalType";
  }
  export interface TSIndexedAccessType extends BaseNode {
    objectType: TSType;
    indexType: TSType;
    type: "TSIndexedAccessType";
  }
  export interface TSTypeOperator extends BaseNode {
    operator: string;
    typeAnnotation: TSType;
    type: "TSTypeOperator";
  }
  export interface TSIndexSignature extends TSHasOptionalTypeAnnotation {
    parameters: namedTypes.Identifier[];
    readonly?: boolean;
    type: "TSIndexSignature";
  }
  export interface TSPropertySignature extends TSHasOptionalTypeAnnotation {
    key: Expression;
    computed?: boolean;
    readonly?: boolean;
    optional?: boolean;
    initializer?: namedTypes.Expression | null;
    type: "TSPropertySignature";
  }
  export interface TSMethodSignature
    extends TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    key: Expression;
    computed?: boolean;
    optional?: boolean;
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    type: "TSMethodSignature";
  }
  export interface TSTypePredicate extends BaseNode {
    parameterName: namedTypes.Identifier | namedTypes.TSThisType;
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
    asserts?: boolean;
    type: "TSTypePredicate";
  }
  export interface TSCallSignatureDeclaration
    extends TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    type: "TSCallSignatureDeclaration";
  }
  export interface TSConstructSignatureDeclaration
    extends TSHasOptionalTypeParameters,
      TSHasOptionalTypeAnnotation {
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    type: "TSConstructSignatureDeclaration";
  }
  export interface TSEnumMember extends BaseNode {
    id: namedTypes.Identifier | namedTypes.StringLiteral;
    initializer?: namedTypes.Expression | null;
    type: "TSEnumMember";
  }
  export interface TSTypeQuery extends BaseNode {
    exprName:
      | (namedTypes.Identifier | namedTypes.TSQualifiedName)
      | namedTypes.TSImportType;
    type: "TSTypeQuery";
  }
  export interface TSImportType
    extends TSHasOptionalTypeParameterInstantiation {
    argument: StringLiteral;
    qualifier?:
      | (namedTypes.Identifier | namedTypes.TSQualifiedName)
      | undefined;
    type: "TSImportType";
  }
  export interface TSTypeLiteral extends BaseNode {
    members: (
      | namedTypes.TSCallSignatureDeclaration
      | namedTypes.TSConstructSignatureDeclaration
      | namedTypes.TSIndexSignature
      | namedTypes.TSMethodSignature
      | namedTypes.TSPropertySignature
    )[];
    type: "TSTypeLiteral";
  }
  export interface TSTypeAssertion extends BaseNode {
    typeAnnotation: TSType;
    expression: Expression;
    extra?: { parenthesized: boolean } | null;
    type: "TSTypeAssertion";
  }
  export interface TSEnumDeclaration extends BaseNode {
    id: Identifier;
    const?: boolean;
    declare?: boolean;
    members: namedTypes.TSEnumMember[];
    initializer?: namedTypes.Expression | null;
    type: "TSEnumDeclaration";
  }
  export interface TSTypeAliasDeclaration extends TSHasOptionalTypeParameters {
    id: Identifier;
    declare?: boolean;
    typeAnnotation: TSType;
    type: "TSTypeAliasDeclaration";
  }
  export interface TSModuleBlock extends BaseNode {
    body: namedTypes.Statement[];
    type: "TSModuleBlock";
  }
  export interface TSModuleDeclaration extends BaseNode {
    id:
      | namedTypes.StringLiteral
      | (namedTypes.Identifier | namedTypes.TSQualifiedName);
    declare?: boolean;
    global?: boolean;
    body?: namedTypes.TSModuleBlock | namedTypes.TSModuleDeclaration | null;
    type: "TSModuleDeclaration";
  }
  export interface TSImportEqualsDeclaration extends BaseNode {
    id: Identifier;
    isExport?: boolean;
    moduleReference:
      | (namedTypes.Identifier | namedTypes.TSQualifiedName)
      | namedTypes.TSExternalModuleReference;
    type: "TSImportEqualsDeclaration";
  }
  export interface TSExternalModuleReference extends BaseNode {
    expression: StringLiteral;
    type: "TSExternalModuleReference";
  }
  export interface TSExportAssignment extends BaseNode {
    expression: Expression;
    type: "TSExportAssignment";
  }
  export interface TSNamespaceExportDeclaration extends BaseNode {
    id: Identifier;
    type: "TSNamespaceExportDeclaration";
  }
  export interface TSInterfaceBody extends BaseNode {
    body: (
      | namedTypes.TSCallSignatureDeclaration
      | namedTypes.TSConstructSignatureDeclaration
      | namedTypes.TSIndexSignature
      | namedTypes.TSMethodSignature
      | namedTypes.TSPropertySignature
    )[];
    type: "TSInterfaceBody";
  }
  export interface TSInterfaceDeclaration extends TSHasOptionalTypeParameters {
    id: namedTypes.Identifier | namedTypes.TSQualifiedName;
    declare?: boolean;
    extends?: namedTypes.TSExpressionWithTypeArguments[] | null;
    body: TSInterfaceBody;
    type: "TSInterfaceDeclaration";
  }
  export interface TSParameterProperty extends BaseNode {
    accessibility?: "public" | "private" | "protected" | undefined;
    readonly?: boolean;
    parameter: namedTypes.Identifier | namedTypes.AssignmentPattern;
    type: "TSParameterProperty";
  }
  export type ASTNode =
    | AwaitExpression
    | Decorator
    | Property
    | MethodDefinition
    | PrivateName
    | Identifier
    | ClassPrivateProperty
    | File
    | Program
    | BlockStatement
    | EmptyStatement
    | ExpressionStatement
    | IfStatement
    | LabeledStatement
    | BreakStatement
    | ContinueStatement
    | WithStatement
    | SwitchStatement
    | SwitchCase
    | ReturnStatement
    | ThrowStatement
    | TryStatement
    | CatchClause
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | VariableDeclaration
    | ForInStatement
    | DebuggerStatement
    | FunctionDeclaration
    | FunctionExpression
    | VariableDeclarator
    | ThisExpression
    | ArrayExpression
    | ObjectExpression
    | SequenceExpression
    | UnaryExpression
    | BinaryExpression
    | AssignmentExpression
    | UpdateExpression
    | LogicalExpression
    | ConditionalExpression
    | NewExpression
    | CallExpression
    | MemberExpression
    | Placeholder
    | RestElement
    | ArrowFunctionExpression
    | ForOfStatement
    | YieldExpression
    | GeneratorExpression
    | ComprehensionBlock
    | ComprehensionExpression
    | ObjectProperty
    | ArrayPattern
    | ObjectPattern
    | SpreadElement
    | AssignmentPattern
    | ClassPropertyDefinition
    | ClassProperty
    | ClassBody
    | ClassDeclaration
    | ClassExpression
    | Super
    | ImportSpecifier
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportDeclaration
    | ExportNamedDeclaration
    | ExportSpecifier
    | ExportDefaultDeclaration
    | ExportAllDeclaration
    | TaggedTemplateExpression
    | TemplateLiteral
    | TemplateElement
    | MetaProperty
    | ExportBatchSpecifier
    | ExportDeclaration
    | Block
    | Line
    | Noop
    | DoExpression
    | BindExpression
    | ParenthesizedExpression
    | ExportNamespaceSpecifier
    | ExportDefaultSpecifier
    | CommentBlock
    | CommentLine
    | Directive
    | DirectiveLiteral
    | InterpreterDirective
    | StringLiteral
    | NumericLiteral
    | BigIntLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | ObjectMethod
    | ClassMethod
    | ClassPrivateMethod
    | ForAwaitStatement
    | Import
    | TSTypeAnnotation
    | TSTypeParameterDeclaration
    | TSTypeParameterInstantiation
    | TSExpressionWithTypeArguments
    | TSQualifiedName
    | TSTypeReference
    | TSAsExpression
    | TSNonNullExpression
    | TSAnyKeyword
    | TSBigIntKeyword
    | TSBooleanKeyword
    | TSNeverKeyword
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSUndefinedKeyword
    | TSUnknownKeyword
    | TSVoidKeyword
    | TSThisType
    | TSArrayType
    | TSLiteralType
    | TSUnionType
    | TSIntersectionType
    | TSConditionalType
    | TSInferType
    | TSTypeParameter
    | TSParenthesizedType
    | TSFunctionType
    | TSConstructorType
    | TSDeclareFunction
    | TSDeclareMethod
    | TSMappedType
    | TSTupleType
    | TSNamedTupleMember
    | TSRestType
    | TSOptionalType
    | TSIndexedAccessType
    | TSTypeOperator
    | TSIndexSignature
    | TSPropertySignature
    | TSMethodSignature
    | TSTypePredicate
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSEnumMember
    | TSTypeQuery
    | TSImportType
    | TSTypeLiteral
    | TSTypeAssertion
    | TSEnumDeclaration
    | TSTypeAliasDeclaration
    | TSModuleBlock
    | TSModuleDeclaration
    | TSImportEqualsDeclaration
    | TSExternalModuleReference
    | TSExportAssignment
    | TSNamespaceExportDeclaration
    | TSInterfaceBody
    | TSInterfaceDeclaration
    | TSParameterProperty;
  export let Node: Type<Node>;
  export let BaseNode: Type<BaseNode>;
  export let Placeholderable: Type<Placeholderable>;
  export let Expression: Type<Expression>;
  export let AwaitExpression: Type<AwaitExpression>;
  export let Decorator: Type<Decorator>;
  export let Property: Type<Property>;
  export let Statement: Type<Statement>;
  export let Declaration: Type<Declaration>;
  export let MethodDefinition: Type<MethodDefinition>;
  export let PrivateName: Type<PrivateName>;
  export let PatternLike: Type<PatternLike>;
  export let LVal: Type<LVal>;
  export let Identifier: Type<Identifier>;
  export let ClassPrivateProperty: Type<ClassPrivateProperty>;
  export let Comment: Type<Comment>;
  export let SourceLocation: Type<SourceLocation>;
  export let Position: Type<Position>;
  export let File: Type<File>;
  export let Scopable: Type<Scopable>;
  export let BlockParent: Type<BlockParent>;
  export let Program: Type<Program>;
  export let Function: Type<Function>;
  export let FunctionParent: Type<FunctionParent>;
  export let BaseFunction: Type<BaseFunction>;
  export let BlockStatement: Type<BlockStatement>;
  export let EmptyStatement: Type<EmptyStatement>;
  export let ExpressionStatement: Type<ExpressionStatement>;
  export let Conditional: Type<Conditional>;
  export let IfStatement: Type<IfStatement>;
  export let LabeledStatement: Type<LabeledStatement>;
  export let CompletionStatement: Type<CompletionStatement>;
  export let BreakStatement: Type<BreakStatement>;
  export let ContinueStatement: Type<ContinueStatement>;
  export let WithStatement: Type<WithStatement>;
  export let SwitchStatement: Type<SwitchStatement>;
  export let SwitchCase: Type<SwitchCase>;
  export let ReturnStatement: Type<ReturnStatement>;
  export let ThrowStatement: Type<ThrowStatement>;
  export let TryStatement: Type<TryStatement>;
  export let CatchClause: Type<CatchClause>;
  export let Loop: Type<Loop>;
  export let While: Type<While>;
  export let For: Type<For>;
  export let ForX: Type<ForX>;
  export let WhileStatement: Type<WhileStatement>;
  export let DoWhileStatement: Type<DoWhileStatement>;
  export let ForStatement: Type<ForStatement>;
  export let VariableDeclaration: Type<VariableDeclaration>;
  export let ForInStatement: Type<ForInStatement>;
  export let DebuggerStatement: Type<DebuggerStatement>;
  export let Pureish: Type<Pureish>;
  export let FunctionDeclaration: Type<FunctionDeclaration>;
  export let FunctionExpression: Type<FunctionExpression>;
  export let VariableDeclarator: Type<VariableDeclarator>;
  export let ThisExpression: Type<ThisExpression>;
  export let ArrayExpression: Type<ArrayExpression>;
  export let ObjectExpression: Type<ObjectExpression>;
  export let Literal: Type<Literal>;
  export let SequenceExpression: Type<SequenceExpression>;
  export let UnaryExpression: Type<UnaryExpression>;
  export let Binary: Type<Binary>;
  export let BinaryExpression: Type<BinaryExpression>;
  export let AssignmentExpression: Type<AssignmentExpression>;
  export let UpdateExpression: Type<UpdateExpression>;
  export let LogicalExpression: Type<LogicalExpression>;
  export let ConditionalExpression: Type<ConditionalExpression>;
  export let NewExpression: Type<NewExpression>;
  export let CallExpression: Type<CallExpression>;
  export let MemberExpression: Type<MemberExpression>;
  export let Pattern: Type<Pattern>;
  export let BaseComment: Type<BaseComment>;
  export let Placeholder: Type<Placeholder>;
  export let RestElement: Type<RestElement>;
  export let ArrowFunctionExpression: Type<ArrowFunctionExpression>;
  export let ForOfStatement: Type<ForOfStatement>;
  export let YieldExpression: Type<YieldExpression>;
  export let GeneratorExpression: Type<GeneratorExpression>;
  export let ComprehensionBlock: Type<ComprehensionBlock>;
  export let ComprehensionExpression: Type<ComprehensionExpression>;
  export let ObjectProperty: Type<ObjectProperty>;
  export let ArrayPattern: Type<ArrayPattern>;
  export let ObjectPattern: Type<ObjectPattern>;
  export let SpreadElement: Type<SpreadElement>;
  export let AssignmentPattern: Type<AssignmentPattern>;
  export let ClassPropertyDefinition: Type<ClassPropertyDefinition>;
  export let ClassProperty: Type<ClassProperty>;
  export let ClassBody: Type<ClassBody>;
  export let Class: Type<Class>;
  export let ClassDeclaration: Type<ClassDeclaration>;
  export let ClassExpression: Type<ClassExpression>;
  export let Super: Type<Super>;
  export let Specifier: Type<Specifier>;
  export let ModuleSpecifier: Type<ModuleSpecifier>;
  export let ImportSpecifier: Type<ImportSpecifier>;
  export let ImportDefaultSpecifier: Type<ImportDefaultSpecifier>;
  export let ImportNamespaceSpecifier: Type<ImportNamespaceSpecifier>;
  export let ImportDeclaration: Type<ImportDeclaration>;
  export let ExportNamedDeclaration: Type<ExportNamedDeclaration>;
  export let ExportSpecifier: Type<ExportSpecifier>;
  export let ExportDefaultDeclaration: Type<ExportDefaultDeclaration>;
  export let ExportAllDeclaration: Type<ExportAllDeclaration>;
  export let TaggedTemplateExpression: Type<TaggedTemplateExpression>;
  export let TemplateLiteral: Type<TemplateLiteral>;
  export let TemplateElement: Type<TemplateElement>;
  export let MetaProperty: Type<MetaProperty>;
  export let ExportBatchSpecifier: Type<ExportBatchSpecifier>;
  export let ExportDeclaration: Type<ExportDeclaration>;
  export let Block: Type<Block>;
  export let Line: Type<Line>;
  export let Noop: Type<Noop>;
  export let DoExpression: Type<DoExpression>;
  export let BindExpression: Type<BindExpression>;
  export let ParenthesizedExpression: Type<ParenthesizedExpression>;
  export let ExportNamespaceSpecifier: Type<ExportNamespaceSpecifier>;
  export let ExportDefaultSpecifier: Type<ExportDefaultSpecifier>;
  export let CommentBlock: Type<CommentBlock>;
  export let CommentLine: Type<CommentLine>;
  export let Directive: Type<Directive>;
  export let DirectiveLiteral: Type<DirectiveLiteral>;
  export let InterpreterDirective: Type<InterpreterDirective>;
  export let StringLiteral: Type<StringLiteral>;
  export let NumericLiteral: Type<NumericLiteral>;
  export let BigIntLiteral: Type<BigIntLiteral>;
  export let NullLiteral: Type<NullLiteral>;
  export let BooleanLiteral: Type<BooleanLiteral>;
  export let RegExpLiteral: Type<RegExpLiteral>;
  export let ObjectMethod: Type<ObjectMethod>;
  export let ClassMethod: Type<ClassMethod>;
  export let ClassPrivateMethod: Type<ClassPrivateMethod>;
  export let ForAwaitStatement: Type<ForAwaitStatement>;
  export let Import: Type<Import>;
  export let TSTypeAnnotation: Type<TSTypeAnnotation>;
  export let TSTypeParameterDeclaration: Type<TSTypeParameterDeclaration>;
  export let TSTypeParameterInstantiation: Type<TSTypeParameterInstantiation>;
  export let TSHasOptionalTypeParameterInstantiation: Type<TSHasOptionalTypeParameterInstantiation>;
  export let TSType: Type<TSType>;
  export let TSExpressionWithTypeArguments: Type<TSExpressionWithTypeArguments>;
  export let TSQualifiedName: Type<TSQualifiedName>;
  export let TSTypeReference: Type<TSTypeReference>;
  export let TSHasOptionalTypeParameters: Type<TSHasOptionalTypeParameters>;
  export let TSHasOptionalTypeAnnotation: Type<TSHasOptionalTypeAnnotation>;
  export let TSAsExpression: Type<TSAsExpression>;
  export let TSNonNullExpression: Type<TSNonNullExpression>;
  export let TSAnyKeyword: Type<TSAnyKeyword>;
  export let TSBigIntKeyword: Type<TSBigIntKeyword>;
  export let TSBooleanKeyword: Type<TSBooleanKeyword>;
  export let TSNeverKeyword: Type<TSNeverKeyword>;
  export let TSNullKeyword: Type<TSNullKeyword>;
  export let TSNumberKeyword: Type<TSNumberKeyword>;
  export let TSObjectKeyword: Type<TSObjectKeyword>;
  export let TSStringKeyword: Type<TSStringKeyword>;
  export let TSSymbolKeyword: Type<TSSymbolKeyword>;
  export let TSUndefinedKeyword: Type<TSUndefinedKeyword>;
  export let TSUnknownKeyword: Type<TSUnknownKeyword>;
  export let TSVoidKeyword: Type<TSVoidKeyword>;
  export let TSThisType: Type<TSThisType>;
  export let TSArrayType: Type<TSArrayType>;
  export let TSLiteralType: Type<TSLiteralType>;
  export let TSUnionType: Type<TSUnionType>;
  export let TSIntersectionType: Type<TSIntersectionType>;
  export let TSConditionalType: Type<TSConditionalType>;
  export let TSInferType: Type<TSInferType>;
  export let TSTypeParameter: Type<TSTypeParameter>;
  export let TSParenthesizedType: Type<TSParenthesizedType>;
  export let TSFunctionType: Type<TSFunctionType>;
  export let TSConstructorType: Type<TSConstructorType>;
  export let TSDeclareFunction: Type<TSDeclareFunction>;
  export let TSDeclareMethod: Type<TSDeclareMethod>;
  export let TSMappedType: Type<TSMappedType>;
  export let TSTupleType: Type<TSTupleType>;
  export let TSNamedTupleMember: Type<TSNamedTupleMember>;
  export let TSRestType: Type<TSRestType>;
  export let TSOptionalType: Type<TSOptionalType>;
  export let TSIndexedAccessType: Type<TSIndexedAccessType>;
  export let TSTypeOperator: Type<TSTypeOperator>;
  export let TSTypeElement: Type<TSTypeElement>;
  export let TSIndexSignature: Type<TSIndexSignature>;
  export let TSPropertySignature: Type<TSPropertySignature>;
  export let TSMethodSignature: Type<TSMethodSignature>;
  export let TSTypePredicate: Type<TSTypePredicate>;
  export let TSCallSignatureDeclaration: Type<TSCallSignatureDeclaration>;
  export let TSConstructSignatureDeclaration: Type<TSConstructSignatureDeclaration>;
  export let TSEnumMember: Type<TSEnumMember>;
  export let TSTypeQuery: Type<TSTypeQuery>;
  export let TSImportType: Type<TSImportType>;
  export let TSTypeLiteral: Type<TSTypeLiteral>;
  export let TSTypeAssertion: Type<TSTypeAssertion>;
  export let TSEnumDeclaration: Type<TSEnumDeclaration>;
  export let TSTypeAliasDeclaration: Type<TSTypeAliasDeclaration>;
  export let TSModuleBlock: Type<TSModuleBlock>;
  export let TSModuleDeclaration: Type<TSModuleDeclaration>;
  export let TSImportEqualsDeclaration: Type<TSImportEqualsDeclaration>;
  export let TSExternalModuleReference: Type<TSExternalModuleReference>;
  export let TSExportAssignment: Type<TSExportAssignment>;
  export let TSNamespaceExportDeclaration: Type<TSNamespaceExportDeclaration>;
  export let TSInterfaceBody: Type<TSInterfaceBody>;
  export let TSInterfaceDeclaration: Type<TSInterfaceDeclaration>;
  export let TSParameterProperty: Type<TSParameterProperty>;
  export function assertNode(x: unknown): asserts x is Node {
    Node.assert(x);
  }
  export function assertBaseNode(x: unknown): asserts x is BaseNode {
    BaseNode.assert(x);
  }
  export function assertPlaceholderable(
    x: unknown
  ): asserts x is Placeholderable {
    Placeholderable.assert(x);
  }
  export function assertExpression(x: unknown): asserts x is Expression {
    Expression.assert(x);
  }
  export function assertAwaitExpression(
    x: unknown
  ): asserts x is AwaitExpression {
    AwaitExpression.assert(x);
  }
  export function assertDecorator(x: unknown): asserts x is Decorator {
    Decorator.assert(x);
  }
  export function assertProperty(x: unknown): asserts x is Property {
    Property.assert(x);
  }
  export function assertStatement(x: unknown): asserts x is Statement {
    Statement.assert(x);
  }
  export function assertDeclaration(x: unknown): asserts x is Declaration {
    Declaration.assert(x);
  }
  export function assertMethodDefinition(
    x: unknown
  ): asserts x is MethodDefinition {
    MethodDefinition.assert(x);
  }
  export function assertPrivateName(x: unknown): asserts x is PrivateName {
    PrivateName.assert(x);
  }
  export function assertPatternLike(x: unknown): asserts x is PatternLike {
    PatternLike.assert(x);
  }
  export function assertLVal(x: unknown): asserts x is LVal {
    LVal.assert(x);
  }
  export function assertIdentifier(x: unknown): asserts x is Identifier {
    Identifier.assert(x);
  }
  export function assertClassPrivateProperty(
    x: unknown
  ): asserts x is ClassPrivateProperty {
    ClassPrivateProperty.assert(x);
  }
  export function assertComment(x: unknown): asserts x is Comment {
    Comment.assert(x);
  }
  export function assertSourceLocation(
    x: unknown
  ): asserts x is SourceLocation {
    SourceLocation.assert(x);
  }
  export function assertPosition(x: unknown): asserts x is Position {
    Position.assert(x);
  }
  export function assertFile(x: unknown): asserts x is File {
    File.assert(x);
  }
  export function assertScopable(x: unknown): asserts x is Scopable {
    Scopable.assert(x);
  }
  export function assertBlockParent(x: unknown): asserts x is BlockParent {
    BlockParent.assert(x);
  }
  export function assertProgram(x: unknown): asserts x is Program {
    Program.assert(x);
  }
  export function assertFunction(x: unknown): asserts x is Function {
    Function.assert(x);
  }
  export function assertFunctionParent(
    x: unknown
  ): asserts x is FunctionParent {
    FunctionParent.assert(x);
  }
  export function assertBaseFunction(x: unknown): asserts x is BaseFunction {
    BaseFunction.assert(x);
  }
  export function assertBlockStatement(
    x: unknown
  ): asserts x is BlockStatement {
    BlockStatement.assert(x);
  }
  export function assertEmptyStatement(
    x: unknown
  ): asserts x is EmptyStatement {
    EmptyStatement.assert(x);
  }
  export function assertExpressionStatement(
    x: unknown
  ): asserts x is ExpressionStatement {
    ExpressionStatement.assert(x);
  }
  export function assertConditional(x: unknown): asserts x is Conditional {
    Conditional.assert(x);
  }
  export function assertIfStatement(x: unknown): asserts x is IfStatement {
    IfStatement.assert(x);
  }
  export function assertLabeledStatement(
    x: unknown
  ): asserts x is LabeledStatement {
    LabeledStatement.assert(x);
  }
  export function assertCompletionStatement(
    x: unknown
  ): asserts x is CompletionStatement {
    CompletionStatement.assert(x);
  }
  export function assertBreakStatement(
    x: unknown
  ): asserts x is BreakStatement {
    BreakStatement.assert(x);
  }
  export function assertContinueStatement(
    x: unknown
  ): asserts x is ContinueStatement {
    ContinueStatement.assert(x);
  }
  export function assertWithStatement(x: unknown): asserts x is WithStatement {
    WithStatement.assert(x);
  }
  export function assertSwitchStatement(
    x: unknown
  ): asserts x is SwitchStatement {
    SwitchStatement.assert(x);
  }
  export function assertSwitchCase(x: unknown): asserts x is SwitchCase {
    SwitchCase.assert(x);
  }
  export function assertReturnStatement(
    x: unknown
  ): asserts x is ReturnStatement {
    ReturnStatement.assert(x);
  }
  export function assertThrowStatement(
    x: unknown
  ): asserts x is ThrowStatement {
    ThrowStatement.assert(x);
  }
  export function assertTryStatement(x: unknown): asserts x is TryStatement {
    TryStatement.assert(x);
  }
  export function assertCatchClause(x: unknown): asserts x is CatchClause {
    CatchClause.assert(x);
  }
  export function assertLoop(x: unknown): asserts x is Loop {
    Loop.assert(x);
  }
  export function assertWhile(x: unknown): asserts x is While {
    While.assert(x);
  }
  export function assertFor(x: unknown): asserts x is For {
    For.assert(x);
  }
  export function assertForX(x: unknown): asserts x is ForX {
    ForX.assert(x);
  }
  export function assertWhileStatement(
    x: unknown
  ): asserts x is WhileStatement {
    WhileStatement.assert(x);
  }
  export function assertDoWhileStatement(
    x: unknown
  ): asserts x is DoWhileStatement {
    DoWhileStatement.assert(x);
  }
  export function assertForStatement(x: unknown): asserts x is ForStatement {
    ForStatement.assert(x);
  }
  export function assertVariableDeclaration(
    x: unknown
  ): asserts x is VariableDeclaration {
    VariableDeclaration.assert(x);
  }
  export function assertForInStatement(
    x: unknown
  ): asserts x is ForInStatement {
    ForInStatement.assert(x);
  }
  export function assertDebuggerStatement(
    x: unknown
  ): asserts x is DebuggerStatement {
    DebuggerStatement.assert(x);
  }
  export function assertPureish(x: unknown): asserts x is Pureish {
    Pureish.assert(x);
  }
  export function assertFunctionDeclaration(
    x: unknown
  ): asserts x is FunctionDeclaration {
    FunctionDeclaration.assert(x);
  }
  export function assertFunctionExpression(
    x: unknown
  ): asserts x is FunctionExpression {
    FunctionExpression.assert(x);
  }
  export function assertVariableDeclarator(
    x: unknown
  ): asserts x is VariableDeclarator {
    VariableDeclarator.assert(x);
  }
  export function assertThisExpression(
    x: unknown
  ): asserts x is ThisExpression {
    ThisExpression.assert(x);
  }
  export function assertArrayExpression(
    x: unknown
  ): asserts x is ArrayExpression {
    ArrayExpression.assert(x);
  }
  export function assertObjectExpression(
    x: unknown
  ): asserts x is ObjectExpression {
    ObjectExpression.assert(x);
  }
  export function assertLiteral(x: unknown): asserts x is Literal {
    Literal.assert(x);
  }
  export function assertSequenceExpression(
    x: unknown
  ): asserts x is SequenceExpression {
    SequenceExpression.assert(x);
  }
  export function assertUnaryExpression(
    x: unknown
  ): asserts x is UnaryExpression {
    UnaryExpression.assert(x);
  }
  export function assertBinary(x: unknown): asserts x is Binary {
    Binary.assert(x);
  }
  export function assertBinaryExpression(
    x: unknown
  ): asserts x is BinaryExpression {
    BinaryExpression.assert(x);
  }
  export function assertAssignmentExpression(
    x: unknown
  ): asserts x is AssignmentExpression {
    AssignmentExpression.assert(x);
  }
  export function assertUpdateExpression(
    x: unknown
  ): asserts x is UpdateExpression {
    UpdateExpression.assert(x);
  }
  export function assertLogicalExpression(
    x: unknown
  ): asserts x is LogicalExpression {
    LogicalExpression.assert(x);
  }
  export function assertConditionalExpression(
    x: unknown
  ): asserts x is ConditionalExpression {
    ConditionalExpression.assert(x);
  }
  export function assertNewExpression(x: unknown): asserts x is NewExpression {
    NewExpression.assert(x);
  }
  export function assertCallExpression(
    x: unknown
  ): asserts x is CallExpression {
    CallExpression.assert(x);
  }
  export function assertMemberExpression(
    x: unknown
  ): asserts x is MemberExpression {
    MemberExpression.assert(x);
  }
  export function assertPattern(x: unknown): asserts x is Pattern {
    Pattern.assert(x);
  }
  export function assertBaseComment(x: unknown): asserts x is BaseComment {
    BaseComment.assert(x);
  }
  export function assertPlaceholder(x: unknown): asserts x is Placeholder {
    Placeholder.assert(x);
  }
  export function assertRestElement(x: unknown): asserts x is RestElement {
    RestElement.assert(x);
  }
  export function assertArrowFunctionExpression(
    x: unknown
  ): asserts x is ArrowFunctionExpression {
    ArrowFunctionExpression.assert(x);
  }
  export function assertForOfStatement(
    x: unknown
  ): asserts x is ForOfStatement {
    ForOfStatement.assert(x);
  }
  export function assertYieldExpression(
    x: unknown
  ): asserts x is YieldExpression {
    YieldExpression.assert(x);
  }
  export function assertGeneratorExpression(
    x: unknown
  ): asserts x is GeneratorExpression {
    GeneratorExpression.assert(x);
  }
  export function assertComprehensionBlock(
    x: unknown
  ): asserts x is ComprehensionBlock {
    ComprehensionBlock.assert(x);
  }
  export function assertComprehensionExpression(
    x: unknown
  ): asserts x is ComprehensionExpression {
    ComprehensionExpression.assert(x);
  }
  export function assertObjectProperty(
    x: unknown
  ): asserts x is ObjectProperty {
    ObjectProperty.assert(x);
  }
  export function assertArrayPattern(x: unknown): asserts x is ArrayPattern {
    ArrayPattern.assert(x);
  }
  export function assertObjectPattern(x: unknown): asserts x is ObjectPattern {
    ObjectPattern.assert(x);
  }
  export function assertSpreadElement(x: unknown): asserts x is SpreadElement {
    SpreadElement.assert(x);
  }
  export function assertAssignmentPattern(
    x: unknown
  ): asserts x is AssignmentPattern {
    AssignmentPattern.assert(x);
  }
  export function assertClassPropertyDefinition(
    x: unknown
  ): asserts x is ClassPropertyDefinition {
    ClassPropertyDefinition.assert(x);
  }
  export function assertClassProperty(x: unknown): asserts x is ClassProperty {
    ClassProperty.assert(x);
  }
  export function assertClassBody(x: unknown): asserts x is ClassBody {
    ClassBody.assert(x);
  }
  export function assertClass(x: unknown): asserts x is Class {
    Class.assert(x);
  }
  export function assertClassDeclaration(
    x: unknown
  ): asserts x is ClassDeclaration {
    ClassDeclaration.assert(x);
  }
  export function assertClassExpression(
    x: unknown
  ): asserts x is ClassExpression {
    ClassExpression.assert(x);
  }
  export function assertSuper(x: unknown): asserts x is Super {
    Super.assert(x);
  }
  export function assertSpecifier(x: unknown): asserts x is Specifier {
    Specifier.assert(x);
  }
  export function assertModuleSpecifier(
    x: unknown
  ): asserts x is ModuleSpecifier {
    ModuleSpecifier.assert(x);
  }
  export function assertImportSpecifier(
    x: unknown
  ): asserts x is ImportSpecifier {
    ImportSpecifier.assert(x);
  }
  export function assertImportDefaultSpecifier(
    x: unknown
  ): asserts x is ImportDefaultSpecifier {
    ImportDefaultSpecifier.assert(x);
  }
  export function assertImportNamespaceSpecifier(
    x: unknown
  ): asserts x is ImportNamespaceSpecifier {
    ImportNamespaceSpecifier.assert(x);
  }
  export function assertImportDeclaration(
    x: unknown
  ): asserts x is ImportDeclaration {
    ImportDeclaration.assert(x);
  }
  export function assertExportNamedDeclaration(
    x: unknown
  ): asserts x is ExportNamedDeclaration {
    ExportNamedDeclaration.assert(x);
  }
  export function assertExportSpecifier(
    x: unknown
  ): asserts x is ExportSpecifier {
    ExportSpecifier.assert(x);
  }
  export function assertExportDefaultDeclaration(
    x: unknown
  ): asserts x is ExportDefaultDeclaration {
    ExportDefaultDeclaration.assert(x);
  }
  export function assertExportAllDeclaration(
    x: unknown
  ): asserts x is ExportAllDeclaration {
    ExportAllDeclaration.assert(x);
  }
  export function assertTaggedTemplateExpression(
    x: unknown
  ): asserts x is TaggedTemplateExpression {
    TaggedTemplateExpression.assert(x);
  }
  export function assertTemplateLiteral(
    x: unknown
  ): asserts x is TemplateLiteral {
    TemplateLiteral.assert(x);
  }
  export function assertTemplateElement(
    x: unknown
  ): asserts x is TemplateElement {
    TemplateElement.assert(x);
  }
  export function assertMetaProperty(x: unknown): asserts x is MetaProperty {
    MetaProperty.assert(x);
  }
  export function assertExportBatchSpecifier(
    x: unknown
  ): asserts x is ExportBatchSpecifier {
    ExportBatchSpecifier.assert(x);
  }
  export function assertExportDeclaration(
    x: unknown
  ): asserts x is ExportDeclaration {
    ExportDeclaration.assert(x);
  }
  export function assertBlock(x: unknown): asserts x is Block {
    Block.assert(x);
  }
  export function assertLine(x: unknown): asserts x is Line {
    Line.assert(x);
  }
  export function assertNoop(x: unknown): asserts x is Noop {
    Noop.assert(x);
  }
  export function assertDoExpression(x: unknown): asserts x is DoExpression {
    DoExpression.assert(x);
  }
  export function assertBindExpression(
    x: unknown
  ): asserts x is BindExpression {
    BindExpression.assert(x);
  }
  export function assertParenthesizedExpression(
    x: unknown
  ): asserts x is ParenthesizedExpression {
    ParenthesizedExpression.assert(x);
  }
  export function assertExportNamespaceSpecifier(
    x: unknown
  ): asserts x is ExportNamespaceSpecifier {
    ExportNamespaceSpecifier.assert(x);
  }
  export function assertExportDefaultSpecifier(
    x: unknown
  ): asserts x is ExportDefaultSpecifier {
    ExportDefaultSpecifier.assert(x);
  }
  export function assertCommentBlock(x: unknown): asserts x is CommentBlock {
    CommentBlock.assert(x);
  }
  export function assertCommentLine(x: unknown): asserts x is CommentLine {
    CommentLine.assert(x);
  }
  export function assertDirective(x: unknown): asserts x is Directive {
    Directive.assert(x);
  }
  export function assertDirectiveLiteral(
    x: unknown
  ): asserts x is DirectiveLiteral {
    DirectiveLiteral.assert(x);
  }
  export function assertInterpreterDirective(
    x: unknown
  ): asserts x is InterpreterDirective {
    InterpreterDirective.assert(x);
  }
  export function assertStringLiteral(x: unknown): asserts x is StringLiteral {
    StringLiteral.assert(x);
  }
  export function assertNumericLiteral(
    x: unknown
  ): asserts x is NumericLiteral {
    NumericLiteral.assert(x);
  }
  export function assertBigIntLiteral(x: unknown): asserts x is BigIntLiteral {
    BigIntLiteral.assert(x);
  }
  export function assertNullLiteral(x: unknown): asserts x is NullLiteral {
    NullLiteral.assert(x);
  }
  export function assertBooleanLiteral(
    x: unknown
  ): asserts x is BooleanLiteral {
    BooleanLiteral.assert(x);
  }
  export function assertRegExpLiteral(x: unknown): asserts x is RegExpLiteral {
    RegExpLiteral.assert(x);
  }
  export function assertObjectMethod(x: unknown): asserts x is ObjectMethod {
    ObjectMethod.assert(x);
  }
  export function assertClassMethod(x: unknown): asserts x is ClassMethod {
    ClassMethod.assert(x);
  }
  export function assertClassPrivateMethod(
    x: unknown
  ): asserts x is ClassPrivateMethod {
    ClassPrivateMethod.assert(x);
  }
  export function assertForAwaitStatement(
    x: unknown
  ): asserts x is ForAwaitStatement {
    ForAwaitStatement.assert(x);
  }
  export function assertImport(x: unknown): asserts x is Import {
    Import.assert(x);
  }
  export function assertTSTypeAnnotation(
    x: unknown
  ): asserts x is TSTypeAnnotation {
    TSTypeAnnotation.assert(x);
  }
  export function assertTSTypeParameterDeclaration(
    x: unknown
  ): asserts x is TSTypeParameterDeclaration {
    TSTypeParameterDeclaration.assert(x);
  }
  export function assertTSTypeParameterInstantiation(
    x: unknown
  ): asserts x is TSTypeParameterInstantiation {
    TSTypeParameterInstantiation.assert(x);
  }
  export function assertTSHasOptionalTypeParameterInstantiation(
    x: unknown
  ): asserts x is TSHasOptionalTypeParameterInstantiation {
    TSHasOptionalTypeParameterInstantiation.assert(x);
  }
  export function assertTSType(x: unknown): asserts x is TSType {
    TSType.assert(x);
  }
  export function assertTSExpressionWithTypeArguments(
    x: unknown
  ): asserts x is TSExpressionWithTypeArguments {
    TSExpressionWithTypeArguments.assert(x);
  }
  export function assertTSQualifiedName(
    x: unknown
  ): asserts x is TSQualifiedName {
    TSQualifiedName.assert(x);
  }
  export function assertTSTypeReference(
    x: unknown
  ): asserts x is TSTypeReference {
    TSTypeReference.assert(x);
  }
  export function assertTSHasOptionalTypeParameters(
    x: unknown
  ): asserts x is TSHasOptionalTypeParameters {
    TSHasOptionalTypeParameters.assert(x);
  }
  export function assertTSHasOptionalTypeAnnotation(
    x: unknown
  ): asserts x is TSHasOptionalTypeAnnotation {
    TSHasOptionalTypeAnnotation.assert(x);
  }
  export function assertTSAsExpression(
    x: unknown
  ): asserts x is TSAsExpression {
    TSAsExpression.assert(x);
  }
  export function assertTSNonNullExpression(
    x: unknown
  ): asserts x is TSNonNullExpression {
    TSNonNullExpression.assert(x);
  }
  export function assertTSAnyKeyword(x: unknown): asserts x is TSAnyKeyword {
    TSAnyKeyword.assert(x);
  }
  export function assertTSBigIntKeyword(
    x: unknown
  ): asserts x is TSBigIntKeyword {
    TSBigIntKeyword.assert(x);
  }
  export function assertTSBooleanKeyword(
    x: unknown
  ): asserts x is TSBooleanKeyword {
    TSBooleanKeyword.assert(x);
  }
  export function assertTSNeverKeyword(
    x: unknown
  ): asserts x is TSNeverKeyword {
    TSNeverKeyword.assert(x);
  }
  export function assertTSNullKeyword(x: unknown): asserts x is TSNullKeyword {
    TSNullKeyword.assert(x);
  }
  export function assertTSNumberKeyword(
    x: unknown
  ): asserts x is TSNumberKeyword {
    TSNumberKeyword.assert(x);
  }
  export function assertTSObjectKeyword(
    x: unknown
  ): asserts x is TSObjectKeyword {
    TSObjectKeyword.assert(x);
  }
  export function assertTSStringKeyword(
    x: unknown
  ): asserts x is TSStringKeyword {
    TSStringKeyword.assert(x);
  }
  export function assertTSSymbolKeyword(
    x: unknown
  ): asserts x is TSSymbolKeyword {
    TSSymbolKeyword.assert(x);
  }
  export function assertTSUndefinedKeyword(
    x: unknown
  ): asserts x is TSUndefinedKeyword {
    TSUndefinedKeyword.assert(x);
  }
  export function assertTSUnknownKeyword(
    x: unknown
  ): asserts x is TSUnknownKeyword {
    TSUnknownKeyword.assert(x);
  }
  export function assertTSVoidKeyword(x: unknown): asserts x is TSVoidKeyword {
    TSVoidKeyword.assert(x);
  }
  export function assertTSThisType(x: unknown): asserts x is TSThisType {
    TSThisType.assert(x);
  }
  export function assertTSArrayType(x: unknown): asserts x is TSArrayType {
    TSArrayType.assert(x);
  }
  export function assertTSLiteralType(x: unknown): asserts x is TSLiteralType {
    TSLiteralType.assert(x);
  }
  export function assertTSUnionType(x: unknown): asserts x is TSUnionType {
    TSUnionType.assert(x);
  }
  export function assertTSIntersectionType(
    x: unknown
  ): asserts x is TSIntersectionType {
    TSIntersectionType.assert(x);
  }
  export function assertTSConditionalType(
    x: unknown
  ): asserts x is TSConditionalType {
    TSConditionalType.assert(x);
  }
  export function assertTSInferType(x: unknown): asserts x is TSInferType {
    TSInferType.assert(x);
  }
  export function assertTSTypeParameter(
    x: unknown
  ): asserts x is TSTypeParameter {
    TSTypeParameter.assert(x);
  }
  export function assertTSParenthesizedType(
    x: unknown
  ): asserts x is TSParenthesizedType {
    TSParenthesizedType.assert(x);
  }
  export function assertTSFunctionType(
    x: unknown
  ): asserts x is TSFunctionType {
    TSFunctionType.assert(x);
  }
  export function assertTSConstructorType(
    x: unknown
  ): asserts x is TSConstructorType {
    TSConstructorType.assert(x);
  }
  export function assertTSDeclareFunction(
    x: unknown
  ): asserts x is TSDeclareFunction {
    TSDeclareFunction.assert(x);
  }
  export function assertTSDeclareMethod(
    x: unknown
  ): asserts x is TSDeclareMethod {
    TSDeclareMethod.assert(x);
  }
  export function assertTSMappedType(x: unknown): asserts x is TSMappedType {
    TSMappedType.assert(x);
  }
  export function assertTSTupleType(x: unknown): asserts x is TSTupleType {
    TSTupleType.assert(x);
  }
  export function assertTSNamedTupleMember(
    x: unknown
  ): asserts x is TSNamedTupleMember {
    TSNamedTupleMember.assert(x);
  }
  export function assertTSRestType(x: unknown): asserts x is TSRestType {
    TSRestType.assert(x);
  }
  export function assertTSOptionalType(
    x: unknown
  ): asserts x is TSOptionalType {
    TSOptionalType.assert(x);
  }
  export function assertTSIndexedAccessType(
    x: unknown
  ): asserts x is TSIndexedAccessType {
    TSIndexedAccessType.assert(x);
  }
  export function assertTSTypeOperator(
    x: unknown
  ): asserts x is TSTypeOperator {
    TSTypeOperator.assert(x);
  }
  export function assertTSTypeElement(x: unknown): asserts x is TSTypeElement {
    TSTypeElement.assert(x);
  }
  export function assertTSIndexSignature(
    x: unknown
  ): asserts x is TSIndexSignature {
    TSIndexSignature.assert(x);
  }
  export function assertTSPropertySignature(
    x: unknown
  ): asserts x is TSPropertySignature {
    TSPropertySignature.assert(x);
  }
  export function assertTSMethodSignature(
    x: unknown
  ): asserts x is TSMethodSignature {
    TSMethodSignature.assert(x);
  }
  export function assertTSTypePredicate(
    x: unknown
  ): asserts x is TSTypePredicate {
    TSTypePredicate.assert(x);
  }
  export function assertTSCallSignatureDeclaration(
    x: unknown
  ): asserts x is TSCallSignatureDeclaration {
    TSCallSignatureDeclaration.assert(x);
  }
  export function assertTSConstructSignatureDeclaration(
    x: unknown
  ): asserts x is TSConstructSignatureDeclaration {
    TSConstructSignatureDeclaration.assert(x);
  }
  export function assertTSEnumMember(x: unknown): asserts x is TSEnumMember {
    TSEnumMember.assert(x);
  }
  export function assertTSTypeQuery(x: unknown): asserts x is TSTypeQuery {
    TSTypeQuery.assert(x);
  }
  export function assertTSImportType(x: unknown): asserts x is TSImportType {
    TSImportType.assert(x);
  }
  export function assertTSTypeLiteral(x: unknown): asserts x is TSTypeLiteral {
    TSTypeLiteral.assert(x);
  }
  export function assertTSTypeAssertion(
    x: unknown
  ): asserts x is TSTypeAssertion {
    TSTypeAssertion.assert(x);
  }
  export function assertTSEnumDeclaration(
    x: unknown
  ): asserts x is TSEnumDeclaration {
    TSEnumDeclaration.assert(x);
  }
  export function assertTSTypeAliasDeclaration(
    x: unknown
  ): asserts x is TSTypeAliasDeclaration {
    TSTypeAliasDeclaration.assert(x);
  }
  export function assertTSModuleBlock(x: unknown): asserts x is TSModuleBlock {
    TSModuleBlock.assert(x);
  }
  export function assertTSModuleDeclaration(
    x: unknown
  ): asserts x is TSModuleDeclaration {
    TSModuleDeclaration.assert(x);
  }
  export function assertTSImportEqualsDeclaration(
    x: unknown
  ): asserts x is TSImportEqualsDeclaration {
    TSImportEqualsDeclaration.assert(x);
  }
  export function assertTSExternalModuleReference(
    x: unknown
  ): asserts x is TSExternalModuleReference {
    TSExternalModuleReference.assert(x);
  }
  export function assertTSExportAssignment(
    x: unknown
  ): asserts x is TSExportAssignment {
    TSExportAssignment.assert(x);
  }
  export function assertTSNamespaceExportDeclaration(
    x: unknown
  ): asserts x is TSNamespaceExportDeclaration {
    TSNamespaceExportDeclaration.assert(x);
  }
  export function assertTSInterfaceBody(
    x: unknown
  ): asserts x is TSInterfaceBody {
    TSInterfaceBody.assert(x);
  }
  export function assertTSInterfaceDeclaration(
    x: unknown
  ): asserts x is TSInterfaceDeclaration {
    TSInterfaceDeclaration.assert(x);
  }
  export function assertTSParameterProperty(
    x: unknown
  ): asserts x is TSParameterProperty {
    TSParameterProperty.assert(x);
  }
}
export interface NamedTypes {
  Node: Type<namedTypes.Node>;
  BaseNode: Type<namedTypes.BaseNode>;
  Placeholderable: Type<namedTypes.Placeholderable>;
  Expression: Type<namedTypes.Expression>;
  AwaitExpression: Type<namedTypes.AwaitExpression>;
  Decorator: Type<namedTypes.Decorator>;
  Property: Type<namedTypes.Property>;
  Statement: Type<namedTypes.Statement>;
  Declaration: Type<namedTypes.Declaration>;
  MethodDefinition: Type<namedTypes.MethodDefinition>;
  PrivateName: Type<namedTypes.PrivateName>;
  PatternLike: Type<namedTypes.PatternLike>;
  LVal: Type<namedTypes.LVal>;
  Identifier: Type<namedTypes.Identifier>;
  ClassPrivateProperty: Type<namedTypes.ClassPrivateProperty>;
  Comment: Type<namedTypes.Comment>;
  SourceLocation: Type<namedTypes.SourceLocation>;
  Position: Type<namedTypes.Position>;
  File: Type<namedTypes.File>;
  Scopable: Type<namedTypes.Scopable>;
  BlockParent: Type<namedTypes.BlockParent>;
  Program: Type<namedTypes.Program>;
  Function: Type<namedTypes.Function>;
  FunctionParent: Type<namedTypes.FunctionParent>;
  BaseFunction: Type<namedTypes.BaseFunction>;
  BlockStatement: Type<namedTypes.BlockStatement>;
  EmptyStatement: Type<namedTypes.EmptyStatement>;
  ExpressionStatement: Type<namedTypes.ExpressionStatement>;
  Conditional: Type<namedTypes.Conditional>;
  IfStatement: Type<namedTypes.IfStatement>;
  LabeledStatement: Type<namedTypes.LabeledStatement>;
  CompletionStatement: Type<namedTypes.CompletionStatement>;
  BreakStatement: Type<namedTypes.BreakStatement>;
  ContinueStatement: Type<namedTypes.ContinueStatement>;
  WithStatement: Type<namedTypes.WithStatement>;
  SwitchStatement: Type<namedTypes.SwitchStatement>;
  SwitchCase: Type<namedTypes.SwitchCase>;
  ReturnStatement: Type<namedTypes.ReturnStatement>;
  ThrowStatement: Type<namedTypes.ThrowStatement>;
  TryStatement: Type<namedTypes.TryStatement>;
  CatchClause: Type<namedTypes.CatchClause>;
  Loop: Type<namedTypes.Loop>;
  While: Type<namedTypes.While>;
  For: Type<namedTypes.For>;
  ForX: Type<namedTypes.ForX>;
  WhileStatement: Type<namedTypes.WhileStatement>;
  DoWhileStatement: Type<namedTypes.DoWhileStatement>;
  ForStatement: Type<namedTypes.ForStatement>;
  VariableDeclaration: Type<namedTypes.VariableDeclaration>;
  ForInStatement: Type<namedTypes.ForInStatement>;
  DebuggerStatement: Type<namedTypes.DebuggerStatement>;
  Pureish: Type<namedTypes.Pureish>;
  FunctionDeclaration: Type<namedTypes.FunctionDeclaration>;
  FunctionExpression: Type<namedTypes.FunctionExpression>;
  VariableDeclarator: Type<namedTypes.VariableDeclarator>;
  ThisExpression: Type<namedTypes.ThisExpression>;
  ArrayExpression: Type<namedTypes.ArrayExpression>;
  ObjectExpression: Type<namedTypes.ObjectExpression>;
  Literal: Type<namedTypes.Literal>;
  SequenceExpression: Type<namedTypes.SequenceExpression>;
  UnaryExpression: Type<namedTypes.UnaryExpression>;
  Binary: Type<namedTypes.Binary>;
  BinaryExpression: Type<namedTypes.BinaryExpression>;
  AssignmentExpression: Type<namedTypes.AssignmentExpression>;
  UpdateExpression: Type<namedTypes.UpdateExpression>;
  LogicalExpression: Type<namedTypes.LogicalExpression>;
  ConditionalExpression: Type<namedTypes.ConditionalExpression>;
  NewExpression: Type<namedTypes.NewExpression>;
  CallExpression: Type<namedTypes.CallExpression>;
  MemberExpression: Type<namedTypes.MemberExpression>;
  Pattern: Type<namedTypes.Pattern>;
  BaseComment: Type<namedTypes.BaseComment>;
  Placeholder: Type<namedTypes.Placeholder>;
  RestElement: Type<namedTypes.RestElement>;
  ArrowFunctionExpression: Type<namedTypes.ArrowFunctionExpression>;
  ForOfStatement: Type<namedTypes.ForOfStatement>;
  YieldExpression: Type<namedTypes.YieldExpression>;
  GeneratorExpression: Type<namedTypes.GeneratorExpression>;
  ComprehensionBlock: Type<namedTypes.ComprehensionBlock>;
  ComprehensionExpression: Type<namedTypes.ComprehensionExpression>;
  ObjectProperty: Type<namedTypes.ObjectProperty>;
  ArrayPattern: Type<namedTypes.ArrayPattern>;
  ObjectPattern: Type<namedTypes.ObjectPattern>;
  SpreadElement: Type<namedTypes.SpreadElement>;
  AssignmentPattern: Type<namedTypes.AssignmentPattern>;
  ClassPropertyDefinition: Type<namedTypes.ClassPropertyDefinition>;
  ClassProperty: Type<namedTypes.ClassProperty>;
  ClassBody: Type<namedTypes.ClassBody>;
  Class: Type<namedTypes.Class>;
  ClassDeclaration: Type<namedTypes.ClassDeclaration>;
  ClassExpression: Type<namedTypes.ClassExpression>;
  Super: Type<namedTypes.Super>;
  Specifier: Type<namedTypes.Specifier>;
  ModuleSpecifier: Type<namedTypes.ModuleSpecifier>;
  ImportSpecifier: Type<namedTypes.ImportSpecifier>;
  ImportDefaultSpecifier: Type<namedTypes.ImportDefaultSpecifier>;
  ImportNamespaceSpecifier: Type<namedTypes.ImportNamespaceSpecifier>;
  ImportDeclaration: Type<namedTypes.ImportDeclaration>;
  ExportNamedDeclaration: Type<namedTypes.ExportNamedDeclaration>;
  ExportSpecifier: Type<namedTypes.ExportSpecifier>;
  ExportDefaultDeclaration: Type<namedTypes.ExportDefaultDeclaration>;
  ExportAllDeclaration: Type<namedTypes.ExportAllDeclaration>;
  TaggedTemplateExpression: Type<namedTypes.TaggedTemplateExpression>;
  TemplateLiteral: Type<namedTypes.TemplateLiteral>;
  TemplateElement: Type<namedTypes.TemplateElement>;
  MetaProperty: Type<namedTypes.MetaProperty>;
  ExportBatchSpecifier: Type<namedTypes.ExportBatchSpecifier>;
  ExportDeclaration: Type<namedTypes.ExportDeclaration>;
  Block: Type<namedTypes.Block>;
  Line: Type<namedTypes.Line>;
  Noop: Type<namedTypes.Noop>;
  DoExpression: Type<namedTypes.DoExpression>;
  BindExpression: Type<namedTypes.BindExpression>;
  ParenthesizedExpression: Type<namedTypes.ParenthesizedExpression>;
  ExportNamespaceSpecifier: Type<namedTypes.ExportNamespaceSpecifier>;
  ExportDefaultSpecifier: Type<namedTypes.ExportDefaultSpecifier>;
  CommentBlock: Type<namedTypes.CommentBlock>;
  CommentLine: Type<namedTypes.CommentLine>;
  Directive: Type<namedTypes.Directive>;
  DirectiveLiteral: Type<namedTypes.DirectiveLiteral>;
  InterpreterDirective: Type<namedTypes.InterpreterDirective>;
  StringLiteral: Type<namedTypes.StringLiteral>;
  NumericLiteral: Type<namedTypes.NumericLiteral>;
  BigIntLiteral: Type<namedTypes.BigIntLiteral>;
  NullLiteral: Type<namedTypes.NullLiteral>;
  BooleanLiteral: Type<namedTypes.BooleanLiteral>;
  RegExpLiteral: Type<namedTypes.RegExpLiteral>;
  ObjectMethod: Type<namedTypes.ObjectMethod>;
  ClassMethod: Type<namedTypes.ClassMethod>;
  ClassPrivateMethod: Type<namedTypes.ClassPrivateMethod>;
  ForAwaitStatement: Type<namedTypes.ForAwaitStatement>;
  Import: Type<namedTypes.Import>;
  TSTypeAnnotation: Type<namedTypes.TSTypeAnnotation>;
  TSTypeParameterDeclaration: Type<namedTypes.TSTypeParameterDeclaration>;
  TSTypeParameterInstantiation: Type<namedTypes.TSTypeParameterInstantiation>;
  TSHasOptionalTypeParameterInstantiation: Type<namedTypes.TSHasOptionalTypeParameterInstantiation>;
  TSType: Type<namedTypes.TSType>;
  TSExpressionWithTypeArguments: Type<namedTypes.TSExpressionWithTypeArguments>;
  TSQualifiedName: Type<namedTypes.TSQualifiedName>;
  TSTypeReference: Type<namedTypes.TSTypeReference>;
  TSHasOptionalTypeParameters: Type<namedTypes.TSHasOptionalTypeParameters>;
  TSHasOptionalTypeAnnotation: Type<namedTypes.TSHasOptionalTypeAnnotation>;
  TSAsExpression: Type<namedTypes.TSAsExpression>;
  TSNonNullExpression: Type<namedTypes.TSNonNullExpression>;
  TSAnyKeyword: Type<namedTypes.TSAnyKeyword>;
  TSBigIntKeyword: Type<namedTypes.TSBigIntKeyword>;
  TSBooleanKeyword: Type<namedTypes.TSBooleanKeyword>;
  TSNeverKeyword: Type<namedTypes.TSNeverKeyword>;
  TSNullKeyword: Type<namedTypes.TSNullKeyword>;
  TSNumberKeyword: Type<namedTypes.TSNumberKeyword>;
  TSObjectKeyword: Type<namedTypes.TSObjectKeyword>;
  TSStringKeyword: Type<namedTypes.TSStringKeyword>;
  TSSymbolKeyword: Type<namedTypes.TSSymbolKeyword>;
  TSUndefinedKeyword: Type<namedTypes.TSUndefinedKeyword>;
  TSUnknownKeyword: Type<namedTypes.TSUnknownKeyword>;
  TSVoidKeyword: Type<namedTypes.TSVoidKeyword>;
  TSThisType: Type<namedTypes.TSThisType>;
  TSArrayType: Type<namedTypes.TSArrayType>;
  TSLiteralType: Type<namedTypes.TSLiteralType>;
  TSUnionType: Type<namedTypes.TSUnionType>;
  TSIntersectionType: Type<namedTypes.TSIntersectionType>;
  TSConditionalType: Type<namedTypes.TSConditionalType>;
  TSInferType: Type<namedTypes.TSInferType>;
  TSTypeParameter: Type<namedTypes.TSTypeParameter>;
  TSParenthesizedType: Type<namedTypes.TSParenthesizedType>;
  TSFunctionType: Type<namedTypes.TSFunctionType>;
  TSConstructorType: Type<namedTypes.TSConstructorType>;
  TSDeclareFunction: Type<namedTypes.TSDeclareFunction>;
  TSDeclareMethod: Type<namedTypes.TSDeclareMethod>;
  TSMappedType: Type<namedTypes.TSMappedType>;
  TSTupleType: Type<namedTypes.TSTupleType>;
  TSNamedTupleMember: Type<namedTypes.TSNamedTupleMember>;
  TSRestType: Type<namedTypes.TSRestType>;
  TSOptionalType: Type<namedTypes.TSOptionalType>;
  TSIndexedAccessType: Type<namedTypes.TSIndexedAccessType>;
  TSTypeOperator: Type<namedTypes.TSTypeOperator>;
  TSTypeElement: Type<namedTypes.TSTypeElement>;
  TSIndexSignature: Type<namedTypes.TSIndexSignature>;
  TSPropertySignature: Type<namedTypes.TSPropertySignature>;
  TSMethodSignature: Type<namedTypes.TSMethodSignature>;
  TSTypePredicate: Type<namedTypes.TSTypePredicate>;
  TSCallSignatureDeclaration: Type<namedTypes.TSCallSignatureDeclaration>;
  TSConstructSignatureDeclaration: Type<namedTypes.TSConstructSignatureDeclaration>;
  TSEnumMember: Type<namedTypes.TSEnumMember>;
  TSTypeQuery: Type<namedTypes.TSTypeQuery>;
  TSImportType: Type<namedTypes.TSImportType>;
  TSTypeLiteral: Type<namedTypes.TSTypeLiteral>;
  TSTypeAssertion: Type<namedTypes.TSTypeAssertion>;
  TSEnumDeclaration: Type<namedTypes.TSEnumDeclaration>;
  TSTypeAliasDeclaration: Type<namedTypes.TSTypeAliasDeclaration>;
  TSModuleBlock: Type<namedTypes.TSModuleBlock>;
  TSModuleDeclaration: Type<namedTypes.TSModuleDeclaration>;
  TSImportEqualsDeclaration: Type<namedTypes.TSImportEqualsDeclaration>;
  TSExternalModuleReference: Type<namedTypes.TSExternalModuleReference>;
  TSExportAssignment: Type<namedTypes.TSExportAssignment>;
  TSNamespaceExportDeclaration: Type<namedTypes.TSNamespaceExportDeclaration>;
  TSInterfaceBody: Type<namedTypes.TSInterfaceBody>;
  TSInterfaceDeclaration: Type<namedTypes.TSInterfaceDeclaration>;
  TSParameterProperty: Type<namedTypes.TSParameterProperty>;
}
