// !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!!
import { Type } from "../lib/baseTypes";
export type Node =
  | AwaitExpression
  | Decorator
  | Property
  | MethodDefinition
  | PrivateName
  | Identifier
  | ClassPrivateProperty
  | File
  | Program
  | BlockStatement
  | EmptyStatement
  | ExpressionStatement
  | IfStatement
  | LabeledStatement
  | BreakStatement
  | ContinueStatement
  | WithStatement
  | SwitchStatement
  | SwitchCase
  | ReturnStatement
  | ThrowStatement
  | TryStatement
  | CatchClause
  | WhileStatement
  | DoWhileStatement
  | ForStatement
  | VariableDeclaration
  | ForInStatement
  | DebuggerStatement
  | FunctionDeclaration
  | FunctionExpression
  | VariableDeclarator
  | ThisExpression
  | ArrayExpression
  | ObjectExpression
  | SequenceExpression
  | UnaryExpression
  | BinaryExpression
  | AssignmentExpression
  | UpdateExpression
  | LogicalExpression
  | ConditionalExpression
  | NewExpression
  | CallExpression
  | MemberExpression
  | Placeholder
  | RestElement
  | ArrowFunctionExpression
  | ForOfStatement
  | YieldExpression
  | GeneratorExpression
  | ComprehensionBlock
  | ComprehensionExpression
  | ObjectProperty
  | ArrayPattern
  | ObjectPattern
  | SpreadElement
  | AssignmentPattern
  | ClassPropertyDefinition
  | ClassProperty
  | ClassBody
  | ClassDeclaration
  | ClassExpression
  | Super
  | ImportSpecifier
  | ImportDefaultSpecifier
  | ImportNamespaceSpecifier
  | ImportDeclaration
  | ExportNamedDeclaration
  | ExportSpecifier
  | ExportDefaultDeclaration
  | ExportAllDeclaration
  | TaggedTemplateExpression
  | TemplateLiteral
  | TemplateElement
  | MetaProperty
  | Noop
  | DoExpression
  | BindExpression
  | ParenthesizedExpression
  | ExportNamespaceSpecifier
  | ExportDefaultSpecifier
  | Directive
  | DirectiveLiteral
  | InterpreterDirective
  | StringLiteral
  | NumericLiteral
  | BigIntLiteral
  | NullLiteral
  | BooleanLiteral
  | RegExpLiteral
  | ObjectMethod
  | ClassMethod
  | ClassPrivateMethod
  | ForAwaitStatement
  | Import
  | TSTypeAnnotation
  | TSTypeParameterDeclaration
  | TSTypeParameterInstantiation
  | TSExpressionWithTypeArguments
  | TSQualifiedName
  | TSTypeReference
  | TSAsExpression
  | TSNonNullExpression
  | TSAnyKeyword
  | TSBigIntKeyword
  | TSBooleanKeyword
  | TSNeverKeyword
  | TSNullKeyword
  | TSNumberKeyword
  | TSObjectKeyword
  | TSStringKeyword
  | TSSymbolKeyword
  | TSUndefinedKeyword
  | TSUnknownKeyword
  | TSVoidKeyword
  | TSThisType
  | TSArrayType
  | TSLiteralType
  | TSUnionType
  | TSIntersectionType
  | TSConditionalType
  | TSInferType
  | TSTypeParameter
  | TSParenthesizedType
  | TSFunctionType
  | TSConstructorType
  | TSDeclareFunction
  | TSDeclareMethod
  | TSMappedType
  | TSTupleType
  | TSNamedTupleMember
  | TSRestType
  | TSOptionalType
  | TSIndexedAccessType
  | TSTypeOperator
  | TSIndexSignature
  | TSPropertySignature
  | TSMethodSignature
  | TSTypePredicate
  | TSCallSignatureDeclaration
  | TSConstructSignatureDeclaration
  | TSEnumMember
  | TSTypeQuery
  | TSImportType
  | TSTypeLiteral
  | TSTypeAssertion
  | TSEnumDeclaration
  | TSTypeAliasDeclaration
  | TSModuleBlock
  | TSModuleDeclaration
  | TSImportEqualsDeclaration
  | TSExternalModuleReference
  | TSExportAssignment
  | TSNamespaceExportDeclaration
  | TSInterfaceBody
  | TSInterfaceDeclaration
  | TSParameterProperty;
export type Placeholderable =
  | AwaitExpression
  | MethodDefinition
  | PrivateName
  | Identifier
  | ClassPrivateProperty
  | BlockStatement
  | EmptyStatement
  | ExpressionStatement
  | IfStatement
  | LabeledStatement
  | BreakStatement
  | ContinueStatement
  | WithStatement
  | SwitchStatement
  | ReturnStatement
  | ThrowStatement
  | TryStatement
  | WhileStatement
  | DoWhileStatement
  | ForStatement
  | VariableDeclaration
  | ForInStatement
  | DebuggerStatement
  | FunctionDeclaration
  | FunctionExpression
  | ThisExpression
  | ArrayExpression
  | ObjectExpression
  | SequenceExpression
  | UnaryExpression
  | BinaryExpression
  | AssignmentExpression
  | UpdateExpression
  | LogicalExpression
  | ConditionalExpression
  | NewExpression
  | CallExpression
  | MemberExpression
  | ArrowFunctionExpression
  | ForOfStatement
  | YieldExpression
  | GeneratorExpression
  | ComprehensionExpression
  | ArrayPattern
  | ObjectPattern
  | AssignmentPattern
  | ClassPropertyDefinition
  | ClassProperty
  | ClassBody
  | ClassDeclaration
  | ClassExpression
  | Super
  | ImportDeclaration
  | ExportNamedDeclaration
  | ExportDefaultDeclaration
  | ExportAllDeclaration
  | TaggedTemplateExpression
  | TemplateLiteral
  | MetaProperty
  | Noop
  | DoExpression
  | BindExpression
  | ParenthesizedExpression
  | DirectiveLiteral
  | StringLiteral
  | NumericLiteral
  | BigIntLiteral
  | NullLiteral
  | BooleanLiteral
  | RegExpLiteral
  | ForAwaitStatement
  | Import
  | TSTypeParameterDeclaration
  | TSAsExpression
  | TSNonNullExpression
  | TSDeclareFunction
  | TSDeclareMethod
  | TSTypeAssertion
  | TSEnumDeclaration
  | TSTypeAliasDeclaration
  | TSModuleDeclaration
  | TSImportEqualsDeclaration
  | TSExportAssignment
  | TSNamespaceExportDeclaration
  | TSInterfaceDeclaration;
export type Expression =
  | AwaitExpression
  | PrivateName
  | Identifier
  | FunctionExpression
  | ThisExpression
  | ArrayExpression
  | ObjectExpression
  | SequenceExpression
  | UnaryExpression
  | BinaryExpression
  | AssignmentExpression
  | UpdateExpression
  | LogicalExpression
  | ConditionalExpression
  | NewExpression
  | CallExpression
  | MemberExpression
  | ArrowFunctionExpression
  | YieldExpression
  | GeneratorExpression
  | ComprehensionExpression
  | ClassExpression
  | Super
  | TaggedTemplateExpression
  | TemplateLiteral
  | MetaProperty
  | DoExpression
  | BindExpression
  | ParenthesizedExpression
  | DirectiveLiteral
  | StringLiteral
  | NumericLiteral
  | BigIntLiteral
  | NullLiteral
  | BooleanLiteral
  | RegExpLiteral
  | Import
  | TSAsExpression
  | TSNonNullExpression
  | TSTypeAssertion;
export type Statement =
  | MethodDefinition
  | ClassPrivateProperty
  | BlockStatement
  | EmptyStatement
  | ExpressionStatement
  | IfStatement
  | LabeledStatement
  | BreakStatement
  | ContinueStatement
  | WithStatement
  | SwitchStatement
  | ReturnStatement
  | ThrowStatement
  | TryStatement
  | WhileStatement
  | DoWhileStatement
  | ForStatement
  | VariableDeclaration
  | ForInStatement
  | DebuggerStatement
  | FunctionDeclaration
  | ForOfStatement
  | ClassPropertyDefinition
  | ClassProperty
  | ClassBody
  | ClassDeclaration
  | ImportDeclaration
  | ExportNamedDeclaration
  | ExportDefaultDeclaration
  | ExportAllDeclaration
  | Noop
  | ForAwaitStatement
  | TSTypeParameterDeclaration
  | TSDeclareFunction
  | TSDeclareMethod
  | TSEnumDeclaration
  | TSTypeAliasDeclaration
  | TSModuleDeclaration
  | TSImportEqualsDeclaration
  | TSExportAssignment
  | TSNamespaceExportDeclaration
  | TSInterfaceDeclaration;
export type Declaration =
  | MethodDefinition
  | ClassPrivateProperty
  | VariableDeclaration
  | FunctionDeclaration
  | ClassPropertyDefinition
  | ClassProperty
  | ClassBody
  | ClassDeclaration
  | ImportDeclaration
  | ExportNamedDeclaration
  | ExportDefaultDeclaration
  | ExportAllDeclaration
  | TSTypeParameterDeclaration
  | TSDeclareFunction
  | TSDeclareMethod
  | TSEnumDeclaration
  | TSTypeAliasDeclaration
  | TSModuleDeclaration
  | TSInterfaceDeclaration;
export type PatternLike =
  | Identifier
  | RestElement
  | ArrayPattern
  | ObjectPattern
  | AssignmentPattern;
export type LVal =
  | Identifier
  | MemberExpression
  | RestElement
  | ArrayPattern
  | ObjectPattern
  | AssignmentPattern
  | TSParameterProperty;
export type Comment = CommentBlock | CommentLine;
export type Scopable =
  | Program
  | BlockStatement
  | SwitchStatement
  | CatchClause
  | WhileStatement
  | DoWhileStatement
  | ForStatement
  | ForInStatement
  | FunctionDeclaration
  | FunctionExpression
  | ArrowFunctionExpression
  | ForOfStatement
  | ClassDeclaration
  | ClassExpression
  | ObjectMethod
  | ClassMethod
  | ClassPrivateMethod;
export type BlockParent =
  | Program
  | BlockStatement
  | SwitchStatement
  | CatchClause
  | FunctionDeclaration
  | FunctionExpression
  | ArrowFunctionExpression
  | ObjectMethod
  | ClassMethod
  | ClassPrivateMethod;
export type Function =
  | FunctionDeclaration
  | FunctionExpression
  | ArrowFunctionExpression
  | ObjectMethod
  | ClassMethod
  | ClassPrivateMethod;
export type FunctionParent =
  | FunctionDeclaration
  | FunctionExpression
  | ArrowFunctionExpression
  | ObjectMethod
  | ClassMethod
  | ClassPrivateMethod;
export type Conditional = IfStatement | ConditionalExpression;
export type CompletionStatement =
  | BreakStatement
  | ContinueStatement
  | ReturnStatement
  | ThrowStatement;
export type Loop =
  | WhileStatement
  | DoWhileStatement
  | ForStatement
  | ForInStatement
  | ForOfStatement;
export type While = WhileStatement | DoWhileStatement;
export type For = ForStatement | ForInStatement | ForOfStatement;
export type ForX = ForInStatement | ForOfStatement;
export type Pureish =
  | FunctionDeclaration
  | FunctionExpression
  | StringLiteral
  | NumericLiteral
  | BigIntLiteral
  | NullLiteral
  | BooleanLiteral
  | RegExpLiteral;
export type Literal =
  | StringLiteral
  | NumericLiteral
  | BigIntLiteral
  | NullLiteral
  | BooleanLiteral
  | RegExpLiteral;
export type Binary = BinaryExpression | LogicalExpression;
export type Pattern = ArrayPattern | ObjectPattern | AssignmentPattern;
export type Class = ClassDeclaration | ClassExpression;
export type Specifier =
  | ImportSpecifier
  | ImportDefaultSpecifier
  | ImportNamespaceSpecifier
  | ExportSpecifier
  | ExportNamespaceSpecifier
  | ExportDefaultSpecifier;
export type ModuleSpecifier =
  | ImportSpecifier
  | ImportDefaultSpecifier
  | ImportNamespaceSpecifier
  | ExportSpecifier;
export type TSType =
  | TSExpressionWithTypeArguments
  | TSTypeReference
  | TSAnyKeyword
  | TSBigIntKeyword
  | TSBooleanKeyword
  | TSNeverKeyword
  | TSNullKeyword
  | TSNumberKeyword
  | TSObjectKeyword
  | TSStringKeyword
  | TSSymbolKeyword
  | TSUndefinedKeyword
  | TSUnknownKeyword
  | TSVoidKeyword
  | TSThisType
  | TSArrayType
  | TSLiteralType
  | TSUnionType
  | TSIntersectionType
  | TSConditionalType
  | TSInferType
  | TSParenthesizedType
  | TSFunctionType
  | TSConstructorType
  | TSMappedType
  | TSTupleType
  | TSNamedTupleMember
  | TSRestType
  | TSOptionalType
  | TSIndexedAccessType
  | TSTypeOperator
  | TSTypePredicate
  | TSTypeQuery
  | TSImportType
  | TSTypeLiteral;
export type TSTypeElement =
  | TSIndexSignature
  | TSPropertySignature
  | TSMethodSignature
  | TSCallSignatureDeclaration
  | TSConstructSignatureDeclaration;
export interface BaseNode {
  type: string;
  comments?: Comment[] | null;
  loc?: SourceLocation | null;
}
export interface AwaitExpression extends BaseNode {
  argument: Expression;
  all?: boolean;
  type: "AwaitExpression";
}
export interface Decorator extends BaseNode {
  expression: Expression;
  type: "Decorator";
}
export interface Property extends BaseNode {
  decorators?: Decorator[] | null;
  kind: "init" | "get" | "set";
  key: Literal | Identifier | Expression;
  value: Expression | PatternLike;
  method?: boolean;
  shorthand?: boolean;
  computed?: boolean;
  type: "Property";
}
export interface MethodDefinition extends BaseNode {
  decorators?: Decorator[] | null;
  kind: "constructor" | "method" | "get" | "set";
  key: Expression;
  value: Function;
  computed?: boolean;
  static?: boolean;
  type: "MethodDefinition";
}
export interface PrivateName extends BaseNode {
  id: Identifier;
  type: "PrivateName";
}
export interface Identifier extends BaseNode {
  name: string;
  optional?: boolean;
  typeAnnotation?: TSTypeAnnotation | null;
  type: "Identifier";
}
export interface ClassPrivateProperty extends BaseNode {
  key: PrivateName;
  value?: Expression | null;
  computed?: boolean;
  type: "ClassPrivateProperty";
}
export interface SourceLocation {
  start: Position;
  end: Position;
  source?: string | null;
}
export interface Position {
  line: number;
  column: number;
}
export interface File extends BaseNode {
  program: Program;
  name?: string | null;
  type: "File";
}
export interface Program extends BaseNode {
  body: Statement[];
  directives: Directive[];
  interpreter?: InterpreterDirective | null;
  type: "Program";
}
export interface BaseFunction extends BaseNode {
  id?: Identifier | null;
  params: PatternLike[];
  body: BlockStatement;
  generator?: boolean;
  async?: boolean;
  expression?: boolean;
  defaults: (Expression | null)[];
  rest?: Identifier | null;
}
export interface BlockStatement extends BaseNode {
  body: Statement[];
  directives: Directive[];
  type: "BlockStatement";
}
export interface EmptyStatement extends BaseNode {
  type: "EmptyStatement";
}
export interface ExpressionStatement extends BaseNode {
  expression: Expression;
  type: "ExpressionStatement";
}
export interface IfStatement extends BaseNode {
  test: Expression;
  consequent: Statement;
  alternate?: Statement | null;
  type: "IfStatement";
}
export interface LabeledStatement extends BaseNode {
  label: Identifier;
  body: Statement;
  type: "LabeledStatement";
}
export interface BreakStatement extends BaseNode {
  label?: Identifier | null;
  type: "BreakStatement";
}
export interface ContinueStatement extends BaseNode {
  label?: Identifier | null;
  type: "ContinueStatement";
}
export interface WithStatement extends BaseNode {
  object: Expression;
  body: Statement;
  type: "WithStatement";
}
export interface SwitchStatement extends BaseNode {
  discriminant: Expression;
  cases: SwitchCase[];
  lexical?: boolean;
  type: "SwitchStatement";
}
export interface SwitchCase extends BaseNode {
  test: Expression | null;
  consequent: Statement[];
  type: "SwitchCase";
}
export interface ReturnStatement extends BaseNode {
  argument: Expression | null;
  type: "ReturnStatement";
}
export interface ThrowStatement extends BaseNode {
  argument: Expression;
  type: "ThrowStatement";
}
export interface TryStatement extends BaseNode {
  block: BlockStatement;
  handler?: CatchClause | null;
  handlers: CatchClause[];
  guardedHandlers: CatchClause[];
  finalizer?: BlockStatement | null;
  type: "TryStatement";
}
export interface CatchClause extends BaseNode {
  param: ArrayPattern | ObjectPattern | Identifier | null;
  guard?: Expression | null;
  body: BlockStatement;
  type: "CatchClause";
}
export interface WhileStatement extends BaseNode {
  test: Expression;
  body: Statement;
  type: "WhileStatement";
}
export interface DoWhileStatement extends BaseNode {
  body: Statement;
  test: Expression;
  type: "DoWhileStatement";
}
export interface ForStatement extends BaseNode {
  init: VariableDeclaration | Expression | null;
  test: Expression | null;
  update: Expression | null;
  body: Statement;
  type: "ForStatement";
}
export interface VariableDeclaration extends BaseNode {
  kind: "var" | "let" | "const";
  declarations: (Identifier | VariableDeclarator)[];
  type: "VariableDeclaration";
}
export interface ForInStatement extends BaseNode {
  left: VariableDeclaration | LVal;
  right: Expression;
  body: Statement;
  type: "ForInStatement";
}
export interface DebuggerStatement extends BaseNode {
  type: "DebuggerStatement";
}
export interface FunctionDeclaration extends Omit<BaseFunction, "id"> {
  id: Identifier | null;
  returnType?: TSTypeAnnotation | null;
  typeParameters?: TSTypeParameterDeclaration | null;
  type: "FunctionDeclaration";
}
export interface FunctionExpression extends BaseFunction {
  returnType?: TSTypeAnnotation | null;
  typeParameters?: TSTypeParameterDeclaration | null;
  type: "FunctionExpression";
}
export interface VariableDeclarator extends BaseNode {
  id: LVal;
  init?: Expression | null;
  type: "VariableDeclarator";
}
export interface ThisExpression extends BaseNode {
  type: "ThisExpression";
}
export interface ArrayExpression extends BaseNode {
  elements: (Expression | SpreadElement | null)[];
  type: "ArrayExpression";
}
export interface ObjectExpression extends BaseNode {
  properties: (Property | ObjectMethod | ObjectProperty | SpreadElement)[];
  type: "ObjectExpression";
}
export interface SequenceExpression extends BaseNode {
  expressions: Expression[];
  type: "SequenceExpression";
}
export interface UnaryExpression extends BaseNode {
  operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";
  argument: Expression;
  prefix: boolean;
  type: "UnaryExpression";
}
export interface BinaryExpression extends BaseNode {
  operator:
    | "=="
    | "!="
    | "==="
    | "!=="
    | "<"
    | "<="
    | ">"
    | ">="
    | "<<"
    | ">>"
    | ">>>"
    | "+"
    | "-"
    | "*"
    | "/"
    | "%"
    | "&"
    | "|"
    | "^"
    | "in"
    | "instanceof";
  left: Expression;
  right: Expression;
  type: "BinaryExpression";
}
export interface AssignmentExpression extends BaseNode {
  operator:
    | "="
    | "+="
    | "-="
    | "*="
    | "/="
    | "%="
    | "<<="
    | ">>="
    | ">>>="
    | "|="
    | "^="
    | "&=";
  left: LVal;
  right: Expression;
  type: "AssignmentExpression";
}
export interface UpdateExpression extends BaseNode {
  operator: "++" | "--";
  argument: Expression;
  prefix: boolean;
  type: "UpdateExpression";
}
export interface LogicalExpression extends BaseNode {
  operator: "||" | "&&";
  left: Expression;
  right: Expression;
  type: "LogicalExpression";
}
export interface ConditionalExpression extends BaseNode {
  test: Expression;
  consequent: Expression;
  alternate: Expression;
  type: "ConditionalExpression";
}
export interface NewExpression extends BaseNode {
  callee: Expression;
  arguments: (Expression | SpreadElement)[];
  type: "NewExpression";
}
export interface CallExpression extends BaseNode {
  callee: Expression;
  arguments: (Expression | SpreadElement)[];
  type: "CallExpression";
}
export interface MemberExpression extends BaseNode {
  object: Expression;
  property: Identifier | Expression;
  computed?: boolean;
  type: "MemberExpression";
}
export interface BaseComment {
  loc?: SourceLocation | null;
  value: string;
  leading: boolean;
  trailing?: boolean;
}
export interface Placeholder extends BaseNode {
  name: Identifier;
  expectedNode:
    | "Identifier"
    | "StringLiteral"
    | "Expression"
    | "Statement"
    | "Declaration"
    | "BlockStatement"
    | "ClassBody"
    | "Pattern";
  type: "Placeholder";
}
export interface RestElement extends BaseNode {
  argument: LVal;
  type: "RestElement";
}
export interface ArrowFunctionExpression
  extends Omit<BaseFunction, "id" | "body" | "generator"> {
  id?: null;
  body: BlockStatement | Expression;
  generator?: false;
  returnType?: TSTypeAnnotation | null;
  typeParameters?: TSTypeParameterDeclaration | null;
  type: "ArrowFunctionExpression";
}
export interface ForOfStatement extends BaseNode {
  left: VariableDeclaration | LVal;
  right: Expression;
  body: Statement;
  type: "ForOfStatement";
}
export interface YieldExpression extends BaseNode {
  argument: Expression | null;
  delegate?: boolean;
  type: "YieldExpression";
}
export interface GeneratorExpression extends BaseNode {
  body: Expression;
  blocks: ComprehensionBlock[];
  filter: Expression | null;
  type: "GeneratorExpression";
}
export interface ComprehensionBlock extends BaseNode {
  left: Pattern;
  right: Expression;
  each: boolean;
  type: "ComprehensionBlock";
}
export interface ComprehensionExpression extends BaseNode {
  body: Expression;
  blocks: ComprehensionBlock[];
  filter: Expression | null;
  type: "ComprehensionExpression";
}
export interface ObjectProperty extends BaseNode {
  shorthand?: boolean;
  key: Literal | Identifier | Expression;
  value: Expression | PatternLike;
  accessibility?: Literal | null;
  computed?: boolean;
  type: "ObjectProperty";
}
export interface ArrayPattern extends BaseNode {
  elements: (PatternLike | null)[];
  type: "ArrayPattern";
}
export interface ObjectPattern extends BaseNode {
  properties: (Property | ObjectProperty)[];
  decorators?: Decorator[] | null;
  typeAnnotation?: TSTypeAnnotation | null;
  type: "ObjectPattern";
}
export interface SpreadElement extends BaseNode {
  argument: Expression;
  type: "SpreadElement";
}
export interface AssignmentPattern extends BaseNode {
  left: Identifier | ObjectPattern | ArrayPattern | MemberExpression;
  right: Expression;
  type: "AssignmentPattern";
}
export interface ClassPropertyDefinition extends BaseNode {
  definition:
    | MethodDefinition
    | VariableDeclarator
    | ClassPropertyDefinition
    | ClassProperty;
  type: "ClassPropertyDefinition";
}
export interface ClassProperty extends BaseNode {
  key: Literal | Identifier | Expression;
  computed?: boolean;
  value: Expression | null;
  static?: boolean;
  typeAnnotation?: TSTypeAnnotation | null;
  access?: "public" | "private" | "protected" | undefined;
  type: "ClassProperty";
}
export interface ClassBody extends BaseNode {
  body: (
    | MethodDefinition
    | VariableDeclarator
    | ClassPropertyDefinition
    | ClassProperty
    | ClassPrivateProperty
    | ClassMethod
    | ClassPrivateMethod
    | TSDeclareMethod
    | (
        | TSCallSignatureDeclaration
        | TSConstructSignatureDeclaration
        | TSIndexSignature
        | TSMethodSignature
        | TSPropertySignature
      )
  )[];
  type: "ClassBody";
}
export interface ClassDeclaration extends BaseNode {
  id: Identifier | null;
  body: ClassBody;
  superClass?: Expression | null;
  typeParameters?: TSTypeParameterDeclaration | null;
  superTypeParameters?: TSTypeParameterInstantiation | null;
  implements: TSExpressionWithTypeArguments;
  type: "ClassDeclaration";
}
export interface ClassExpression extends BaseNode {
  id?: Identifier | null;
  body: ClassBody;
  superClass?: Expression | null;
  typeParameters?: TSTypeParameterDeclaration | null;
  superTypeParameters?: TSTypeParameterInstantiation | null;
  implements: TSExpressionWithTypeArguments;
  type: "ClassExpression";
}
export interface Super extends BaseNode {
  type: "Super";
}
export interface ImportSpecifier extends BaseNode {
  local?: Identifier | null;
  id?: Identifier | null;
  name?: Identifier | null;
  imported: Identifier;
  type: "ImportSpecifier";
}
export interface ImportDefaultSpecifier extends BaseNode {
  local?: Identifier | null;
  id?: Identifier | null;
  name?: Identifier | null;
  type: "ImportDefaultSpecifier";
}
export interface ImportNamespaceSpecifier extends BaseNode {
  local?: Identifier | null;
  id?: Identifier | null;
  name?: Identifier | null;
  type: "ImportNamespaceSpecifier";
}
export interface ImportDeclaration extends BaseNode {
  specifiers: (
    | ImportSpecifier
    | ImportNamespaceSpecifier
    | ImportDefaultSpecifier
  )[];
  source: Literal;
  importKind: "value" | "type";
  type: "ImportDeclaration";
}
export interface ExportNamedDeclaration extends BaseNode {
  declaration: Declaration | null;
  specifiers: ExportSpecifier[];
  source?: Literal | null;
  type: "ExportNamedDeclaration";
}
export interface ExportSpecifier extends BaseNode {
  local?: Identifier | null;
  id?: Identifier | null;
  name?: Identifier | null;
  exported: Identifier;
  type: "ExportSpecifier";
}
export interface ExportDefaultDeclaration extends BaseNode {
  declaration: Declaration | Expression;
  type: "ExportDefaultDeclaration";
}
export interface ExportAllDeclaration extends BaseNode {
  source: Literal;
  type: "ExportAllDeclaration";
}
export interface TaggedTemplateExpression extends BaseNode {
  tag: Expression;
  quasi: TemplateLiteral;
  type: "TaggedTemplateExpression";
}
export interface TemplateLiteral extends BaseNode {
  quasis: TemplateElement[];
  expressions: Expression[];
  type: "TemplateLiteral";
}
export interface TemplateElement extends BaseNode {
  value: { cooked: string; raw: string };
  tail: boolean;
  type: "TemplateElement";
}
export interface MetaProperty extends BaseNode {
  meta: Identifier;
  property: Identifier;
  type: "MetaProperty";
}
export interface Noop extends BaseNode {
  type: "Noop";
}
export interface DoExpression extends BaseNode {
  body: Statement[];
  type: "DoExpression";
}
export interface BindExpression extends BaseNode {
  object: Expression | null;
  callee: Expression;
  type: "BindExpression";
}
export interface ParenthesizedExpression extends BaseNode {
  expression: Expression;
  type: "ParenthesizedExpression";
}
export interface ExportNamespaceSpecifier extends BaseNode {
  exported: Identifier;
  type: "ExportNamespaceSpecifier";
}
export interface ExportDefaultSpecifier extends BaseNode {
  exported: Identifier;
  type: "ExportDefaultSpecifier";
}
export interface CommentBlock extends BaseComment {
  type: string;
}
export interface CommentLine extends BaseComment {
  type: string;
}
export interface Directive extends BaseNode {
  value: DirectiveLiteral;
  type: "Directive";
}
export interface DirectiveLiteral extends BaseNode {
  value: string;
  type: "DirectiveLiteral";
}
export interface InterpreterDirective extends BaseNode {
  value: string;
  type: "InterpreterDirective";
}
export interface StringLiteral extends BaseNode {
  value: string;
  raw?: string;
  extra: { rawValue: string; raw: string };
  type: "StringLiteral";
}
export interface NumericLiteral extends BaseNode {
  value: number;
  raw?: string;
  extra: { rawValue: number; raw: string };
  type: "NumericLiteral";
}
export interface BigIntLiteral extends BaseNode {
  value: string | number;
  raw: string;
  extra: { rawValue: string; raw: string };
  type: "BigIntLiteral";
}
export interface NullLiteral extends BaseNode {
  value: null;
  raw: string;
  extra: { rawValue: null; raw: string };
  type: "NullLiteral";
}
export interface BooleanLiteral extends BaseNode {
  value: boolean;
  raw: string;
  extra: { rawValue: boolean; raw: string };
  type: "BooleanLiteral";
}
export interface RegExpLiteral extends BaseNode {
  pattern: string;
  flags: string;
  value: RegExp;
  raw: string;
  extra: { rawValue: RegExp; raw: string };
  type: "RegExpLiteral";
}
export interface ObjectMethod
  extends Omit<BaseFunction, "params" | "body" | "generator" | "async"> {
  kind: "method" | "get" | "set";
  key: Literal | Identifier | Expression;
  params: PatternLike[];
  body: BlockStatement;
  computed?: boolean;
  generator?: boolean;
  async?: boolean;
  accessibility?: Literal | null;
  decorators?: Decorator[] | null;
  returnType?: TSTypeAnnotation | null;
  typeParameters?: TSTypeParameterDeclaration | null;
  type: "ObjectMethod";
}
export interface ClassMethod extends Omit<BaseFunction, "body"> {
  key: Literal | Identifier | Expression;
  kind: "get" | "set" | "method" | "constructor";
  body: BlockStatement;
  computed?: boolean;
  static?: boolean | null;
  abstract?: boolean | null;
  access?: "public" | "private" | "protected" | null;
  accessibility?: "public" | "private" | "protected" | null;
  decorators?: Decorator[] | null;
  optional?: boolean | null;
  returnType?: TSTypeAnnotation | null;
  typeParameters?: TSTypeParameterDeclaration | null;
  type: "ClassMethod";
}
export interface ClassPrivateMethod extends Omit<BaseFunction, "body"> {
  key: PrivateName;
  kind: "get" | "set" | "method" | "constructor";
  body: BlockStatement;
  computed?: boolean;
  static?: boolean | null;
  abstract?: boolean | null;
  access?: "public" | "private" | "protected" | null;
  accessibility?: "public" | "private" | "protected" | null;
  decorators?: Decorator[] | null;
  optional?: boolean | null;
  returnType?: TSTypeAnnotation | null;
  typeParameters?: TSTypeParameterDeclaration | null;
  type: "ClassPrivateMethod";
}
export interface ForAwaitStatement extends BaseNode {
  left: VariableDeclaration | Expression;
  right: Expression;
  body: Statement;
  type: "ForAwaitStatement";
}
export interface Import extends BaseNode {
  type: "Import";
}
export interface TSTypeAnnotation extends BaseNode {
  typeAnnotation: TSType | TSTypeAnnotation;
  type: "TSTypeAnnotation";
}
export interface TSTypeParameterDeclaration extends BaseNode {
  params: TSTypeParameter[];
  type: "TSTypeParameterDeclaration";
}
export interface TSTypeParameterInstantiation extends BaseNode {
  params: TSType[];
  type: "TSTypeParameterInstantiation";
}
export interface TSHasOptionalTypeParameterInstantiation extends BaseNode {
  typeParameters?: TSTypeParameterInstantiation | null;
}
export interface TSExpressionWithTypeArguments
  extends TSHasOptionalTypeParameterInstantiation {
  expression: Identifier | TSQualifiedName;
  type: "TSExpressionWithTypeArguments";
}
export interface TSQualifiedName extends BaseNode {
  left: Identifier | TSQualifiedName;
  right: Identifier | TSQualifiedName;
  type: "TSQualifiedName";
}
export interface TSTypeReference
  extends TSHasOptionalTypeParameterInstantiation {
  typeName: Identifier | TSQualifiedName;
  type: "TSTypeReference";
}
export interface TSHasOptionalTypeParameters extends BaseNode {
  typeParameters?: TSTypeParameterDeclaration | null | undefined;
}
export interface TSHasOptionalTypeAnnotation extends BaseNode {
  typeAnnotation?: TSTypeAnnotation | null;
}
export interface TSAsExpression extends BaseNode {
  expression: Expression;
  typeAnnotation: TSType;
  extra?: { parenthesized: boolean } | null;
  type: "TSAsExpression";
}
export interface TSNonNullExpression extends BaseNode {
  expression: Expression;
  type: "TSNonNullExpression";
}
export interface TSAnyKeyword extends BaseNode {
  type: "TSAnyKeyword";
}
export interface TSBigIntKeyword extends BaseNode {
  type: "TSBigIntKeyword";
}
export interface TSBooleanKeyword extends BaseNode {
  type: "TSBooleanKeyword";
}
export interface TSNeverKeyword extends BaseNode {
  type: "TSNeverKeyword";
}
export interface TSNullKeyword extends BaseNode {
  type: "TSNullKeyword";
}
export interface TSNumberKeyword extends BaseNode {
  type: "TSNumberKeyword";
}
export interface TSObjectKeyword extends BaseNode {
  type: "TSObjectKeyword";
}
export interface TSStringKeyword extends BaseNode {
  type: "TSStringKeyword";
}
export interface TSSymbolKeyword extends BaseNode {
  type: "TSSymbolKeyword";
}
export interface TSUndefinedKeyword extends BaseNode {
  type: "TSUndefinedKeyword";
}
export interface TSUnknownKeyword extends BaseNode {
  type: "TSUnknownKeyword";
}
export interface TSVoidKeyword extends BaseNode {
  type: "TSVoidKeyword";
}
export interface TSThisType extends BaseNode {
  type: "TSThisType";
}
export interface TSArrayType extends BaseNode {
  elementType: TSType;
  type: "TSArrayType";
}
export interface TSLiteralType extends BaseNode {
  literal:
    | NumericLiteral
    | StringLiteral
    | BooleanLiteral
    | TemplateLiteral
    | UnaryExpression;
  type: "TSLiteralType";
}
export interface TSUnionType extends BaseNode {
  types: TSType[];
  type: "TSUnionType";
}
export interface TSIntersectionType extends BaseNode {
  types: TSType[];
  type: "TSIntersectionType";
}
export interface TSConditionalType extends BaseNode {
  checkType: TSType;
  extendsType: TSType;
  trueType: TSType;
  falseType: TSType;
  type: "TSConditionalType";
}
export interface TSInferType extends BaseNode {
  typeParameter: TSTypeParameter;
  type: "TSInferType";
}
export interface TSTypeParameter extends BaseNode {
  name: string;
  constraint?: TSType | undefined;
  default?: TSType | undefined;
  type: "TSTypeParameter";
}
export interface TSParenthesizedType extends BaseNode {
  typeAnnotation: TSType;
  type: "TSParenthesizedType";
}
export interface TSFunctionType
  extends TSHasOptionalTypeParameters,
    TSHasOptionalTypeAnnotation {
  parameters: (Identifier | RestElement | ArrayPattern | ObjectPattern)[];
  type: "TSFunctionType";
}
export interface TSConstructorType
  extends TSHasOptionalTypeParameters,
    TSHasOptionalTypeAnnotation {
  parameters: (Identifier | RestElement | ArrayPattern | ObjectPattern)[];
  type: "TSConstructorType";
}
export interface TSDeclareFunction extends TSHasOptionalTypeParameters {
  declare?: boolean;
  async?: boolean;
  generator?: boolean;
  id?: Identifier | null;
  params: PatternLike[];
  returnType?: TSTypeAnnotation | Noop | null;
  type: "TSDeclareFunction";
}
export interface TSDeclareMethod extends TSHasOptionalTypeParameters {
  async?: boolean;
  generator?: boolean;
  params: PatternLike[];
  abstract?: boolean;
  accessibility?: "public" | "private" | "protected" | undefined;
  static?: boolean;
  computed?: boolean;
  optional?: boolean;
  key: Identifier | StringLiteral | NumericLiteral | Expression;
  kind: "get" | "set" | "method" | "constructor";
  access?: "public" | "private" | "protected" | undefined;
  decorators?: Decorator[] | null;
  returnType?: TSTypeAnnotation | Noop | null;
  type: "TSDeclareMethod";
}
export interface TSMappedType extends BaseNode {
  readonly?: boolean | "+" | "-";
  typeParameter: TSTypeParameter;
  optional?: boolean | "+" | "-";
  typeAnnotation?: TSType | null;
  type: "TSMappedType";
}
export interface TSTupleType extends BaseNode {
  elementTypes: (TSType | TSNamedTupleMember)[];
  type: "TSTupleType";
}
export interface TSNamedTupleMember extends BaseNode {
  label: Identifier;
  optional?: boolean;
  elementType: TSType;
  type: "TSNamedTupleMember";
}
export interface TSRestType extends BaseNode {
  typeAnnotation: TSType;
  type: "TSRestType";
}
export interface TSOptionalType extends BaseNode {
  typeAnnotation: TSType;
  type: "TSOptionalType";
}
export interface TSIndexedAccessType extends BaseNode {
  objectType: TSType;
  indexType: TSType;
  type: "TSIndexedAccessType";
}
export interface TSTypeOperator extends BaseNode {
  operator: string;
  typeAnnotation: TSType;
  type: "TSTypeOperator";
}
export interface TSIndexSignature extends TSHasOptionalTypeAnnotation {
  parameters: Identifier[];
  readonly?: boolean;
  type: "TSIndexSignature";
}
export interface TSPropertySignature extends TSHasOptionalTypeAnnotation {
  key: Expression;
  computed?: boolean;
  readonly?: boolean;
  optional?: boolean;
  initializer?: Expression | null;
  type: "TSPropertySignature";
}
export interface TSMethodSignature
  extends TSHasOptionalTypeParameters,
    TSHasOptionalTypeAnnotation {
  key: Expression;
  computed?: boolean;
  optional?: boolean;
  parameters: (Identifier | RestElement | ArrayPattern | ObjectPattern)[];
  type: "TSMethodSignature";
}
export interface TSTypePredicate extends BaseNode {
  parameterName: Identifier | TSThisType;
  typeAnnotation?: TSTypeAnnotation | null;
  asserts?: boolean;
  type: "TSTypePredicate";
}
export interface TSCallSignatureDeclaration
  extends TSHasOptionalTypeParameters,
    TSHasOptionalTypeAnnotation {
  parameters: (Identifier | RestElement | ArrayPattern | ObjectPattern)[];
  type: "TSCallSignatureDeclaration";
}
export interface TSConstructSignatureDeclaration
  extends TSHasOptionalTypeParameters,
    TSHasOptionalTypeAnnotation {
  parameters: (Identifier | RestElement | ArrayPattern | ObjectPattern)[];
  type: "TSConstructSignatureDeclaration";
}
export interface TSEnumMember extends BaseNode {
  id: Identifier | StringLiteral;
  initializer?: Expression | null;
  type: "TSEnumMember";
}
export interface TSTypeQuery extends BaseNode {
  exprName: (Identifier | TSQualifiedName) | TSImportType;
  type: "TSTypeQuery";
}
export interface TSImportType extends TSHasOptionalTypeParameterInstantiation {
  argument: StringLiteral;
  qualifier?: (Identifier | TSQualifiedName) | undefined;
  type: "TSImportType";
}
export interface TSTypeLiteral extends BaseNode {
  members: (
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSIndexSignature
    | TSMethodSignature
    | TSPropertySignature
  )[];
  type: "TSTypeLiteral";
}
export interface TSTypeAssertion extends BaseNode {
  typeAnnotation: TSType;
  expression: Expression;
  extra?: { parenthesized: boolean } | null;
  type: "TSTypeAssertion";
}
export interface TSEnumDeclaration extends BaseNode {
  id: Identifier;
  const?: boolean;
  declare?: boolean;
  members: TSEnumMember[];
  initializer?: Expression | null;
  type: "TSEnumDeclaration";
}
export interface TSTypeAliasDeclaration extends TSHasOptionalTypeParameters {
  id: Identifier;
  declare?: boolean;
  typeAnnotation: TSType;
  type: "TSTypeAliasDeclaration";
}
export interface TSModuleBlock extends BaseNode {
  body: Statement[];
  type: "TSModuleBlock";
}
export interface TSModuleDeclaration extends BaseNode {
  id: StringLiteral | (Identifier | TSQualifiedName);
  declare?: boolean;
  global?: boolean;
  body?: TSModuleBlock | TSModuleDeclaration | null;
  type: "TSModuleDeclaration";
}
export interface TSImportEqualsDeclaration extends BaseNode {
  id: Identifier;
  isExport?: boolean;
  moduleReference: (Identifier | TSQualifiedName) | TSExternalModuleReference;
  type: "TSImportEqualsDeclaration";
}
export interface TSExternalModuleReference extends BaseNode {
  expression: StringLiteral;
  type: "TSExternalModuleReference";
}
export interface TSExportAssignment extends BaseNode {
  expression: Expression;
  type: "TSExportAssignment";
}
export interface TSNamespaceExportDeclaration extends BaseNode {
  id: Identifier;
  type: "TSNamespaceExportDeclaration";
}
export interface TSInterfaceBody extends BaseNode {
  body: (
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSIndexSignature
    | TSMethodSignature
    | TSPropertySignature
  )[];
  type: "TSInterfaceBody";
}
export interface TSInterfaceDeclaration extends TSHasOptionalTypeParameters {
  id: Identifier | TSQualifiedName;
  declare?: boolean;
  extends?: TSExpressionWithTypeArguments[] | null;
  body: TSInterfaceBody;
  type: "TSInterfaceDeclaration";
}
export interface TSParameterProperty extends BaseNode {
  accessibility?: "public" | "private" | "protected" | undefined;
  readonly?: boolean;
  parameter: Identifier | AssignmentPattern;
  type: "TSParameterProperty";
}
export type ASTNode =
  | AwaitExpression
  | Decorator
  | Property
  | MethodDefinition
  | PrivateName
  | Identifier
  | ClassPrivateProperty
  | File
  | Program
  | BlockStatement
  | EmptyStatement
  | ExpressionStatement
  | IfStatement
  | LabeledStatement
  | BreakStatement
  | ContinueStatement
  | WithStatement
  | SwitchStatement
  | SwitchCase
  | ReturnStatement
  | ThrowStatement
  | TryStatement
  | CatchClause
  | WhileStatement
  | DoWhileStatement
  | ForStatement
  | VariableDeclaration
  | ForInStatement
  | DebuggerStatement
  | FunctionDeclaration
  | FunctionExpression
  | VariableDeclarator
  | ThisExpression
  | ArrayExpression
  | ObjectExpression
  | SequenceExpression
  | UnaryExpression
  | BinaryExpression
  | AssignmentExpression
  | UpdateExpression
  | LogicalExpression
  | ConditionalExpression
  | NewExpression
  | CallExpression
  | MemberExpression
  | Placeholder
  | RestElement
  | ArrowFunctionExpression
  | ForOfStatement
  | YieldExpression
  | GeneratorExpression
  | ComprehensionBlock
  | ComprehensionExpression
  | ObjectProperty
  | ArrayPattern
  | ObjectPattern
  | SpreadElement
  | AssignmentPattern
  | ClassPropertyDefinition
  | ClassProperty
  | ClassBody
  | ClassDeclaration
  | ClassExpression
  | Super
  | ImportSpecifier
  | ImportDefaultSpecifier
  | ImportNamespaceSpecifier
  | ImportDeclaration
  | ExportNamedDeclaration
  | ExportSpecifier
  | ExportDefaultDeclaration
  | ExportAllDeclaration
  | TaggedTemplateExpression
  | TemplateLiteral
  | TemplateElement
  | MetaProperty
  | Noop
  | DoExpression
  | BindExpression
  | ParenthesizedExpression
  | ExportNamespaceSpecifier
  | ExportDefaultSpecifier
  | CommentBlock
  | CommentLine
  | Directive
  | DirectiveLiteral
  | InterpreterDirective
  | StringLiteral
  | NumericLiteral
  | BigIntLiteral
  | NullLiteral
  | BooleanLiteral
  | RegExpLiteral
  | ObjectMethod
  | ClassMethod
  | ClassPrivateMethod
  | ForAwaitStatement
  | Import
  | TSTypeAnnotation
  | TSTypeParameterDeclaration
  | TSTypeParameterInstantiation
  | TSExpressionWithTypeArguments
  | TSQualifiedName
  | TSTypeReference
  | TSAsExpression
  | TSNonNullExpression
  | TSAnyKeyword
  | TSBigIntKeyword
  | TSBooleanKeyword
  | TSNeverKeyword
  | TSNullKeyword
  | TSNumberKeyword
  | TSObjectKeyword
  | TSStringKeyword
  | TSSymbolKeyword
  | TSUndefinedKeyword
  | TSUnknownKeyword
  | TSVoidKeyword
  | TSThisType
  | TSArrayType
  | TSLiteralType
  | TSUnionType
  | TSIntersectionType
  | TSConditionalType
  | TSInferType
  | TSTypeParameter
  | TSParenthesizedType
  | TSFunctionType
  | TSConstructorType
  | TSDeclareFunction
  | TSDeclareMethod
  | TSMappedType
  | TSTupleType
  | TSNamedTupleMember
  | TSRestType
  | TSOptionalType
  | TSIndexedAccessType
  | TSTypeOperator
  | TSIndexSignature
  | TSPropertySignature
  | TSMethodSignature
  | TSTypePredicate
  | TSCallSignatureDeclaration
  | TSConstructSignatureDeclaration
  | TSEnumMember
  | TSTypeQuery
  | TSImportType
  | TSTypeLiteral
  | TSTypeAssertion
  | TSEnumDeclaration
  | TSTypeAliasDeclaration
  | TSModuleBlock
  | TSModuleDeclaration
  | TSImportEqualsDeclaration
  | TSExternalModuleReference
  | TSExportAssignment
  | TSNamespaceExportDeclaration
  | TSInterfaceBody
  | TSInterfaceDeclaration
  | TSParameterProperty;
export let BaseNode: Type<BaseNode>;
export let assertBaseNode: (x: unknown) => asserts x is BaseNode;
export let Node: Type<Node>;
export let assertNode: (x: unknown) => asserts x is Node;
export let Placeholderable: Type<Placeholderable>;
export let assertPlaceholderable: (x: unknown) => asserts x is Placeholderable;
export let Expression: Type<Expression>;
export let assertExpression: (x: unknown) => asserts x is Expression;
export let AwaitExpression: Type<AwaitExpression>;
export let assertAwaitExpression: (x: unknown) => asserts x is AwaitExpression;
export let Decorator: Type<Decorator>;
export let assertDecorator: (x: unknown) => asserts x is Decorator;
export let Property: Type<Property>;
export let assertProperty: (x: unknown) => asserts x is Property;
export let Statement: Type<Statement>;
export let assertStatement: (x: unknown) => asserts x is Statement;
export let Declaration: Type<Declaration>;
export let assertDeclaration: (x: unknown) => asserts x is Declaration;
export let MethodDefinition: Type<MethodDefinition>;
export let assertMethodDefinition: (
  x: unknown
) => asserts x is MethodDefinition;
export let PrivateName: Type<PrivateName>;
export let assertPrivateName: (x: unknown) => asserts x is PrivateName;
export let PatternLike: Type<PatternLike>;
export let assertPatternLike: (x: unknown) => asserts x is PatternLike;
export let LVal: Type<LVal>;
export let assertLVal: (x: unknown) => asserts x is LVal;
export let Identifier: Type<Identifier>;
export let assertIdentifier: (x: unknown) => asserts x is Identifier;
export let ClassPrivateProperty: Type<ClassPrivateProperty>;
export let assertClassPrivateProperty: (
  x: unknown
) => asserts x is ClassPrivateProperty;
export let Comment: Type<Comment>;
export let assertComment: (x: unknown) => asserts x is Comment;
export let SourceLocation: Type<SourceLocation>;
export let assertSourceLocation: (x: unknown) => asserts x is SourceLocation;
export let Position: Type<Position>;
export let assertPosition: (x: unknown) => asserts x is Position;
export let File: Type<File>;
export let assertFile: (x: unknown) => asserts x is File;
export let Scopable: Type<Scopable>;
export let assertScopable: (x: unknown) => asserts x is Scopable;
export let BlockParent: Type<BlockParent>;
export let assertBlockParent: (x: unknown) => asserts x is BlockParent;
export let Program: Type<Program>;
export let assertProgram: (x: unknown) => asserts x is Program;
export let Function: Type<Function>;
export let assertFunction: (x: unknown) => asserts x is Function;
export let FunctionParent: Type<FunctionParent>;
export let assertFunctionParent: (x: unknown) => asserts x is FunctionParent;
export let BaseFunction: Type<BaseFunction>;
export let assertBaseFunction: (x: unknown) => asserts x is BaseFunction;
export let BlockStatement: Type<BlockStatement>;
export let assertBlockStatement: (x: unknown) => asserts x is BlockStatement;
export let EmptyStatement: Type<EmptyStatement>;
export let assertEmptyStatement: (x: unknown) => asserts x is EmptyStatement;
export let ExpressionStatement: Type<ExpressionStatement>;
export let assertExpressionStatement: (
  x: unknown
) => asserts x is ExpressionStatement;
export let Conditional: Type<Conditional>;
export let assertConditional: (x: unknown) => asserts x is Conditional;
export let IfStatement: Type<IfStatement>;
export let assertIfStatement: (x: unknown) => asserts x is IfStatement;
export let LabeledStatement: Type<LabeledStatement>;
export let assertLabeledStatement: (
  x: unknown
) => asserts x is LabeledStatement;
export let CompletionStatement: Type<CompletionStatement>;
export let assertCompletionStatement: (
  x: unknown
) => asserts x is CompletionStatement;
export let BreakStatement: Type<BreakStatement>;
export let assertBreakStatement: (x: unknown) => asserts x is BreakStatement;
export let ContinueStatement: Type<ContinueStatement>;
export let assertContinueStatement: (
  x: unknown
) => asserts x is ContinueStatement;
export let WithStatement: Type<WithStatement>;
export let assertWithStatement: (x: unknown) => asserts x is WithStatement;
export let SwitchStatement: Type<SwitchStatement>;
export let assertSwitchStatement: (x: unknown) => asserts x is SwitchStatement;
export let SwitchCase: Type<SwitchCase>;
export let assertSwitchCase: (x: unknown) => asserts x is SwitchCase;
export let ReturnStatement: Type<ReturnStatement>;
export let assertReturnStatement: (x: unknown) => asserts x is ReturnStatement;
export let ThrowStatement: Type<ThrowStatement>;
export let assertThrowStatement: (x: unknown) => asserts x is ThrowStatement;
export let TryStatement: Type<TryStatement>;
export let assertTryStatement: (x: unknown) => asserts x is TryStatement;
export let CatchClause: Type<CatchClause>;
export let assertCatchClause: (x: unknown) => asserts x is CatchClause;
export let Loop: Type<Loop>;
export let assertLoop: (x: unknown) => asserts x is Loop;
export let While: Type<While>;
export let assertWhile: (x: unknown) => asserts x is While;
export let For: Type<For>;
export let assertFor: (x: unknown) => asserts x is For;
export let ForX: Type<ForX>;
export let assertForX: (x: unknown) => asserts x is ForX;
export let WhileStatement: Type<WhileStatement>;
export let assertWhileStatement: (x: unknown) => asserts x is WhileStatement;
export let DoWhileStatement: Type<DoWhileStatement>;
export let assertDoWhileStatement: (
  x: unknown
) => asserts x is DoWhileStatement;
export let ForStatement: Type<ForStatement>;
export let assertForStatement: (x: unknown) => asserts x is ForStatement;
export let VariableDeclaration: Type<VariableDeclaration>;
export let assertVariableDeclaration: (
  x: unknown
) => asserts x is VariableDeclaration;
export let ForInStatement: Type<ForInStatement>;
export let assertForInStatement: (x: unknown) => asserts x is ForInStatement;
export let DebuggerStatement: Type<DebuggerStatement>;
export let assertDebuggerStatement: (
  x: unknown
) => asserts x is DebuggerStatement;
export let Pureish: Type<Pureish>;
export let assertPureish: (x: unknown) => asserts x is Pureish;
export let FunctionDeclaration: Type<FunctionDeclaration>;
export let assertFunctionDeclaration: (
  x: unknown
) => asserts x is FunctionDeclaration;
export let FunctionExpression: Type<FunctionExpression>;
export let assertFunctionExpression: (
  x: unknown
) => asserts x is FunctionExpression;
export let VariableDeclarator: Type<VariableDeclarator>;
export let assertVariableDeclarator: (
  x: unknown
) => asserts x is VariableDeclarator;
export let ThisExpression: Type<ThisExpression>;
export let assertThisExpression: (x: unknown) => asserts x is ThisExpression;
export let ArrayExpression: Type<ArrayExpression>;
export let assertArrayExpression: (x: unknown) => asserts x is ArrayExpression;
export let ObjectExpression: Type<ObjectExpression>;
export let assertObjectExpression: (
  x: unknown
) => asserts x is ObjectExpression;
export let Literal: Type<Literal>;
export let assertLiteral: (x: unknown) => asserts x is Literal;
export let SequenceExpression: Type<SequenceExpression>;
export let assertSequenceExpression: (
  x: unknown
) => asserts x is SequenceExpression;
export let UnaryExpression: Type<UnaryExpression>;
export let assertUnaryExpression: (x: unknown) => asserts x is UnaryExpression;
export let Binary: Type<Binary>;
export let assertBinary: (x: unknown) => asserts x is Binary;
export let BinaryExpression: Type<BinaryExpression>;
export let assertBinaryExpression: (
  x: unknown
) => asserts x is BinaryExpression;
export let AssignmentExpression: Type<AssignmentExpression>;
export let assertAssignmentExpression: (
  x: unknown
) => asserts x is AssignmentExpression;
export let UpdateExpression: Type<UpdateExpression>;
export let assertUpdateExpression: (
  x: unknown
) => asserts x is UpdateExpression;
export let LogicalExpression: Type<LogicalExpression>;
export let assertLogicalExpression: (
  x: unknown
) => asserts x is LogicalExpression;
export let ConditionalExpression: Type<ConditionalExpression>;
export let assertConditionalExpression: (
  x: unknown
) => asserts x is ConditionalExpression;
export let NewExpression: Type<NewExpression>;
export let assertNewExpression: (x: unknown) => asserts x is NewExpression;
export let CallExpression: Type<CallExpression>;
export let assertCallExpression: (x: unknown) => asserts x is CallExpression;
export let MemberExpression: Type<MemberExpression>;
export let assertMemberExpression: (
  x: unknown
) => asserts x is MemberExpression;
export let Pattern: Type<Pattern>;
export let assertPattern: (x: unknown) => asserts x is Pattern;
export let BaseComment: Type<BaseComment>;
export let assertBaseComment: (x: unknown) => asserts x is BaseComment;
export let Placeholder: Type<Placeholder>;
export let assertPlaceholder: (x: unknown) => asserts x is Placeholder;
export let RestElement: Type<RestElement>;
export let assertRestElement: (x: unknown) => asserts x is RestElement;
export let ArrowFunctionExpression: Type<ArrowFunctionExpression>;
export let assertArrowFunctionExpression: (
  x: unknown
) => asserts x is ArrowFunctionExpression;
export let ForOfStatement: Type<ForOfStatement>;
export let assertForOfStatement: (x: unknown) => asserts x is ForOfStatement;
export let YieldExpression: Type<YieldExpression>;
export let assertYieldExpression: (x: unknown) => asserts x is YieldExpression;
export let GeneratorExpression: Type<GeneratorExpression>;
export let assertGeneratorExpression: (
  x: unknown
) => asserts x is GeneratorExpression;
export let ComprehensionBlock: Type<ComprehensionBlock>;
export let assertComprehensionBlock: (
  x: unknown
) => asserts x is ComprehensionBlock;
export let ComprehensionExpression: Type<ComprehensionExpression>;
export let assertComprehensionExpression: (
  x: unknown
) => asserts x is ComprehensionExpression;
export let ObjectProperty: Type<ObjectProperty>;
export let assertObjectProperty: (x: unknown) => asserts x is ObjectProperty;
export let ArrayPattern: Type<ArrayPattern>;
export let assertArrayPattern: (x: unknown) => asserts x is ArrayPattern;
export let ObjectPattern: Type<ObjectPattern>;
export let assertObjectPattern: (x: unknown) => asserts x is ObjectPattern;
export let SpreadElement: Type<SpreadElement>;
export let assertSpreadElement: (x: unknown) => asserts x is SpreadElement;
export let AssignmentPattern: Type<AssignmentPattern>;
export let assertAssignmentPattern: (
  x: unknown
) => asserts x is AssignmentPattern;
export let ClassPropertyDefinition: Type<ClassPropertyDefinition>;
export let assertClassPropertyDefinition: (
  x: unknown
) => asserts x is ClassPropertyDefinition;
export let ClassProperty: Type<ClassProperty>;
export let assertClassProperty: (x: unknown) => asserts x is ClassProperty;
export let ClassBody: Type<ClassBody>;
export let assertClassBody: (x: unknown) => asserts x is ClassBody;
export let Class: Type<Class>;
export let assertClass: (x: unknown) => asserts x is Class;
export let ClassDeclaration: Type<ClassDeclaration>;
export let assertClassDeclaration: (
  x: unknown
) => asserts x is ClassDeclaration;
export let ClassExpression: Type<ClassExpression>;
export let assertClassExpression: (x: unknown) => asserts x is ClassExpression;
export let Super: Type<Super>;
export let assertSuper: (x: unknown) => asserts x is Super;
export let Specifier: Type<Specifier>;
export let assertSpecifier: (x: unknown) => asserts x is Specifier;
export let ModuleSpecifier: Type<ModuleSpecifier>;
export let assertModuleSpecifier: (x: unknown) => asserts x is ModuleSpecifier;
export let ImportSpecifier: Type<ImportSpecifier>;
export let assertImportSpecifier: (x: unknown) => asserts x is ImportSpecifier;
export let ImportDefaultSpecifier: Type<ImportDefaultSpecifier>;
export let assertImportDefaultSpecifier: (
  x: unknown
) => asserts x is ImportDefaultSpecifier;
export let ImportNamespaceSpecifier: Type<ImportNamespaceSpecifier>;
export let assertImportNamespaceSpecifier: (
  x: unknown
) => asserts x is ImportNamespaceSpecifier;
export let ImportDeclaration: Type<ImportDeclaration>;
export let assertImportDeclaration: (
  x: unknown
) => asserts x is ImportDeclaration;
export let ExportNamedDeclaration: Type<ExportNamedDeclaration>;
export let assertExportNamedDeclaration: (
  x: unknown
) => asserts x is ExportNamedDeclaration;
export let ExportSpecifier: Type<ExportSpecifier>;
export let assertExportSpecifier: (x: unknown) => asserts x is ExportSpecifier;
export let ExportDefaultDeclaration: Type<ExportDefaultDeclaration>;
export let assertExportDefaultDeclaration: (
  x: unknown
) => asserts x is ExportDefaultDeclaration;
export let ExportAllDeclaration: Type<ExportAllDeclaration>;
export let assertExportAllDeclaration: (
  x: unknown
) => asserts x is ExportAllDeclaration;
export let TaggedTemplateExpression: Type<TaggedTemplateExpression>;
export let assertTaggedTemplateExpression: (
  x: unknown
) => asserts x is TaggedTemplateExpression;
export let TemplateLiteral: Type<TemplateLiteral>;
export let assertTemplateLiteral: (x: unknown) => asserts x is TemplateLiteral;
export let TemplateElement: Type<TemplateElement>;
export let assertTemplateElement: (x: unknown) => asserts x is TemplateElement;
export let MetaProperty: Type<MetaProperty>;
export let assertMetaProperty: (x: unknown) => asserts x is MetaProperty;
export let Noop: Type<Noop>;
export let assertNoop: (x: unknown) => asserts x is Noop;
export let DoExpression: Type<DoExpression>;
export let assertDoExpression: (x: unknown) => asserts x is DoExpression;
export let BindExpression: Type<BindExpression>;
export let assertBindExpression: (x: unknown) => asserts x is BindExpression;
export let ParenthesizedExpression: Type<ParenthesizedExpression>;
export let assertParenthesizedExpression: (
  x: unknown
) => asserts x is ParenthesizedExpression;
export let ExportNamespaceSpecifier: Type<ExportNamespaceSpecifier>;
export let assertExportNamespaceSpecifier: (
  x: unknown
) => asserts x is ExportNamespaceSpecifier;
export let ExportDefaultSpecifier: Type<ExportDefaultSpecifier>;
export let assertExportDefaultSpecifier: (
  x: unknown
) => asserts x is ExportDefaultSpecifier;
export let CommentBlock: Type<CommentBlock>;
export let assertCommentBlock: (x: unknown) => asserts x is CommentBlock;
export let CommentLine: Type<CommentLine>;
export let assertCommentLine: (x: unknown) => asserts x is CommentLine;
export let Directive: Type<Directive>;
export let assertDirective: (x: unknown) => asserts x is Directive;
export let DirectiveLiteral: Type<DirectiveLiteral>;
export let assertDirectiveLiteral: (
  x: unknown
) => asserts x is DirectiveLiteral;
export let InterpreterDirective: Type<InterpreterDirective>;
export let assertInterpreterDirective: (
  x: unknown
) => asserts x is InterpreterDirective;
export let StringLiteral: Type<StringLiteral>;
export let assertStringLiteral: (x: unknown) => asserts x is StringLiteral;
export let NumericLiteral: Type<NumericLiteral>;
export let assertNumericLiteral: (x: unknown) => asserts x is NumericLiteral;
export let BigIntLiteral: Type<BigIntLiteral>;
export let assertBigIntLiteral: (x: unknown) => asserts x is BigIntLiteral;
export let NullLiteral: Type<NullLiteral>;
export let assertNullLiteral: (x: unknown) => asserts x is NullLiteral;
export let BooleanLiteral: Type<BooleanLiteral>;
export let assertBooleanLiteral: (x: unknown) => asserts x is BooleanLiteral;
export let RegExpLiteral: Type<RegExpLiteral>;
export let assertRegExpLiteral: (x: unknown) => asserts x is RegExpLiteral;
export let ObjectMethod: Type<ObjectMethod>;
export let assertObjectMethod: (x: unknown) => asserts x is ObjectMethod;
export let ClassMethod: Type<ClassMethod>;
export let assertClassMethod: (x: unknown) => asserts x is ClassMethod;
export let ClassPrivateMethod: Type<ClassPrivateMethod>;
export let assertClassPrivateMethod: (
  x: unknown
) => asserts x is ClassPrivateMethod;
export let ForAwaitStatement: Type<ForAwaitStatement>;
export let assertForAwaitStatement: (
  x: unknown
) => asserts x is ForAwaitStatement;
export let Import: Type<Import>;
export let assertImport: (x: unknown) => asserts x is Import;
export let TSTypeAnnotation: Type<TSTypeAnnotation>;
export let assertTSTypeAnnotation: (
  x: unknown
) => asserts x is TSTypeAnnotation;
export let TSTypeParameterDeclaration: Type<TSTypeParameterDeclaration>;
export let assertTSTypeParameterDeclaration: (
  x: unknown
) => asserts x is TSTypeParameterDeclaration;
export let TSTypeParameterInstantiation: Type<TSTypeParameterInstantiation>;
export let assertTSTypeParameterInstantiation: (
  x: unknown
) => asserts x is TSTypeParameterInstantiation;
export let TSHasOptionalTypeParameterInstantiation: Type<TSHasOptionalTypeParameterInstantiation>;
export let assertTSHasOptionalTypeParameterInstantiation: (
  x: unknown
) => asserts x is TSHasOptionalTypeParameterInstantiation;
export let TSType: Type<TSType>;
export let assertTSType: (x: unknown) => asserts x is TSType;
export let TSExpressionWithTypeArguments: Type<TSExpressionWithTypeArguments>;
export let assertTSExpressionWithTypeArguments: (
  x: unknown
) => asserts x is TSExpressionWithTypeArguments;
export let TSQualifiedName: Type<TSQualifiedName>;
export let assertTSQualifiedName: (x: unknown) => asserts x is TSQualifiedName;
export let TSTypeReference: Type<TSTypeReference>;
export let assertTSTypeReference: (x: unknown) => asserts x is TSTypeReference;
export let TSHasOptionalTypeParameters: Type<TSHasOptionalTypeParameters>;
export let assertTSHasOptionalTypeParameters: (
  x: unknown
) => asserts x is TSHasOptionalTypeParameters;
export let TSHasOptionalTypeAnnotation: Type<TSHasOptionalTypeAnnotation>;
export let assertTSHasOptionalTypeAnnotation: (
  x: unknown
) => asserts x is TSHasOptionalTypeAnnotation;
export let TSAsExpression: Type<TSAsExpression>;
export let assertTSAsExpression: (x: unknown) => asserts x is TSAsExpression;
export let TSNonNullExpression: Type<TSNonNullExpression>;
export let assertTSNonNullExpression: (
  x: unknown
) => asserts x is TSNonNullExpression;
export let TSAnyKeyword: Type<TSAnyKeyword>;
export let assertTSAnyKeyword: (x: unknown) => asserts x is TSAnyKeyword;
export let TSBigIntKeyword: Type<TSBigIntKeyword>;
export let assertTSBigIntKeyword: (x: unknown) => asserts x is TSBigIntKeyword;
export let TSBooleanKeyword: Type<TSBooleanKeyword>;
export let assertTSBooleanKeyword: (
  x: unknown
) => asserts x is TSBooleanKeyword;
export let TSNeverKeyword: Type<TSNeverKeyword>;
export let assertTSNeverKeyword: (x: unknown) => asserts x is TSNeverKeyword;
export let TSNullKeyword: Type<TSNullKeyword>;
export let assertTSNullKeyword: (x: unknown) => asserts x is TSNullKeyword;
export let TSNumberKeyword: Type<TSNumberKeyword>;
export let assertTSNumberKeyword: (x: unknown) => asserts x is TSNumberKeyword;
export let TSObjectKeyword: Type<TSObjectKeyword>;
export let assertTSObjectKeyword: (x: unknown) => asserts x is TSObjectKeyword;
export let TSStringKeyword: Type<TSStringKeyword>;
export let assertTSStringKeyword: (x: unknown) => asserts x is TSStringKeyword;
export let TSSymbolKeyword: Type<TSSymbolKeyword>;
export let assertTSSymbolKeyword: (x: unknown) => asserts x is TSSymbolKeyword;
export let TSUndefinedKeyword: Type<TSUndefinedKeyword>;
export let assertTSUndefinedKeyword: (
  x: unknown
) => asserts x is TSUndefinedKeyword;
export let TSUnknownKeyword: Type<TSUnknownKeyword>;
export let assertTSUnknownKeyword: (
  x: unknown
) => asserts x is TSUnknownKeyword;
export let TSVoidKeyword: Type<TSVoidKeyword>;
export let assertTSVoidKeyword: (x: unknown) => asserts x is TSVoidKeyword;
export let TSThisType: Type<TSThisType>;
export let assertTSThisType: (x: unknown) => asserts x is TSThisType;
export let TSArrayType: Type<TSArrayType>;
export let assertTSArrayType: (x: unknown) => asserts x is TSArrayType;
export let TSLiteralType: Type<TSLiteralType>;
export let assertTSLiteralType: (x: unknown) => asserts x is TSLiteralType;
export let TSUnionType: Type<TSUnionType>;
export let assertTSUnionType: (x: unknown) => asserts x is TSUnionType;
export let TSIntersectionType: Type<TSIntersectionType>;
export let assertTSIntersectionType: (
  x: unknown
) => asserts x is TSIntersectionType;
export let TSConditionalType: Type<TSConditionalType>;
export let assertTSConditionalType: (
  x: unknown
) => asserts x is TSConditionalType;
export let TSInferType: Type<TSInferType>;
export let assertTSInferType: (x: unknown) => asserts x is TSInferType;
export let TSTypeParameter: Type<TSTypeParameter>;
export let assertTSTypeParameter: (x: unknown) => asserts x is TSTypeParameter;
export let TSParenthesizedType: Type<TSParenthesizedType>;
export let assertTSParenthesizedType: (
  x: unknown
) => asserts x is TSParenthesizedType;
export let TSFunctionType: Type<TSFunctionType>;
export let assertTSFunctionType: (x: unknown) => asserts x is TSFunctionType;
export let TSConstructorType: Type<TSConstructorType>;
export let assertTSConstructorType: (
  x: unknown
) => asserts x is TSConstructorType;
export let TSDeclareFunction: Type<TSDeclareFunction>;
export let assertTSDeclareFunction: (
  x: unknown
) => asserts x is TSDeclareFunction;
export let TSDeclareMethod: Type<TSDeclareMethod>;
export let assertTSDeclareMethod: (x: unknown) => asserts x is TSDeclareMethod;
export let TSMappedType: Type<TSMappedType>;
export let assertTSMappedType: (x: unknown) => asserts x is TSMappedType;
export let TSTupleType: Type<TSTupleType>;
export let assertTSTupleType: (x: unknown) => asserts x is TSTupleType;
export let TSNamedTupleMember: Type<TSNamedTupleMember>;
export let assertTSNamedTupleMember: (
  x: unknown
) => asserts x is TSNamedTupleMember;
export let TSRestType: Type<TSRestType>;
export let assertTSRestType: (x: unknown) => asserts x is TSRestType;
export let TSOptionalType: Type<TSOptionalType>;
export let assertTSOptionalType: (x: unknown) => asserts x is TSOptionalType;
export let TSIndexedAccessType: Type<TSIndexedAccessType>;
export let assertTSIndexedAccessType: (
  x: unknown
) => asserts x is TSIndexedAccessType;
export let TSTypeOperator: Type<TSTypeOperator>;
export let assertTSTypeOperator: (x: unknown) => asserts x is TSTypeOperator;
export let TSTypeElement: Type<TSTypeElement>;
export let assertTSTypeElement: (x: unknown) => asserts x is TSTypeElement;
export let TSIndexSignature: Type<TSIndexSignature>;
export let assertTSIndexSignature: (
  x: unknown
) => asserts x is TSIndexSignature;
export let TSPropertySignature: Type<TSPropertySignature>;
export let assertTSPropertySignature: (
  x: unknown
) => asserts x is TSPropertySignature;
export let TSMethodSignature: Type<TSMethodSignature>;
export let assertTSMethodSignature: (
  x: unknown
) => asserts x is TSMethodSignature;
export let TSTypePredicate: Type<TSTypePredicate>;
export let assertTSTypePredicate: (x: unknown) => asserts x is TSTypePredicate;
export let TSCallSignatureDeclaration: Type<TSCallSignatureDeclaration>;
export let assertTSCallSignatureDeclaration: (
  x: unknown
) => asserts x is TSCallSignatureDeclaration;
export let TSConstructSignatureDeclaration: Type<TSConstructSignatureDeclaration>;
export let assertTSConstructSignatureDeclaration: (
  x: unknown
) => asserts x is TSConstructSignatureDeclaration;
export let TSEnumMember: Type<TSEnumMember>;
export let assertTSEnumMember: (x: unknown) => asserts x is TSEnumMember;
export let TSTypeQuery: Type<TSTypeQuery>;
export let assertTSTypeQuery: (x: unknown) => asserts x is TSTypeQuery;
export let TSImportType: Type<TSImportType>;
export let assertTSImportType: (x: unknown) => asserts x is TSImportType;
export let TSTypeLiteral: Type<TSTypeLiteral>;
export let assertTSTypeLiteral: (x: unknown) => asserts x is TSTypeLiteral;
export let TSTypeAssertion: Type<TSTypeAssertion>;
export let assertTSTypeAssertion: (x: unknown) => asserts x is TSTypeAssertion;
export let TSEnumDeclaration: Type<TSEnumDeclaration>;
export let assertTSEnumDeclaration: (
  x: unknown
) => asserts x is TSEnumDeclaration;
export let TSTypeAliasDeclaration: Type<TSTypeAliasDeclaration>;
export let assertTSTypeAliasDeclaration: (
  x: unknown
) => asserts x is TSTypeAliasDeclaration;
export let TSModuleBlock: Type<TSModuleBlock>;
export let assertTSModuleBlock: (x: unknown) => asserts x is TSModuleBlock;
export let TSModuleDeclaration: Type<TSModuleDeclaration>;
export let assertTSModuleDeclaration: (
  x: unknown
) => asserts x is TSModuleDeclaration;
export let TSImportEqualsDeclaration: Type<TSImportEqualsDeclaration>;
export let assertTSImportEqualsDeclaration: (
  x: unknown
) => asserts x is TSImportEqualsDeclaration;
export let TSExternalModuleReference: Type<TSExternalModuleReference>;
export let assertTSExternalModuleReference: (
  x: unknown
) => asserts x is TSExternalModuleReference;
export let TSExportAssignment: Type<TSExportAssignment>;
export let assertTSExportAssignment: (
  x: unknown
) => asserts x is TSExportAssignment;
export let TSNamespaceExportDeclaration: Type<TSNamespaceExportDeclaration>;
export let assertTSNamespaceExportDeclaration: (
  x: unknown
) => asserts x is TSNamespaceExportDeclaration;
export let TSInterfaceBody: Type<TSInterfaceBody>;
export let assertTSInterfaceBody: (x: unknown) => asserts x is TSInterfaceBody;
export let TSInterfaceDeclaration: Type<TSInterfaceDeclaration>;
export let assertTSInterfaceDeclaration: (
  x: unknown
) => asserts x is TSInterfaceDeclaration;
export let TSParameterProperty: Type<TSParameterProperty>;
export let assertTSParameterProperty: (
  x: unknown
) => asserts x is TSParameterProperty;
