// !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!!
import { NodePath } from "../lib/node-path";
import { Context } from "../lib/path-visitor";
import { namedTypes } from "./namedTypes";
export interface Visitor<M = Record<string, any>> {
  reset?(this: Context<M>, path: NodePath, state: M): any;
  visitNode?(this: Context<M>, path: NodePath<namedTypes.Node>, state: M): any;
  visitBaseNode?(
    this: Context<M>,
    path: NodePath<namedTypes.BaseNode>,
    state: M
  ): any;
  visitExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.Expression>,
    state: M
  ): any;
  visitAwaitExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.AwaitExpression>,
    state: M
  ): any;
  visitDecorator?(
    this: Context<M>,
    path: NodePath<namedTypes.Decorator>,
    state: M
  ): any;
  visitProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.Property>,
    state: M
  ): any;
  visitStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.Statement>,
    state: M
  ): any;
  visitDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.Declaration>,
    state: M
  ): any;
  visitMethodDefinition?(
    this: Context<M>,
    path: NodePath<namedTypes.MethodDefinition>,
    state: M
  ): any;
  visitPrivateName?(
    this: Context<M>,
    path: NodePath<namedTypes.PrivateName>,
    state: M
  ): any;
  visitPatternLike?(
    this: Context<M>,
    path: NodePath<namedTypes.PatternLike>,
    state: M
  ): any;
  visitLVal?(this: Context<M>, path: NodePath<namedTypes.LVal>, state: M): any;
  visitIdentifier?(
    this: Context<M>,
    path: NodePath<namedTypes.Identifier>,
    state: M
  ): any;
  visitClassPrivateProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassPrivateProperty>,
    state: M
  ): any;
  visitComment?(
    this: Context<M>,
    path: NodePath<namedTypes.Comment>,
    state: M
  ): any;
  visitSourceLocation?(
    this: Context<M>,
    path: NodePath<namedTypes.SourceLocation>,
    state: M
  ): any;
  visitPosition?(
    this: Context<M>,
    path: NodePath<namedTypes.Position>,
    state: M
  ): any;
  visitFile?(this: Context<M>, path: NodePath<namedTypes.File>, state: M): any;
  visitScopable?(
    this: Context<M>,
    path: NodePath<namedTypes.Scopable>,
    state: M
  ): any;
  visitBlockParent?(
    this: Context<M>,
    path: NodePath<namedTypes.BlockParent>,
    state: M
  ): any;
  visitProgram?(
    this: Context<M>,
    path: NodePath<namedTypes.Program>,
    state: M
  ): any;
  visitFunction?(
    this: Context<M>,
    path: NodePath<namedTypes.Function>,
    state: M
  ): any;
  visitFunctionParent?(
    this: Context<M>,
    path: NodePath<namedTypes.FunctionParent>,
    state: M
  ): any;
  visitBaseFunction?(
    this: Context<M>,
    path: NodePath<namedTypes.BaseFunction>,
    state: M
  ): any;
  visitBlockStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.BlockStatement>,
    state: M
  ): any;
  visitEmptyStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.EmptyStatement>,
    state: M
  ): any;
  visitExpressionStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ExpressionStatement>,
    state: M
  ): any;
  visitConditional?(
    this: Context<M>,
    path: NodePath<namedTypes.Conditional>,
    state: M
  ): any;
  visitIfStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.IfStatement>,
    state: M
  ): any;
  visitLabeledStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.LabeledStatement>,
    state: M
  ): any;
  visitCompletionStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.CompletionStatement>,
    state: M
  ): any;
  visitBreakStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.BreakStatement>,
    state: M
  ): any;
  visitContinueStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ContinueStatement>,
    state: M
  ): any;
  visitWithStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.WithStatement>,
    state: M
  ): any;
  visitSwitchStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.SwitchStatement>,
    state: M
  ): any;
  visitSwitchCase?(
    this: Context<M>,
    path: NodePath<namedTypes.SwitchCase>,
    state: M
  ): any;
  visitReturnStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ReturnStatement>,
    state: M
  ): any;
  visitThrowStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ThrowStatement>,
    state: M
  ): any;
  visitTryStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.TryStatement>,
    state: M
  ): any;
  visitCatchClause?(
    this: Context<M>,
    path: NodePath<namedTypes.CatchClause>,
    state: M
  ): any;
  visitLoop?(this: Context<M>, path: NodePath<namedTypes.Loop>, state: M): any;
  visitWhile?(
    this: Context<M>,
    path: NodePath<namedTypes.While>,
    state: M
  ): any;
  visitFor?(this: Context<M>, path: NodePath<namedTypes.For>, state: M): any;
  visitForX?(this: Context<M>, path: NodePath<namedTypes.ForX>, state: M): any;
  visitWhileStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.WhileStatement>,
    state: M
  ): any;
  visitDoWhileStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.DoWhileStatement>,
    state: M
  ): any;
  visitForStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ForStatement>,
    state: M
  ): any;
  visitVariableDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.VariableDeclaration>,
    state: M
  ): any;
  visitForInStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ForInStatement>,
    state: M
  ): any;
  visitDebuggerStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.DebuggerStatement>,
    state: M
  ): any;
  visitPureish?(
    this: Context<M>,
    path: NodePath<namedTypes.Pureish>,
    state: M
  ): any;
  visitFunctionDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.FunctionDeclaration>,
    state: M
  ): any;
  visitFunctionExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.FunctionExpression>,
    state: M
  ): any;
  visitVariableDeclarator?(
    this: Context<M>,
    path: NodePath<namedTypes.VariableDeclarator>,
    state: M
  ): any;
  visitThisExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ThisExpression>,
    state: M
  ): any;
  visitArrayExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ArrayExpression>,
    state: M
  ): any;
  visitObjectExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectExpression>,
    state: M
  ): any;
  visitLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.Literal>,
    state: M
  ): any;
  visitSequenceExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.SequenceExpression>,
    state: M
  ): any;
  visitUnaryExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.UnaryExpression>,
    state: M
  ): any;
  visitBinary?(
    this: Context<M>,
    path: NodePath<namedTypes.Binary>,
    state: M
  ): any;
  visitBinaryExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.BinaryExpression>,
    state: M
  ): any;
  visitAssignmentExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.AssignmentExpression>,
    state: M
  ): any;
  visitUpdateExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.UpdateExpression>,
    state: M
  ): any;
  visitLogicalExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.LogicalExpression>,
    state: M
  ): any;
  visitConditionalExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ConditionalExpression>,
    state: M
  ): any;
  visitNewExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.NewExpression>,
    state: M
  ): any;
  visitCallExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.CallExpression>,
    state: M
  ): any;
  visitMemberExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.MemberExpression>,
    state: M
  ): any;
  visitPattern?(
    this: Context<M>,
    path: NodePath<namedTypes.Pattern>,
    state: M
  ): any;
  visitBaseComment?(
    this: Context<M>,
    path: NodePath<namedTypes.BaseComment>,
    state: M
  ): any;
  visitRestElement?(
    this: Context<M>,
    path: NodePath<namedTypes.RestElement>,
    state: M
  ): any;
  visitArrowFunctionExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ArrowFunctionExpression>,
    state: M
  ): any;
  visitForOfStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ForOfStatement>,
    state: M
  ): any;
  visitYieldExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.YieldExpression>,
    state: M
  ): any;
  visitGeneratorExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.GeneratorExpression>,
    state: M
  ): any;
  visitComprehensionBlock?(
    this: Context<M>,
    path: NodePath<namedTypes.ComprehensionBlock>,
    state: M
  ): any;
  visitComprehensionExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ComprehensionExpression>,
    state: M
  ): any;
  visitObjectProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectProperty>,
    state: M
  ): any;
  visitArrayPattern?(
    this: Context<M>,
    path: NodePath<namedTypes.ArrayPattern>,
    state: M
  ): any;
  visitObjectPattern?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectPattern>,
    state: M
  ): any;
  visitSpreadElement?(
    this: Context<M>,
    path: NodePath<namedTypes.SpreadElement>,
    state: M
  ): any;
  visitAssignmentPattern?(
    this: Context<M>,
    path: NodePath<namedTypes.AssignmentPattern>,
    state: M
  ): any;
  visitClassPropertyDefinition?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassPropertyDefinition>,
    state: M
  ): any;
  visitClassProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassProperty>,
    state: M
  ): any;
  visitClassBody?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassBody>,
    state: M
  ): any;
  visitClass?(
    this: Context<M>,
    path: NodePath<namedTypes.Class>,
    state: M
  ): any;
  visitClassDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassDeclaration>,
    state: M
  ): any;
  visitClassExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassExpression>,
    state: M
  ): any;
  visitSuper?(
    this: Context<M>,
    path: NodePath<namedTypes.Super>,
    state: M
  ): any;
  visitSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.Specifier>,
    state: M
  ): any;
  visitModuleSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ModuleSpecifier>,
    state: M
  ): any;
  visitImportSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ImportSpecifier>,
    state: M
  ): any;
  visitImportDefaultSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ImportDefaultSpecifier>,
    state: M
  ): any;
  visitImportNamespaceSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ImportNamespaceSpecifier>,
    state: M
  ): any;
  visitImportDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.ImportDeclaration>,
    state: M
  ): any;
  visitExportNamedDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportNamedDeclaration>,
    state: M
  ): any;
  visitExportSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportSpecifier>,
    state: M
  ): any;
  visitExportDefaultDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportDefaultDeclaration>,
    state: M
  ): any;
  visitExportAllDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportAllDeclaration>,
    state: M
  ): any;
  visitTaggedTemplateExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.TaggedTemplateExpression>,
    state: M
  ): any;
  visitTemplateLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.TemplateLiteral>,
    state: M
  ): any;
  visitTemplateElement?(
    this: Context<M>,
    path: NodePath<namedTypes.TemplateElement>,
    state: M
  ): any;
  visitMetaProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.MetaProperty>,
    state: M
  ): any;
  visitExportBatchSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportBatchSpecifier>,
    state: M
  ): any;
  visitExportDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportDeclaration>,
    state: M
  ): any;
  visitBlock?(
    this: Context<M>,
    path: NodePath<namedTypes.Block>,
    state: M
  ): any;
  visitLine?(this: Context<M>, path: NodePath<namedTypes.Line>, state: M): any;
  visitNoop?(this: Context<M>, path: NodePath<namedTypes.Noop>, state: M): any;
  visitDoExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.DoExpression>,
    state: M
  ): any;
  visitBindExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.BindExpression>,
    state: M
  ): any;
  visitParenthesizedExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ParenthesizedExpression>,
    state: M
  ): any;
  visitExportNamespaceSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportNamespaceSpecifier>,
    state: M
  ): any;
  visitExportDefaultSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportDefaultSpecifier>,
    state: M
  ): any;
  visitCommentBlock?(
    this: Context<M>,
    path: NodePath<namedTypes.CommentBlock>,
    state: M
  ): any;
  visitCommentLine?(
    this: Context<M>,
    path: NodePath<namedTypes.CommentLine>,
    state: M
  ): any;
  visitDirective?(
    this: Context<M>,
    path: NodePath<namedTypes.Directive>,
    state: M
  ): any;
  visitDirectiveLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.DirectiveLiteral>,
    state: M
  ): any;
  visitInterpreterDirective?(
    this: Context<M>,
    path: NodePath<namedTypes.InterpreterDirective>,
    state: M
  ): any;
  visitStringLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.StringLiteral>,
    state: M
  ): any;
  visitNumericLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.NumericLiteral>,
    state: M
  ): any;
  visitBigIntLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.BigIntLiteral>,
    state: M
  ): any;
  visitNullLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.NullLiteral>,
    state: M
  ): any;
  visitBooleanLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.BooleanLiteral>,
    state: M
  ): any;
  visitRegExpLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.RegExpLiteral>,
    state: M
  ): any;
  visitObjectMethod?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectMethod>,
    state: M
  ): any;
  visitClassMethod?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassMethod>,
    state: M
  ): any;
  visitClassPrivateMethod?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassPrivateMethod>,
    state: M
  ): any;
  visitForAwaitStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ForAwaitStatement>,
    state: M
  ): any;
  visitImport?(
    this: Context<M>,
    path: NodePath<namedTypes.Import>,
    state: M
  ): any;
  visitTSTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeAnnotation>,
    state: M
  ): any;
  visitTSTypeParameterDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeParameterDeclaration>,
    state: M
  ): any;
  visitTSTypeParameterInstantiation?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeParameterInstantiation>,
    state: M
  ): any;
  visitTSHasOptionalTypeParameterInstantiation?(
    this: Context<M>,
    path: NodePath<namedTypes.TSHasOptionalTypeParameterInstantiation>,
    state: M
  ): any;
  visitTSType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSType>,
    state: M
  ): any;
  visitTSExpressionWithTypeArguments?(
    this: Context<M>,
    path: NodePath<namedTypes.TSExpressionWithTypeArguments>,
    state: M
  ): any;
  visitTSQualifiedName?(
    this: Context<M>,
    path: NodePath<namedTypes.TSQualifiedName>,
    state: M
  ): any;
  visitTSTypeReference?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeReference>,
    state: M
  ): any;
  visitTSHasOptionalTypeParameters?(
    this: Context<M>,
    path: NodePath<namedTypes.TSHasOptionalTypeParameters>,
    state: M
  ): any;
  visitTSHasOptionalTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.TSHasOptionalTypeAnnotation>,
    state: M
  ): any;
  visitTSAsExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.TSAsExpression>,
    state: M
  ): any;
  visitTSNonNullExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.TSNonNullExpression>,
    state: M
  ): any;
  visitTSAnyKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSAnyKeyword>,
    state: M
  ): any;
  visitTSBigIntKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSBigIntKeyword>,
    state: M
  ): any;
  visitTSBooleanKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSBooleanKeyword>,
    state: M
  ): any;
  visitTSNeverKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSNeverKeyword>,
    state: M
  ): any;
  visitTSNullKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSNullKeyword>,
    state: M
  ): any;
  visitTSNumberKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSNumberKeyword>,
    state: M
  ): any;
  visitTSObjectKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSObjectKeyword>,
    state: M
  ): any;
  visitTSStringKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSStringKeyword>,
    state: M
  ): any;
  visitTSSymbolKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSSymbolKeyword>,
    state: M
  ): any;
  visitTSUndefinedKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSUndefinedKeyword>,
    state: M
  ): any;
  visitTSUnknownKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSUnknownKeyword>,
    state: M
  ): any;
  visitTSVoidKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSVoidKeyword>,
    state: M
  ): any;
  visitTSThisType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSThisType>,
    state: M
  ): any;
  visitTSArrayType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSArrayType>,
    state: M
  ): any;
  visitTSLiteralType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSLiteralType>,
    state: M
  ): any;
  visitTSUnionType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSUnionType>,
    state: M
  ): any;
  visitTSIntersectionType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSIntersectionType>,
    state: M
  ): any;
  visitTSConditionalType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSConditionalType>,
    state: M
  ): any;
  visitTSInferType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSInferType>,
    state: M
  ): any;
  visitTSTypeParameter?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeParameter>,
    state: M
  ): any;
  visitTSParenthesizedType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSParenthesizedType>,
    state: M
  ): any;
  visitTSFunctionType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSFunctionType>,
    state: M
  ): any;
  visitTSConstructorType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSConstructorType>,
    state: M
  ): any;
  visitTSDeclareFunction?(
    this: Context<M>,
    path: NodePath<namedTypes.TSDeclareFunction>,
    state: M
  ): any;
  visitTSDeclareMethod?(
    this: Context<M>,
    path: NodePath<namedTypes.TSDeclareMethod>,
    state: M
  ): any;
  visitTSMappedType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSMappedType>,
    state: M
  ): any;
  visitTSTupleType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTupleType>,
    state: M
  ): any;
  visitTSNamedTupleMember?(
    this: Context<M>,
    path: NodePath<namedTypes.TSNamedTupleMember>,
    state: M
  ): any;
  visitTSRestType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSRestType>,
    state: M
  ): any;
  visitTSOptionalType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSOptionalType>,
    state: M
  ): any;
  visitTSIndexedAccessType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSIndexedAccessType>,
    state: M
  ): any;
  visitTSTypeOperator?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeOperator>,
    state: M
  ): any;
  visitTSTypeElement?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeElement>,
    state: M
  ): any;
  visitTSIndexSignature?(
    this: Context<M>,
    path: NodePath<namedTypes.TSIndexSignature>,
    state: M
  ): any;
  visitTSPropertySignature?(
    this: Context<M>,
    path: NodePath<namedTypes.TSPropertySignature>,
    state: M
  ): any;
  visitTSMethodSignature?(
    this: Context<M>,
    path: NodePath<namedTypes.TSMethodSignature>,
    state: M
  ): any;
  visitTSTypePredicate?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypePredicate>,
    state: M
  ): any;
  visitTSCallSignatureDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSCallSignatureDeclaration>,
    state: M
  ): any;
  visitTSConstructSignatureDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSConstructSignatureDeclaration>,
    state: M
  ): any;
  visitTSEnumMember?(
    this: Context<M>,
    path: NodePath<namedTypes.TSEnumMember>,
    state: M
  ): any;
  visitTSTypeQuery?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeQuery>,
    state: M
  ): any;
  visitTSImportType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSImportType>,
    state: M
  ): any;
  visitTSTypeLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeLiteral>,
    state: M
  ): any;
  visitTSTypeAssertion?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeAssertion>,
    state: M
  ): any;
  visitTSEnumDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSEnumDeclaration>,
    state: M
  ): any;
  visitTSTypeAliasDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeAliasDeclaration>,
    state: M
  ): any;
  visitTSModuleBlock?(
    this: Context<M>,
    path: NodePath<namedTypes.TSModuleBlock>,
    state: M
  ): any;
  visitTSModuleDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSModuleDeclaration>,
    state: M
  ): any;
  visitTSImportEqualsDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSImportEqualsDeclaration>,
    state: M
  ): any;
  visitTSExternalModuleReference?(
    this: Context<M>,
    path: NodePath<namedTypes.TSExternalModuleReference>,
    state: M
  ): any;
  visitTSExportAssignment?(
    this: Context<M>,
    path: NodePath<namedTypes.TSExportAssignment>,
    state: M
  ): any;
  visitTSNamespaceExportDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSNamespaceExportDeclaration>,
    state: M
  ): any;
  visitTSInterfaceBody?(
    this: Context<M>,
    path: NodePath<namedTypes.TSInterfaceBody>,
    state: M
  ): any;
  visitTSInterfaceDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSInterfaceDeclaration>,
    state: M
  ): any;
  visitTSParameterProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.TSParameterProperty>,
    state: M
  ): any;
}
