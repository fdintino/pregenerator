// !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!!
import { NodePath } from "../lib/node-path";
import { Context } from "../lib/path-visitor";
import { namedTypes } from "./namedTypes";
export interface Visitor<M = Record<string, any>> {
  reset?(this: Context<M>, path: NodePath, state: M): any;
  visitNode?(this: Context<M>, path: NodePath<namedTypes.Node>, state: M): any;
  visitBaseNode?(
    this: Context<M>,
    path: NodePath<namedTypes.BaseNode>,
    state: M
  ): any;
  visitExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.Expression>,
    state: M
  ): any;
  visitBinary?(
    this: Context<M>,
    path: NodePath<namedTypes.Binary>,
    state: M
  ): any;
  visitBinaryExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.BinaryExpression>,
    state: M
  ): any;
  visitAssignmentExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.AssignmentExpression>,
    state: M
  ): any;
  visitScopable?(
    this: Context<M>,
    path: NodePath<namedTypes.Scopable>,
    state: M
  ): any;
  visitBlockParent?(
    this: Context<M>,
    path: NodePath<namedTypes.BlockParent>,
    state: M
  ): any;
  visitFunction?(
    this: Context<M>,
    path: NodePath<namedTypes.Function>,
    state: M
  ): any;
  visitBaseFunction?(
    this: Context<M>,
    path: NodePath<namedTypes.BaseFunction>,
    state: M
  ): any;
  visitAwaitExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.AwaitExpression>,
    state: M
  ): any;
  visitStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.Statement>,
    state: M
  ): any;
  visitLoop?(this: Context<M>, path: NodePath<namedTypes.Loop>, state: M): any;
  visitFor?(this: Context<M>, path: NodePath<namedTypes.For>, state: M): any;
  visitForX?(this: Context<M>, path: NodePath<namedTypes.ForX>, state: M): any;
  visitForOfStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ForOfStatement>,
    state: M
  ): any;
  visitObjectExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectExpression>,
    state: M
  ): any;
  visitFunctionParent?(
    this: Context<M>,
    path: NodePath<namedTypes.FunctionParent>,
    state: M
  ): any;
  visitObjectMethod?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectMethod>,
    state: M
  ): any;
  visitObjectProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectProperty>,
    state: M
  ): any;
  visitSpreadElement?(
    this: Context<M>,
    path: NodePath<namedTypes.SpreadElement>,
    state: M
  ): any;
  visitTemplateElement?(
    this: Context<M>,
    path: NodePath<namedTypes.TemplateElement>,
    state: M
  ): any;
  visitCatchClause?(
    this: Context<M>,
    path: NodePath<namedTypes.CatchClause>,
    state: M
  ): any;
  visitPatternLike?(
    this: Context<M>,
    path: NodePath<namedTypes.PatternLike>,
    state: M
  ): any;
  visitLVal?(this: Context<M>, path: NodePath<namedTypes.LVal>, state: M): any;
  visitIdentifier?(
    this: Context<M>,
    path: NodePath<namedTypes.Identifier>,
    state: M
  ): any;
  visitPattern?(
    this: Context<M>,
    path: NodePath<namedTypes.Pattern>,
    state: M
  ): any;
  visitArrayPattern?(
    this: Context<M>,
    path: NodePath<namedTypes.ArrayPattern>,
    state: M
  ): any;
  visitObjectPattern?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectPattern>,
    state: M
  ): any;
  visitImportExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ImportExpression>,
    state: M
  ): any;
  visitDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.Declaration>,
    state: M
  ): any;
  visitExportAllDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportAllDeclaration>,
    state: M
  ): any;
  visitPureish?(
    this: Context<M>,
    path: NodePath<namedTypes.Pureish>,
    state: M
  ): any;
  visitLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.Literal>,
    state: M
  ): any;
  visitChainElement?(
    this: Context<M>,
    path: NodePath<namedTypes.ChainElement>,
    state: M
  ): any;
  visitCallExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.CallExpression>,
    state: M
  ): any;
  visitMemberExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.MemberExpression>,
    state: M
  ): any;
  visitChainExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ChainExpression>,
    state: M
  ): any;
  visitOptionalCallExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.OptionalCallExpression>,
    state: M
  ): any;
  visitOptionalMemberExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.OptionalMemberExpression>,
    state: M
  ): any;
  visitLogicalExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.LogicalExpression>,
    state: M
  ): any;
  visitDecorator?(
    this: Context<M>,
    path: NodePath<namedTypes.Decorator>,
    state: M
  ): any;
  visitProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.Property>,
    state: M
  ): any;
  visitMethodDefinition?(
    this: Context<M>,
    path: NodePath<namedTypes.MethodDefinition>,
    state: M
  ): any;
  visitPrivateName?(
    this: Context<M>,
    path: NodePath<namedTypes.PrivateName>,
    state: M
  ): any;
  visitClassPrivateProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassPrivateProperty>,
    state: M
  ): any;
  visitComment?(
    this: Context<M>,
    path: NodePath<namedTypes.Comment>,
    state: M
  ): any;
  visitSourceLocation?(
    this: Context<M>,
    path: NodePath<namedTypes.SourceLocation>,
    state: M
  ): any;
  visitPosition?(
    this: Context<M>,
    path: NodePath<namedTypes.Position>,
    state: M
  ): any;
  visitFile?(this: Context<M>, path: NodePath<namedTypes.File>, state: M): any;
  visitProgram?(
    this: Context<M>,
    path: NodePath<namedTypes.Program>,
    state: M
  ): any;
  visitBlockStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.BlockStatement>,
    state: M
  ): any;
  visitEmptyStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.EmptyStatement>,
    state: M
  ): any;
  visitExpressionStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ExpressionStatement>,
    state: M
  ): any;
  visitConditional?(
    this: Context<M>,
    path: NodePath<namedTypes.Conditional>,
    state: M
  ): any;
  visitIfStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.IfStatement>,
    state: M
  ): any;
  visitLabeledStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.LabeledStatement>,
    state: M
  ): any;
  visitCompletionStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.CompletionStatement>,
    state: M
  ): any;
  visitBreakStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.BreakStatement>,
    state: M
  ): any;
  visitContinueStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ContinueStatement>,
    state: M
  ): any;
  visitWithStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.WithStatement>,
    state: M
  ): any;
  visitSwitchStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.SwitchStatement>,
    state: M
  ): any;
  visitSwitchCase?(
    this: Context<M>,
    path: NodePath<namedTypes.SwitchCase>,
    state: M
  ): any;
  visitReturnStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ReturnStatement>,
    state: M
  ): any;
  visitThrowStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ThrowStatement>,
    state: M
  ): any;
  visitTryStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.TryStatement>,
    state: M
  ): any;
  visitWhile?(
    this: Context<M>,
    path: NodePath<namedTypes.While>,
    state: M
  ): any;
  visitWhileStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.WhileStatement>,
    state: M
  ): any;
  visitDoWhileStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.DoWhileStatement>,
    state: M
  ): any;
  visitForStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ForStatement>,
    state: M
  ): any;
  visitVariableDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.VariableDeclaration>,
    state: M
  ): any;
  visitForInStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ForInStatement>,
    state: M
  ): any;
  visitDebuggerStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.DebuggerStatement>,
    state: M
  ): any;
  visitFunctionDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.FunctionDeclaration>,
    state: M
  ): any;
  visitFunctionExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.FunctionExpression>,
    state: M
  ): any;
  visitVariableDeclarator?(
    this: Context<M>,
    path: NodePath<namedTypes.VariableDeclarator>,
    state: M
  ): any;
  visitThisExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ThisExpression>,
    state: M
  ): any;
  visitArrayExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ArrayExpression>,
    state: M
  ): any;
  visitSequenceExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.SequenceExpression>,
    state: M
  ): any;
  visitUnaryExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.UnaryExpression>,
    state: M
  ): any;
  visitUpdateExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.UpdateExpression>,
    state: M
  ): any;
  visitConditionalExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ConditionalExpression>,
    state: M
  ): any;
  visitNewExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.NewExpression>,
    state: M
  ): any;
  visitBaseComment?(
    this: Context<M>,
    path: NodePath<namedTypes.BaseComment>,
    state: M
  ): any;
  visitRestElement?(
    this: Context<M>,
    path: NodePath<namedTypes.RestElement>,
    state: M
  ): any;
  visitArrowFunctionExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ArrowFunctionExpression>,
    state: M
  ): any;
  visitYieldExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.YieldExpression>,
    state: M
  ): any;
  visitGeneratorExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.GeneratorExpression>,
    state: M
  ): any;
  visitComprehensionBlock?(
    this: Context<M>,
    path: NodePath<namedTypes.ComprehensionBlock>,
    state: M
  ): any;
  visitComprehensionExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ComprehensionExpression>,
    state: M
  ): any;
  visitAssignmentPattern?(
    this: Context<M>,
    path: NodePath<namedTypes.AssignmentPattern>,
    state: M
  ): any;
  visitClassPropertyDefinition?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassPropertyDefinition>,
    state: M
  ): any;
  visitClassProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassProperty>,
    state: M
  ): any;
  visitClassBody?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassBody>,
    state: M
  ): any;
  visitClass?(
    this: Context<M>,
    path: NodePath<namedTypes.Class>,
    state: M
  ): any;
  visitClassDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassDeclaration>,
    state: M
  ): any;
  visitClassExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassExpression>,
    state: M
  ): any;
  visitSuper?(
    this: Context<M>,
    path: NodePath<namedTypes.Super>,
    state: M
  ): any;
  visitSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.Specifier>,
    state: M
  ): any;
  visitModuleSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ModuleSpecifier>,
    state: M
  ): any;
  visitImportSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ImportSpecifier>,
    state: M
  ): any;
  visitImportDefaultSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ImportDefaultSpecifier>,
    state: M
  ): any;
  visitImportNamespaceSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ImportNamespaceSpecifier>,
    state: M
  ): any;
  visitImportDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.ImportDeclaration>,
    state: M
  ): any;
  visitExportNamedDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportNamedDeclaration>,
    state: M
  ): any;
  visitExportSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportSpecifier>,
    state: M
  ): any;
  visitExportDefaultDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportDefaultDeclaration>,
    state: M
  ): any;
  visitTaggedTemplateExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.TaggedTemplateExpression>,
    state: M
  ): any;
  visitTemplateLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.TemplateLiteral>,
    state: M
  ): any;
  visitMetaProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.MetaProperty>,
    state: M
  ): any;
  visitJSX?(this: Context<M>, path: NodePath<namedTypes.JSX>, state: M): any;
  visitJSXAttribute?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXAttribute>,
    state: M
  ): any;
  visitJSXIdentifier?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXIdentifier>,
    state: M
  ): any;
  visitJSXNamespacedName?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXNamespacedName>,
    state: M
  ): any;
  visitJSXExpressionContainer?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXExpressionContainer>,
    state: M
  ): any;
  visitJSXElement?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXElement>,
    state: M
  ): any;
  visitJSXFragment?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXFragment>,
    state: M
  ): any;
  visitJSXMemberExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXMemberExpression>,
    state: M
  ): any;
  visitJSXSpreadAttribute?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXSpreadAttribute>,
    state: M
  ): any;
  visitJSXEmptyExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXEmptyExpression>,
    state: M
  ): any;
  visitJSXText?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXText>,
    state: M
  ): any;
  visitJSXSpreadChild?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXSpreadChild>,
    state: M
  ): any;
  visitJSXOpeningElement?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXOpeningElement>,
    state: M
  ): any;
  visitJSXClosingElement?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXClosingElement>,
    state: M
  ): any;
  visitJSXOpeningFragment?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXOpeningFragment>,
    state: M
  ): any;
  visitJSXClosingFragment?(
    this: Context<M>,
    path: NodePath<namedTypes.JSXClosingFragment>,
    state: M
  ): any;
  visitTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.TypeAnnotation>,
    state: M
  ): any;
  visitTSTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeAnnotation>,
    state: M
  ): any;
  visitTypeParameterDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TypeParameterDeclaration>,
    state: M
  ): any;
  visitTSTypeParameterDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeParameterDeclaration>,
    state: M
  ): any;
  visitClassMethod?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassMethod>,
    state: M
  ): any;
  visitClassPrivateMethod?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassPrivateMethod>,
    state: M
  ): any;
  visitTypeParameterInstantiation?(
    this: Context<M>,
    path: NodePath<namedTypes.TypeParameterInstantiation>,
    state: M
  ): any;
  visitTSTypeParameterInstantiation?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeParameterInstantiation>,
    state: M
  ): any;
  visitClassImplements?(
    this: Context<M>,
    path: NodePath<namedTypes.ClassImplements>,
    state: M
  ): any;
  visitTSHasOptionalTypeParameterInstantiation?(
    this: Context<M>,
    path: NodePath<namedTypes.TSHasOptionalTypeParameterInstantiation>,
    state: M
  ): any;
  visitTSType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSType>,
    state: M
  ): any;
  visitTSExpressionWithTypeArguments?(
    this: Context<M>,
    path: NodePath<namedTypes.TSExpressionWithTypeArguments>,
    state: M
  ): any;
  visitFlow?(this: Context<M>, path: NodePath<namedTypes.Flow>, state: M): any;
  visitFlowType?(
    this: Context<M>,
    path: NodePath<namedTypes.FlowType>,
    state: M
  ): any;
  visitAnyTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.AnyTypeAnnotation>,
    state: M
  ): any;
  visitEmptyTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.EmptyTypeAnnotation>,
    state: M
  ): any;
  visitMixedTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.MixedTypeAnnotation>,
    state: M
  ): any;
  visitVoidTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.VoidTypeAnnotation>,
    state: M
  ): any;
  visitSymbolTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.SymbolTypeAnnotation>,
    state: M
  ): any;
  visitNumberTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.NumberTypeAnnotation>,
    state: M
  ): any;
  visitBigIntTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.BigIntTypeAnnotation>,
    state: M
  ): any;
  visitNumberLiteralTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.NumberLiteralTypeAnnotation>,
    state: M
  ): any;
  visitNumericLiteralTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.NumericLiteralTypeAnnotation>,
    state: M
  ): any;
  visitBigIntLiteralTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.BigIntLiteralTypeAnnotation>,
    state: M
  ): any;
  visitStringTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.StringTypeAnnotation>,
    state: M
  ): any;
  visitStringLiteralTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.StringLiteralTypeAnnotation>,
    state: M
  ): any;
  visitBooleanTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.BooleanTypeAnnotation>,
    state: M
  ): any;
  visitBooleanLiteralTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.BooleanLiteralTypeAnnotation>,
    state: M
  ): any;
  visitNullableTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.NullableTypeAnnotation>,
    state: M
  ): any;
  visitNullLiteralTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.NullLiteralTypeAnnotation>,
    state: M
  ): any;
  visitNullTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.NullTypeAnnotation>,
    state: M
  ): any;
  visitThisTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.ThisTypeAnnotation>,
    state: M
  ): any;
  visitExistsTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.ExistsTypeAnnotation>,
    state: M
  ): any;
  visitExistentialTypeParam?(
    this: Context<M>,
    path: NodePath<namedTypes.ExistentialTypeParam>,
    state: M
  ): any;
  visitFunctionTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.FunctionTypeAnnotation>,
    state: M
  ): any;
  visitFunctionTypeParam?(
    this: Context<M>,
    path: NodePath<namedTypes.FunctionTypeParam>,
    state: M
  ): any;
  visitArrayTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.ArrayTypeAnnotation>,
    state: M
  ): any;
  visitObjectTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectTypeAnnotation>,
    state: M
  ): any;
  visitObjectTypeProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectTypeProperty>,
    state: M
  ): any;
  visitObjectTypeSpreadProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectTypeSpreadProperty>,
    state: M
  ): any;
  visitObjectTypeIndexer?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectTypeIndexer>,
    state: M
  ): any;
  visitObjectTypeCallProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectTypeCallProperty>,
    state: M
  ): any;
  visitObjectTypeInternalSlot?(
    this: Context<M>,
    path: NodePath<namedTypes.ObjectTypeInternalSlot>,
    state: M
  ): any;
  visitVariance?(
    this: Context<M>,
    path: NodePath<namedTypes.Variance>,
    state: M
  ): any;
  visitQualifiedTypeIdentifier?(
    this: Context<M>,
    path: NodePath<namedTypes.QualifiedTypeIdentifier>,
    state: M
  ): any;
  visitGenericTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.GenericTypeAnnotation>,
    state: M
  ): any;
  visitMemberTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.MemberTypeAnnotation>,
    state: M
  ): any;
  visitUnionTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.UnionTypeAnnotation>,
    state: M
  ): any;
  visitIntersectionTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.IntersectionTypeAnnotation>,
    state: M
  ): any;
  visitTypeofTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.TypeofTypeAnnotation>,
    state: M
  ): any;
  visitTypeParameter?(
    this: Context<M>,
    path: NodePath<namedTypes.TypeParameter>,
    state: M
  ): any;
  visitInterfaceTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.InterfaceTypeAnnotation>,
    state: M
  ): any;
  visitInterfaceExtends?(
    this: Context<M>,
    path: NodePath<namedTypes.InterfaceExtends>,
    state: M
  ): any;
  visitInterfaceDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.InterfaceDeclaration>,
    state: M
  ): any;
  visitTypeAlias?(
    this: Context<M>,
    path: NodePath<namedTypes.TypeAlias>,
    state: M
  ): any;
  visitDeclareTypeAlias?(
    this: Context<M>,
    path: NodePath<namedTypes.DeclareTypeAlias>,
    state: M
  ): any;
  visitOpaqueType?(
    this: Context<M>,
    path: NodePath<namedTypes.OpaqueType>,
    state: M
  ): any;
  visitDeclareOpaqueType?(
    this: Context<M>,
    path: NodePath<namedTypes.DeclareOpaqueType>,
    state: M
  ): any;
  visitTypeCastExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.TypeCastExpression>,
    state: M
  ): any;
  visitTupleTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.TupleTypeAnnotation>,
    state: M
  ): any;
  visitDeclareVariable?(
    this: Context<M>,
    path: NodePath<namedTypes.DeclareVariable>,
    state: M
  ): any;
  visitDeclareFunction?(
    this: Context<M>,
    path: NodePath<namedTypes.DeclareFunction>,
    state: M
  ): any;
  visitFlowPredicate?(
    this: Context<M>,
    path: NodePath<namedTypes.FlowPredicate>,
    state: M
  ): any;
  visitDeclareClass?(
    this: Context<M>,
    path: NodePath<namedTypes.DeclareClass>,
    state: M
  ): any;
  visitDeclareModule?(
    this: Context<M>,
    path: NodePath<namedTypes.DeclareModule>,
    state: M
  ): any;
  visitDeclareModuleExports?(
    this: Context<M>,
    path: NodePath<namedTypes.DeclareModuleExports>,
    state: M
  ): any;
  visitDeclareExportDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.DeclareExportDeclaration>,
    state: M
  ): any;
  visitExportBatchSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportBatchSpecifier>,
    state: M
  ): any;
  visitDeclareExportAllDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.DeclareExportAllDeclaration>,
    state: M
  ): any;
  visitInferredPredicate?(
    this: Context<M>,
    path: NodePath<namedTypes.InferredPredicate>,
    state: M
  ): any;
  visitDeclaredPredicate?(
    this: Context<M>,
    path: NodePath<namedTypes.DeclaredPredicate>,
    state: M
  ): any;
  visitEnumDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.EnumDeclaration>,
    state: M
  ): any;
  visitEnumBooleanBody?(
    this: Context<M>,
    path: NodePath<namedTypes.EnumBooleanBody>,
    state: M
  ): any;
  visitEnumNumberBody?(
    this: Context<M>,
    path: NodePath<namedTypes.EnumNumberBody>,
    state: M
  ): any;
  visitEnumStringBody?(
    this: Context<M>,
    path: NodePath<namedTypes.EnumStringBody>,
    state: M
  ): any;
  visitEnumSymbolBody?(
    this: Context<M>,
    path: NodePath<namedTypes.EnumSymbolBody>,
    state: M
  ): any;
  visitEnumBooleanMember?(
    this: Context<M>,
    path: NodePath<namedTypes.EnumBooleanMember>,
    state: M
  ): any;
  visitEnumNumberMember?(
    this: Context<M>,
    path: NodePath<namedTypes.EnumNumberMember>,
    state: M
  ): any;
  visitEnumStringMember?(
    this: Context<M>,
    path: NodePath<namedTypes.EnumStringMember>,
    state: M
  ): any;
  visitEnumDefaultedMember?(
    this: Context<M>,
    path: NodePath<namedTypes.EnumDefaultedMember>,
    state: M
  ): any;
  visitExportDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportDeclaration>,
    state: M
  ): any;
  visitBlock?(
    this: Context<M>,
    path: NodePath<namedTypes.Block>,
    state: M
  ): any;
  visitLine?(this: Context<M>, path: NodePath<namedTypes.Line>, state: M): any;
  visitNoop?(this: Context<M>, path: NodePath<namedTypes.Noop>, state: M): any;
  visitDoExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.DoExpression>,
    state: M
  ): any;
  visitBindExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.BindExpression>,
    state: M
  ): any;
  visitParenthesizedExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.ParenthesizedExpression>,
    state: M
  ): any;
  visitExportNamespaceSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportNamespaceSpecifier>,
    state: M
  ): any;
  visitExportDefaultSpecifier?(
    this: Context<M>,
    path: NodePath<namedTypes.ExportDefaultSpecifier>,
    state: M
  ): any;
  visitCommentBlock?(
    this: Context<M>,
    path: NodePath<namedTypes.CommentBlock>,
    state: M
  ): any;
  visitCommentLine?(
    this: Context<M>,
    path: NodePath<namedTypes.CommentLine>,
    state: M
  ): any;
  visitDirective?(
    this: Context<M>,
    path: NodePath<namedTypes.Directive>,
    state: M
  ): any;
  visitDirectiveLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.DirectiveLiteral>,
    state: M
  ): any;
  visitInterpreterDirective?(
    this: Context<M>,
    path: NodePath<namedTypes.InterpreterDirective>,
    state: M
  ): any;
  visitStringLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.StringLiteral>,
    state: M
  ): any;
  visitNumericLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.NumericLiteral>,
    state: M
  ): any;
  visitBigIntLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.BigIntLiteral>,
    state: M
  ): any;
  visitNullLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.NullLiteral>,
    state: M
  ): any;
  visitBooleanLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.BooleanLiteral>,
    state: M
  ): any;
  visitRegExpLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.RegExpLiteral>,
    state: M
  ): any;
  visitForAwaitStatement?(
    this: Context<M>,
    path: NodePath<namedTypes.ForAwaitStatement>,
    state: M
  ): any;
  visitImport?(
    this: Context<M>,
    path: NodePath<namedTypes.Import>,
    state: M
  ): any;
  visitTSQualifiedName?(
    this: Context<M>,
    path: NodePath<namedTypes.TSQualifiedName>,
    state: M
  ): any;
  visitTSTypeReference?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeReference>,
    state: M
  ): any;
  visitTSHasOptionalTypeParameters?(
    this: Context<M>,
    path: NodePath<namedTypes.TSHasOptionalTypeParameters>,
    state: M
  ): any;
  visitTSHasOptionalTypeAnnotation?(
    this: Context<M>,
    path: NodePath<namedTypes.TSHasOptionalTypeAnnotation>,
    state: M
  ): any;
  visitTSAsExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.TSAsExpression>,
    state: M
  ): any;
  visitTSNonNullExpression?(
    this: Context<M>,
    path: NodePath<namedTypes.TSNonNullExpression>,
    state: M
  ): any;
  visitTSAnyKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSAnyKeyword>,
    state: M
  ): any;
  visitTSBigIntKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSBigIntKeyword>,
    state: M
  ): any;
  visitTSBooleanKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSBooleanKeyword>,
    state: M
  ): any;
  visitTSNeverKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSNeverKeyword>,
    state: M
  ): any;
  visitTSNullKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSNullKeyword>,
    state: M
  ): any;
  visitTSNumberKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSNumberKeyword>,
    state: M
  ): any;
  visitTSObjectKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSObjectKeyword>,
    state: M
  ): any;
  visitTSStringKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSStringKeyword>,
    state: M
  ): any;
  visitTSSymbolKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSSymbolKeyword>,
    state: M
  ): any;
  visitTSUndefinedKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSUndefinedKeyword>,
    state: M
  ): any;
  visitTSUnknownKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSUnknownKeyword>,
    state: M
  ): any;
  visitTSVoidKeyword?(
    this: Context<M>,
    path: NodePath<namedTypes.TSVoidKeyword>,
    state: M
  ): any;
  visitTSThisType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSThisType>,
    state: M
  ): any;
  visitTSArrayType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSArrayType>,
    state: M
  ): any;
  visitTSLiteralType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSLiteralType>,
    state: M
  ): any;
  visitTSUnionType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSUnionType>,
    state: M
  ): any;
  visitTSIntersectionType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSIntersectionType>,
    state: M
  ): any;
  visitTSConditionalType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSConditionalType>,
    state: M
  ): any;
  visitTSInferType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSInferType>,
    state: M
  ): any;
  visitTSTypeParameter?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeParameter>,
    state: M
  ): any;
  visitTSParenthesizedType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSParenthesizedType>,
    state: M
  ): any;
  visitTSFunctionType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSFunctionType>,
    state: M
  ): any;
  visitTSConstructorType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSConstructorType>,
    state: M
  ): any;
  visitTSDeclareFunction?(
    this: Context<M>,
    path: NodePath<namedTypes.TSDeclareFunction>,
    state: M
  ): any;
  visitTSDeclareMethod?(
    this: Context<M>,
    path: NodePath<namedTypes.TSDeclareMethod>,
    state: M
  ): any;
  visitTSMappedType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSMappedType>,
    state: M
  ): any;
  visitTSTupleType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTupleType>,
    state: M
  ): any;
  visitTSNamedTupleMember?(
    this: Context<M>,
    path: NodePath<namedTypes.TSNamedTupleMember>,
    state: M
  ): any;
  visitTSRestType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSRestType>,
    state: M
  ): any;
  visitTSOptionalType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSOptionalType>,
    state: M
  ): any;
  visitTSIndexedAccessType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSIndexedAccessType>,
    state: M
  ): any;
  visitTSTypeOperator?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeOperator>,
    state: M
  ): any;
  visitTSTypeElement?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeElement>,
    state: M
  ): any;
  visitTSIndexSignature?(
    this: Context<M>,
    path: NodePath<namedTypes.TSIndexSignature>,
    state: M
  ): any;
  visitTSPropertySignature?(
    this: Context<M>,
    path: NodePath<namedTypes.TSPropertySignature>,
    state: M
  ): any;
  visitTSMethodSignature?(
    this: Context<M>,
    path: NodePath<namedTypes.TSMethodSignature>,
    state: M
  ): any;
  visitTSTypePredicate?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypePredicate>,
    state: M
  ): any;
  visitTSCallSignatureDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSCallSignatureDeclaration>,
    state: M
  ): any;
  visitTSConstructSignatureDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSConstructSignatureDeclaration>,
    state: M
  ): any;
  visitTSEnumMember?(
    this: Context<M>,
    path: NodePath<namedTypes.TSEnumMember>,
    state: M
  ): any;
  visitTSTypeQuery?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeQuery>,
    state: M
  ): any;
  visitTSImportType?(
    this: Context<M>,
    path: NodePath<namedTypes.TSImportType>,
    state: M
  ): any;
  visitTSTypeLiteral?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeLiteral>,
    state: M
  ): any;
  visitTSTypeAssertion?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeAssertion>,
    state: M
  ): any;
  visitTSEnumDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSEnumDeclaration>,
    state: M
  ): any;
  visitTSTypeAliasDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSTypeAliasDeclaration>,
    state: M
  ): any;
  visitTSModuleBlock?(
    this: Context<M>,
    path: NodePath<namedTypes.TSModuleBlock>,
    state: M
  ): any;
  visitTSModuleDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSModuleDeclaration>,
    state: M
  ): any;
  visitTSImportEqualsDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSImportEqualsDeclaration>,
    state: M
  ): any;
  visitTSExternalModuleReference?(
    this: Context<M>,
    path: NodePath<namedTypes.TSExternalModuleReference>,
    state: M
  ): any;
  visitTSExportAssignment?(
    this: Context<M>,
    path: NodePath<namedTypes.TSExportAssignment>,
    state: M
  ): any;
  visitTSNamespaceExportDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSNamespaceExportDeclaration>,
    state: M
  ): any;
  visitTSInterfaceBody?(
    this: Context<M>,
    path: NodePath<namedTypes.TSInterfaceBody>,
    state: M
  ): any;
  visitTSInterfaceDeclaration?(
    this: Context<M>,
    path: NodePath<namedTypes.TSInterfaceDeclaration>,
    state: M
  ): any;
  visitTSParameterProperty?(
    this: Context<M>,
    path: NodePath<namedTypes.TSParameterProperty>,
    state: M
  ): any;
}
