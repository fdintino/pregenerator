// !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!!
import { namedTypes } from "./namedTypes";
export interface AwaitExpressionBuilder {
  (argument: namedTypes.Expression, all?: boolean): namedTypes.AwaitExpression;
  from(params: {
    all?: boolean;
    argument: namedTypes.Expression;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.AwaitExpression;
}
export interface DecoratorBuilder {
  (expression: namedTypes.Expression): namedTypes.Decorator;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    expression: namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.Decorator;
}
export interface PropertyBuilder {
  (
    kind: "init" | "get" | "set",
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression,
    value: namedTypes.Expression | namedTypes.PatternLike
  ): namedTypes.Property;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    computed?: boolean;
    decorators?: namedTypes.Decorator[] | null;
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    kind: "init" | "get" | "set";
    loc?: namedTypes.SourceLocation | null;
    method?: boolean;
    shorthand?: boolean;
    value: namedTypes.Expression | namedTypes.PatternLike;
  }): namedTypes.Property;
}
export interface MethodDefinitionBuilder {
  (
    kind: "constructor" | "method" | "get" | "set",
    key: namedTypes.Expression,
    value: namedTypes.Function,
    staticParam?: boolean
  ): namedTypes.MethodDefinition;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    computed?: boolean;
    decorators?: namedTypes.Decorator[] | null;
    key: namedTypes.Expression;
    kind: "constructor" | "method" | "get" | "set";
    loc?: namedTypes.SourceLocation | null;
    static?: boolean;
    value: namedTypes.Function;
  }): namedTypes.MethodDefinition;
}
export interface PrivateNameBuilder {
  (id: namedTypes.Identifier): namedTypes.PrivateName;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    id: namedTypes.Identifier;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.PrivateName;
}
export interface IdentifierBuilder {
  (name: string): namedTypes.Identifier;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    name: string;
    optional?: boolean;
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
  }): namedTypes.Identifier;
}
export interface ClassPrivatePropertyBuilder {
  (
    key: namedTypes.PrivateName,
    value?: namedTypes.Expression | null
  ): namedTypes.ClassPrivateProperty;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    computed?: boolean;
    key: namedTypes.PrivateName;
    loc?: namedTypes.SourceLocation | null;
    value?: namedTypes.Expression | null;
  }): namedTypes.ClassPrivateProperty;
}
export interface FileBuilder {
  (program: namedTypes.Program, name?: string | null): namedTypes.File;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    name?: string | null;
    program: namedTypes.Program;
  }): namedTypes.File;
}
export interface ProgramBuilder {
  (body: namedTypes.Statement[]): namedTypes.Program;
  from(params: {
    body: namedTypes.Statement[];
    comments?: namedTypes.Comment[] | null;
    directives?: namedTypes.Directive[];
    interpreter?: namedTypes.InterpreterDirective | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.Program;
}
export interface BlockStatementBuilder {
  (body: namedTypes.Statement[]): namedTypes.BlockStatement;
  from(params: {
    body: namedTypes.Statement[];
    comments?: namedTypes.Comment[] | null;
    directives?: namedTypes.Directive[];
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.BlockStatement;
}
export interface EmptyStatementBuilder {
  (): namedTypes.EmptyStatement;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.EmptyStatement;
}
export interface ExpressionStatementBuilder {
  (expression: namedTypes.Expression): namedTypes.ExpressionStatement;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    expression: namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ExpressionStatement;
}
export interface IfStatementBuilder {
  (
    test: namedTypes.Expression,
    consequent: namedTypes.Statement,
    alternate?: namedTypes.Statement | null
  ): namedTypes.IfStatement;
  from(params: {
    alternate?: namedTypes.Statement | null;
    comments?: namedTypes.Comment[] | null;
    consequent: namedTypes.Statement;
    loc?: namedTypes.SourceLocation | null;
    test: namedTypes.Expression;
  }): namedTypes.IfStatement;
}
export interface LabeledStatementBuilder {
  (
    label: namedTypes.Identifier,
    body: namedTypes.Statement
  ): namedTypes.LabeledStatement;
  from(params: {
    body: namedTypes.Statement;
    comments?: namedTypes.Comment[] | null;
    label: namedTypes.Identifier;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.LabeledStatement;
}
export interface BreakStatementBuilder {
  (label?: namedTypes.Identifier | null): namedTypes.BreakStatement;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    label?: namedTypes.Identifier | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.BreakStatement;
}
export interface ContinueStatementBuilder {
  (label?: namedTypes.Identifier | null): namedTypes.ContinueStatement;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    label?: namedTypes.Identifier | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ContinueStatement;
}
export interface WithStatementBuilder {
  (
    object: namedTypes.Expression,
    body: namedTypes.Statement
  ): namedTypes.WithStatement;
  from(params: {
    body: namedTypes.Statement;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    object: namedTypes.Expression;
  }): namedTypes.WithStatement;
}
export interface SwitchStatementBuilder {
  (
    discriminant: namedTypes.Expression,
    cases: namedTypes.SwitchCase[],
    lexical?: boolean
  ): namedTypes.SwitchStatement;
  from(params: {
    cases: namedTypes.SwitchCase[];
    comments?: namedTypes.Comment[] | null;
    discriminant: namedTypes.Expression;
    lexical?: boolean;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.SwitchStatement;
}
export interface SwitchCaseBuilder {
  (
    test: namedTypes.Expression | null,
    consequent: namedTypes.Statement[]
  ): namedTypes.SwitchCase;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    consequent: namedTypes.Statement[];
    loc?: namedTypes.SourceLocation | null;
    test: namedTypes.Expression | null;
  }): namedTypes.SwitchCase;
}
export interface ReturnStatementBuilder {
  (argument: namedTypes.Expression | null): namedTypes.ReturnStatement;
  from(params: {
    argument: namedTypes.Expression | null;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ReturnStatement;
}
export interface ThrowStatementBuilder {
  (argument: namedTypes.Expression): namedTypes.ThrowStatement;
  from(params: {
    argument: namedTypes.Expression;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ThrowStatement;
}
export interface TryStatementBuilder {
  (
    block: namedTypes.BlockStatement,
    handler?: namedTypes.CatchClause | null,
    finalizer?: namedTypes.BlockStatement | null
  ): namedTypes.TryStatement;
  from(params: {
    block: namedTypes.BlockStatement;
    comments?: namedTypes.Comment[] | null;
    finalizer?: namedTypes.BlockStatement | null;
    guardedHandlers?: namedTypes.CatchClause[];
    handler?: namedTypes.CatchClause | null;
    handlers?: namedTypes.CatchClause[];
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TryStatement;
}
export interface CatchClauseBuilder {
  (
    param:
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
      | namedTypes.Identifier
      | null,
    guard: (namedTypes.Expression | null) | undefined,
    body: namedTypes.BlockStatement
  ): namedTypes.CatchClause;
  from(params: {
    body: namedTypes.BlockStatement;
    comments?: namedTypes.Comment[] | null;
    guard?: namedTypes.Expression | null;
    loc?: namedTypes.SourceLocation | null;
    param:
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
      | namedTypes.Identifier
      | null;
  }): namedTypes.CatchClause;
}
export interface WhileStatementBuilder {
  (
    test: namedTypes.Expression,
    body: namedTypes.Statement
  ): namedTypes.WhileStatement;
  from(params: {
    body: namedTypes.Statement;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    test: namedTypes.Expression;
  }): namedTypes.WhileStatement;
}
export interface DoWhileStatementBuilder {
  (
    body: namedTypes.Statement,
    test: namedTypes.Expression
  ): namedTypes.DoWhileStatement;
  from(params: {
    body: namedTypes.Statement;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    test: namedTypes.Expression;
  }): namedTypes.DoWhileStatement;
}
export interface ForStatementBuilder {
  (
    init: namedTypes.VariableDeclaration | namedTypes.Expression | null,
    test: namedTypes.Expression | null,
    update: namedTypes.Expression | null,
    body: namedTypes.Statement
  ): namedTypes.ForStatement;
  from(params: {
    body: namedTypes.Statement;
    comments?: namedTypes.Comment[] | null;
    init: namedTypes.VariableDeclaration | namedTypes.Expression | null;
    loc?: namedTypes.SourceLocation | null;
    test: namedTypes.Expression | null;
    update: namedTypes.Expression | null;
  }): namedTypes.ForStatement;
}
export interface VariableDeclarationBuilder {
  (
    kind: "var" | "let" | "const",
    declarations: (namedTypes.Identifier | namedTypes.VariableDeclarator)[]
  ): namedTypes.VariableDeclaration;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    declarations: (namedTypes.Identifier | namedTypes.VariableDeclarator)[];
    kind: "var" | "let" | "const";
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.VariableDeclaration;
}
export interface ForInStatementBuilder {
  (
    left: namedTypes.VariableDeclaration | namedTypes.LVal,
    right: namedTypes.Expression,
    body: namedTypes.Statement
  ): namedTypes.ForInStatement;
  from(params: {
    body: namedTypes.Statement;
    comments?: namedTypes.Comment[] | null;
    left: namedTypes.VariableDeclaration | namedTypes.LVal;
    loc?: namedTypes.SourceLocation | null;
    right: namedTypes.Expression;
  }): namedTypes.ForInStatement;
}
export interface DebuggerStatementBuilder {
  (): namedTypes.DebuggerStatement;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.DebuggerStatement;
}
export interface FunctionDeclarationBuilder {
  (
    id: namedTypes.Identifier | null,
    params: namedTypes.PatternLike[],
    body: namedTypes.BlockStatement,
    generator?: boolean,
    expression?: boolean
  ): namedTypes.FunctionDeclaration;
  from(params: {
    async?: boolean;
    body: namedTypes.BlockStatement;
    comments?: namedTypes.Comment[] | null;
    defaults?: (namedTypes.Expression | null)[];
    expression?: boolean;
    generator?: boolean;
    id: namedTypes.Identifier | null;
    loc?: namedTypes.SourceLocation | null;
    params: namedTypes.PatternLike[];
    rest?: namedTypes.Identifier | null;
    returnType?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
  }): namedTypes.FunctionDeclaration;
}
export interface FunctionExpressionBuilder {
  (
    id: (namedTypes.Identifier | null) | undefined,
    params: namedTypes.PatternLike[],
    body: namedTypes.BlockStatement,
    generator?: boolean,
    expression?: boolean
  ): namedTypes.FunctionExpression;
  from(params: {
    async?: boolean;
    body: namedTypes.BlockStatement;
    comments?: namedTypes.Comment[] | null;
    defaults?: (namedTypes.Expression | null)[];
    expression?: boolean;
    generator?: boolean;
    id?: namedTypes.Identifier | null;
    loc?: namedTypes.SourceLocation | null;
    params: namedTypes.PatternLike[];
    rest?: namedTypes.Identifier | null;
    returnType?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
  }): namedTypes.FunctionExpression;
}
export interface VariableDeclaratorBuilder {
  (
    id: namedTypes.LVal,
    init?: namedTypes.Expression | null
  ): namedTypes.VariableDeclarator;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    id: namedTypes.LVal;
    init?: namedTypes.Expression | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.VariableDeclarator;
}
export interface ThisExpressionBuilder {
  (): namedTypes.ThisExpression;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ThisExpression;
}
export interface ArrayExpressionBuilder {
  (
    elements: (namedTypes.Expression | namedTypes.SpreadElement | null)[]
  ): namedTypes.ArrayExpression;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    elements: (namedTypes.Expression | namedTypes.SpreadElement | null)[];
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ArrayExpression;
}
export interface ObjectExpressionBuilder {
  (
    properties: (
      | namedTypes.Property
      | namedTypes.ObjectMethod
      | namedTypes.ObjectProperty
      | namedTypes.SpreadElement
    )[]
  ): namedTypes.ObjectExpression;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    properties: (
      | namedTypes.Property
      | namedTypes.ObjectMethod
      | namedTypes.ObjectProperty
      | namedTypes.SpreadElement
    )[];
  }): namedTypes.ObjectExpression;
}
export interface SequenceExpressionBuilder {
  (expressions: namedTypes.Expression[]): namedTypes.SequenceExpression;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    expressions: namedTypes.Expression[];
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.SequenceExpression;
}
export interface UnaryExpressionBuilder {
  (
    operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete",
    argument: namedTypes.Expression,
    prefix?: boolean
  ): namedTypes.UnaryExpression;
  from(params: {
    argument: namedTypes.Expression;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";
    prefix?: boolean;
  }): namedTypes.UnaryExpression;
}
export interface BinaryExpressionBuilder {
  (
    operator:
      | "=="
      | "!="
      | "==="
      | "!=="
      | "<"
      | "<="
      | ">"
      | ">="
      | "<<"
      | ">>"
      | ">>>"
      | "+"
      | "-"
      | "*"
      | "/"
      | "%"
      | "&"
      | "|"
      | "^"
      | "in"
      | "instanceof",
    left: namedTypes.Expression,
    right: namedTypes.Expression
  ): namedTypes.BinaryExpression;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    left: namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
    operator:
      | "=="
      | "!="
      | "==="
      | "!=="
      | "<"
      | "<="
      | ">"
      | ">="
      | "<<"
      | ">>"
      | ">>>"
      | "+"
      | "-"
      | "*"
      | "/"
      | "%"
      | "&"
      | "|"
      | "^"
      | "in"
      | "instanceof";
    right: namedTypes.Expression;
  }): namedTypes.BinaryExpression;
}
export interface AssignmentExpressionBuilder {
  (
    operator:
      | "="
      | "+="
      | "-="
      | "*="
      | "/="
      | "%="
      | "<<="
      | ">>="
      | ">>>="
      | "|="
      | "^="
      | "&=",
    left: namedTypes.LVal,
    right: namedTypes.Expression
  ): namedTypes.AssignmentExpression;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    left: namedTypes.LVal;
    loc?: namedTypes.SourceLocation | null;
    operator:
      | "="
      | "+="
      | "-="
      | "*="
      | "/="
      | "%="
      | "<<="
      | ">>="
      | ">>>="
      | "|="
      | "^="
      | "&=";
    right: namedTypes.Expression;
  }): namedTypes.AssignmentExpression;
}
export interface UpdateExpressionBuilder {
  (
    operator: "++" | "--",
    argument: namedTypes.Expression,
    prefix: boolean
  ): namedTypes.UpdateExpression;
  from(params: {
    argument: namedTypes.Expression;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    operator: "++" | "--";
    prefix: boolean;
  }): namedTypes.UpdateExpression;
}
export interface LogicalExpressionBuilder {
  (
    operator: "||" | "&&",
    left: namedTypes.Expression,
    right: namedTypes.Expression
  ): namedTypes.LogicalExpression;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    left: namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
    operator: "||" | "&&";
    right: namedTypes.Expression;
  }): namedTypes.LogicalExpression;
}
export interface ConditionalExpressionBuilder {
  (
    test: namedTypes.Expression,
    consequent: namedTypes.Expression,
    alternate: namedTypes.Expression
  ): namedTypes.ConditionalExpression;
  from(params: {
    alternate: namedTypes.Expression;
    comments?: namedTypes.Comment[] | null;
    consequent: namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
    test: namedTypes.Expression;
  }): namedTypes.ConditionalExpression;
}
export interface NewExpressionBuilder {
  (
    callee: namedTypes.Expression,
    argumentsParam: (namedTypes.Expression | namedTypes.SpreadElement)[]
  ): namedTypes.NewExpression;
  from(params: {
    arguments: (namedTypes.Expression | namedTypes.SpreadElement)[];
    callee: namedTypes.Expression;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.NewExpression;
}
export interface CallExpressionBuilder {
  (
    callee: namedTypes.Expression,
    argumentsParam: (namedTypes.Expression | namedTypes.SpreadElement)[]
  ): namedTypes.CallExpression;
  from(params: {
    arguments: (namedTypes.Expression | namedTypes.SpreadElement)[];
    callee: namedTypes.Expression;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.CallExpression;
}
export interface MemberExpressionBuilder {
  (
    object: namedTypes.Expression,
    property: namedTypes.Identifier | namedTypes.Expression,
    computed?: boolean
  ): namedTypes.MemberExpression;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    computed?: boolean;
    loc?: namedTypes.SourceLocation | null;
    object: namedTypes.Expression;
    property: namedTypes.Identifier | namedTypes.Expression;
  }): namedTypes.MemberExpression;
}
export interface PlaceholderBuilder {
  (
    expectedNode:
      | "Identifier"
      | "StringLiteral"
      | "Expression"
      | "Statement"
      | "Declaration"
      | "BlockStatement"
      | "ClassBody"
      | "Pattern",
    name: namedTypes.Identifier
  ): namedTypes.Placeholder;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    expectedNode:
      | "Identifier"
      | "StringLiteral"
      | "Expression"
      | "Statement"
      | "Declaration"
      | "BlockStatement"
      | "ClassBody"
      | "Pattern";
    loc?: namedTypes.SourceLocation | null;
    name: namedTypes.Identifier;
  }): namedTypes.Placeholder;
}
export interface RestElementBuilder {
  (argument: namedTypes.LVal): namedTypes.RestElement;
  from(params: {
    argument: namedTypes.LVal;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.RestElement;
}
export interface ArrowFunctionExpressionBuilder {
  (
    params: namedTypes.PatternLike[],
    body: namedTypes.BlockStatement | namedTypes.Expression,
    expression?: boolean
  ): namedTypes.ArrowFunctionExpression;
  from(params: {
    async?: boolean;
    body: namedTypes.BlockStatement | namedTypes.Expression;
    comments?: namedTypes.Comment[] | null;
    defaults?: (namedTypes.Expression | null)[];
    expression?: boolean;
    generator?: false;
    id?: null;
    loc?: namedTypes.SourceLocation | null;
    params: namedTypes.PatternLike[];
    rest?: namedTypes.Identifier | null;
    returnType?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
  }): namedTypes.ArrowFunctionExpression;
}
export interface ForOfStatementBuilder {
  (
    left: namedTypes.VariableDeclaration | namedTypes.LVal,
    right: namedTypes.Expression,
    body: namedTypes.Statement
  ): namedTypes.ForOfStatement;
  from(params: {
    await?: boolean;
    body: namedTypes.Statement;
    comments?: namedTypes.Comment[] | null;
    left: namedTypes.VariableDeclaration | namedTypes.LVal;
    loc?: namedTypes.SourceLocation | null;
    right: namedTypes.Expression;
  }): namedTypes.ForOfStatement;
}
export interface YieldExpressionBuilder {
  (
    argument: namedTypes.Expression | null,
    delegate?: boolean
  ): namedTypes.YieldExpression;
  from(params: {
    argument: namedTypes.Expression | null;
    comments?: namedTypes.Comment[] | null;
    delegate?: boolean;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.YieldExpression;
}
export interface GeneratorExpressionBuilder {
  (
    body: namedTypes.Expression,
    blocks: namedTypes.ComprehensionBlock[],
    filter: namedTypes.Expression | null
  ): namedTypes.GeneratorExpression;
  from(params: {
    blocks: namedTypes.ComprehensionBlock[];
    body: namedTypes.Expression;
    comments?: namedTypes.Comment[] | null;
    filter: namedTypes.Expression | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.GeneratorExpression;
}
export interface ComprehensionBlockBuilder {
  (
    left: namedTypes.Pattern,
    right: namedTypes.Expression,
    each: boolean
  ): namedTypes.ComprehensionBlock;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    each: boolean;
    left: namedTypes.Pattern;
    loc?: namedTypes.SourceLocation | null;
    right: namedTypes.Expression;
  }): namedTypes.ComprehensionBlock;
}
export interface ComprehensionExpressionBuilder {
  (
    body: namedTypes.Expression,
    blocks: namedTypes.ComprehensionBlock[],
    filter: namedTypes.Expression | null
  ): namedTypes.ComprehensionExpression;
  from(params: {
    blocks: namedTypes.ComprehensionBlock[];
    body: namedTypes.Expression;
    comments?: namedTypes.Comment[] | null;
    filter: namedTypes.Expression | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ComprehensionExpression;
}
export interface ObjectPropertyBuilder {
  (
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression,
    value: namedTypes.Expression | namedTypes.PatternLike
  ): namedTypes.ObjectProperty;
  from(params: {
    accessibility?: namedTypes.Literal | null;
    comments?: namedTypes.Comment[] | null;
    computed?: boolean;
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
    shorthand?: boolean;
    value: namedTypes.Expression | namedTypes.PatternLike;
  }): namedTypes.ObjectProperty;
}
export interface ArrayPatternBuilder {
  (elements: (namedTypes.PatternLike | null)[]): namedTypes.ArrayPattern;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    elements: (namedTypes.PatternLike | null)[];
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ArrayPattern;
}
export interface ObjectPatternBuilder {
  (
    properties: (namedTypes.Property | namedTypes.ObjectProperty)[]
  ): namedTypes.ObjectPattern;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    decorators?: namedTypes.Decorator[] | null;
    loc?: namedTypes.SourceLocation | null;
    properties: (namedTypes.Property | namedTypes.ObjectProperty)[];
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
  }): namedTypes.ObjectPattern;
}
export interface SpreadElementBuilder {
  (argument: namedTypes.Expression): namedTypes.SpreadElement;
  from(params: {
    argument: namedTypes.Expression;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.SpreadElement;
}
export interface AssignmentPatternBuilder {
  (
    left:
      | namedTypes.Identifier
      | namedTypes.ObjectPattern
      | namedTypes.ArrayPattern
      | namedTypes.MemberExpression,
    right: namedTypes.Expression
  ): namedTypes.AssignmentPattern;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    left:
      | namedTypes.Identifier
      | namedTypes.ObjectPattern
      | namedTypes.ArrayPattern
      | namedTypes.MemberExpression;
    loc?: namedTypes.SourceLocation | null;
    right: namedTypes.Expression;
  }): namedTypes.AssignmentPattern;
}
export interface ClassPropertyDefinitionBuilder {
  (
    definition:
      | namedTypes.MethodDefinition
      | namedTypes.VariableDeclarator
      | namedTypes.ClassPropertyDefinition
      | namedTypes.ClassProperty
  ): namedTypes.ClassPropertyDefinition;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    definition:
      | namedTypes.MethodDefinition
      | namedTypes.VariableDeclarator
      | namedTypes.ClassPropertyDefinition
      | namedTypes.ClassProperty;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ClassPropertyDefinition;
}
export interface ClassPropertyBuilder {
  (
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression,
    value: namedTypes.Expression | null,
    typeAnnotation?: namedTypes.TSTypeAnnotation | null,
    staticParam?: boolean
  ): namedTypes.ClassProperty;
  from(params: {
    access?: "public" | "private" | "protected" | undefined;
    comments?: namedTypes.Comment[] | null;
    computed?: boolean;
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
    static?: boolean;
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
    value: namedTypes.Expression | null;
  }): namedTypes.ClassProperty;
}
export interface ClassBodyBuilder {
  (
    body: (
      | namedTypes.MethodDefinition
      | namedTypes.VariableDeclarator
      | namedTypes.ClassPropertyDefinition
      | namedTypes.ClassProperty
      | namedTypes.ClassPrivateProperty
      | namedTypes.ClassMethod
      | namedTypes.ClassPrivateMethod
      | namedTypes.TSDeclareMethod
      | (
          | namedTypes.TSCallSignatureDeclaration
          | namedTypes.TSConstructSignatureDeclaration
          | namedTypes.TSIndexSignature
          | namedTypes.TSMethodSignature
          | namedTypes.TSPropertySignature
        )
    )[]
  ): namedTypes.ClassBody;
  from(params: {
    body: (
      | namedTypes.MethodDefinition
      | namedTypes.VariableDeclarator
      | namedTypes.ClassPropertyDefinition
      | namedTypes.ClassProperty
      | namedTypes.ClassPrivateProperty
      | namedTypes.ClassMethod
      | namedTypes.ClassPrivateMethod
      | namedTypes.TSDeclareMethod
      | (
          | namedTypes.TSCallSignatureDeclaration
          | namedTypes.TSConstructSignatureDeclaration
          | namedTypes.TSIndexSignature
          | namedTypes.TSMethodSignature
          | namedTypes.TSPropertySignature
        )
    )[];
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ClassBody;
}
export interface ClassDeclarationBuilder {
  (
    id: namedTypes.Identifier | null,
    body: namedTypes.ClassBody,
    superClass?: namedTypes.Expression | null
  ): namedTypes.ClassDeclaration;
  from(params: {
    body: namedTypes.ClassBody;
    comments?: namedTypes.Comment[] | null;
    id: namedTypes.Identifier | null;
    implements?: namedTypes.TSExpressionWithTypeArguments;
    loc?: namedTypes.SourceLocation | null;
    superClass?: namedTypes.Expression | null;
    superTypeParameters?: namedTypes.TSTypeParameterInstantiation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
  }): namedTypes.ClassDeclaration;
}
export interface ClassExpressionBuilder {
  (
    id: (namedTypes.Identifier | null) | undefined,
    body: namedTypes.ClassBody,
    superClass?: namedTypes.Expression | null
  ): namedTypes.ClassExpression;
  from(params: {
    body: namedTypes.ClassBody;
    comments?: namedTypes.Comment[] | null;
    id?: namedTypes.Identifier | null;
    implements?: namedTypes.TSExpressionWithTypeArguments;
    loc?: namedTypes.SourceLocation | null;
    superClass?: namedTypes.Expression | null;
    superTypeParameters?: namedTypes.TSTypeParameterInstantiation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
  }): namedTypes.ClassExpression;
}
export interface SuperBuilder {
  (): namedTypes.Super;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.Super;
}
export interface ImportSpecifierBuilder {
  (
    imported: namedTypes.Identifier,
    local?: namedTypes.Identifier | null
  ): namedTypes.ImportSpecifier;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    id?: namedTypes.Identifier | null;
    imported: namedTypes.Identifier;
    loc?: namedTypes.SourceLocation | null;
    local?: namedTypes.Identifier | null;
    name?: namedTypes.Identifier | null;
  }): namedTypes.ImportSpecifier;
}
export interface ImportDefaultSpecifierBuilder {
  (local?: namedTypes.Identifier | null): namedTypes.ImportDefaultSpecifier;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    id?: namedTypes.Identifier | null;
    loc?: namedTypes.SourceLocation | null;
    local?: namedTypes.Identifier | null;
    name?: namedTypes.Identifier | null;
  }): namedTypes.ImportDefaultSpecifier;
}
export interface ImportNamespaceSpecifierBuilder {
  (local?: namedTypes.Identifier | null): namedTypes.ImportNamespaceSpecifier;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    id?: namedTypes.Identifier | null;
    loc?: namedTypes.SourceLocation | null;
    local?: namedTypes.Identifier | null;
    name?: namedTypes.Identifier | null;
  }): namedTypes.ImportNamespaceSpecifier;
}
export interface ImportDeclarationBuilder {
  (
    specifiers:
      | (
          | namedTypes.ImportSpecifier
          | namedTypes.ImportNamespaceSpecifier
          | namedTypes.ImportDefaultSpecifier
        )[]
      | undefined,
    source: namedTypes.Literal,
    importKind?: "value" | "type"
  ): namedTypes.ImportDeclaration;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    importKind?: "value" | "type";
    loc?: namedTypes.SourceLocation | null;
    source: namedTypes.Literal;
    specifiers?: (
      | namedTypes.ImportSpecifier
      | namedTypes.ImportNamespaceSpecifier
      | namedTypes.ImportDefaultSpecifier
    )[];
  }): namedTypes.ImportDeclaration;
}
export interface ExportNamedDeclarationBuilder {
  (
    declaration: namedTypes.Declaration | null,
    specifiers?: namedTypes.ExportSpecifier[],
    source?: namedTypes.Literal | null
  ): namedTypes.ExportNamedDeclaration;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    declaration: namedTypes.Declaration | null;
    loc?: namedTypes.SourceLocation | null;
    source?: namedTypes.Literal | null;
    specifiers?: namedTypes.ExportSpecifier[];
  }): namedTypes.ExportNamedDeclaration;
}
export interface ExportSpecifierBuilder {
  (
    local: (namedTypes.Identifier | null) | undefined,
    exported: namedTypes.Identifier
  ): namedTypes.ExportSpecifier;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    exported: namedTypes.Identifier;
    id?: namedTypes.Identifier | null;
    loc?: namedTypes.SourceLocation | null;
    local?: namedTypes.Identifier | null;
    name?: namedTypes.Identifier | null;
  }): namedTypes.ExportSpecifier;
}
export interface ExportDefaultDeclarationBuilder {
  (
    declaration: namedTypes.Declaration | namedTypes.Expression
  ): namedTypes.ExportDefaultDeclaration;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    declaration: namedTypes.Declaration | namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ExportDefaultDeclaration;
}
export interface ExportAllDeclarationBuilder {
  (source: namedTypes.Literal): namedTypes.ExportAllDeclaration;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    source: namedTypes.Literal;
  }): namedTypes.ExportAllDeclaration;
}
export interface TaggedTemplateExpressionBuilder {
  (
    tag: namedTypes.Expression,
    quasi: namedTypes.TemplateLiteral
  ): namedTypes.TaggedTemplateExpression;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    quasi: namedTypes.TemplateLiteral;
    tag: namedTypes.Expression;
  }): namedTypes.TaggedTemplateExpression;
}
export interface TemplateLiteralBuilder {
  (
    quasis: namedTypes.TemplateElement[],
    expressions: namedTypes.Expression[]
  ): namedTypes.TemplateLiteral;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    expressions: namedTypes.Expression[];
    loc?: namedTypes.SourceLocation | null;
    quasis: namedTypes.TemplateElement[];
  }): namedTypes.TemplateLiteral;
}
export interface TemplateElementBuilder {
  (
    value: { cooked: string; raw: string },
    tail: boolean
  ): namedTypes.TemplateElement;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    tail: boolean;
    value: { cooked: string; raw: string };
  }): namedTypes.TemplateElement;
}
export interface MetaPropertyBuilder {
  (
    meta: namedTypes.Identifier,
    property: namedTypes.Identifier
  ): namedTypes.MetaProperty;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    meta: namedTypes.Identifier;
    property: namedTypes.Identifier;
  }): namedTypes.MetaProperty;
}
export interface NoopBuilder {
  (): namedTypes.Noop;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.Noop;
}
export interface DoExpressionBuilder {
  (body: namedTypes.Statement[]): namedTypes.DoExpression;
  from(params: {
    body: namedTypes.Statement[];
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.DoExpression;
}
export interface BindExpressionBuilder {
  (
    object: namedTypes.Expression | null,
    callee: namedTypes.Expression
  ): namedTypes.BindExpression;
  from(params: {
    callee: namedTypes.Expression;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    object: namedTypes.Expression | null;
  }): namedTypes.BindExpression;
}
export interface ParenthesizedExpressionBuilder {
  (expression: namedTypes.Expression): namedTypes.ParenthesizedExpression;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    expression: namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ParenthesizedExpression;
}
export interface ExportNamespaceSpecifierBuilder {
  (exported: namedTypes.Identifier): namedTypes.ExportNamespaceSpecifier;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    exported: namedTypes.Identifier;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ExportNamespaceSpecifier;
}
export interface ExportDefaultSpecifierBuilder {
  (exported: namedTypes.Identifier): namedTypes.ExportDefaultSpecifier;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    exported: namedTypes.Identifier;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.ExportDefaultSpecifier;
}
export interface CommentBlockBuilder {
  (
    value: string,
    leading?: boolean,
    trailing?: boolean
  ): namedTypes.CommentBlock;
  from(params: {
    leading?: boolean;
    loc?: namedTypes.SourceLocation | null;
    trailing?: boolean;
    value: string;
  }): namedTypes.CommentBlock;
}
export interface CommentLineBuilder {
  (
    value: string,
    leading?: boolean,
    trailing?: boolean
  ): namedTypes.CommentLine;
  from(params: {
    leading?: boolean;
    loc?: namedTypes.SourceLocation | null;
    trailing?: boolean;
    value: string;
  }): namedTypes.CommentLine;
}
export interface DirectiveBuilder {
  (value: namedTypes.DirectiveLiteral): namedTypes.Directive;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    value: namedTypes.DirectiveLiteral;
  }): namedTypes.Directive;
}
export interface DirectiveLiteralBuilder {
  (value?: string): namedTypes.DirectiveLiteral;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    value?: string;
  }): namedTypes.DirectiveLiteral;
}
export interface InterpreterDirectiveBuilder {
  (value: string): namedTypes.InterpreterDirective;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    value: string;
  }): namedTypes.InterpreterDirective;
}
export interface StringLiteralBuilder {
  (value: string): namedTypes.StringLiteral;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    extra?: { rawValue: string; raw: string };
    loc?: namedTypes.SourceLocation | null;
    raw?: string;
    value: string;
  }): namedTypes.StringLiteral;
}
export interface NumericLiteralBuilder {
  (value: number): namedTypes.NumericLiteral;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    extra?: { rawValue: number; raw: string };
    loc?: namedTypes.SourceLocation | null;
    raw?: string;
    value: number;
  }): namedTypes.NumericLiteral;
}
export interface BigIntLiteralBuilder {
  (value: string | number): namedTypes.BigIntLiteral;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    extra?: { rawValue: string; raw: string };
    loc?: namedTypes.SourceLocation | null;
    raw?: string;
    value: string | number;
  }): namedTypes.BigIntLiteral;
}
export interface NullLiteralBuilder {
  (value?: null): namedTypes.NullLiteral;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    extra?: { rawValue: null; raw: string };
    loc?: namedTypes.SourceLocation | null;
    raw?: string;
    value?: null;
  }): namedTypes.NullLiteral;
}
export interface BooleanLiteralBuilder {
  (value: boolean): namedTypes.BooleanLiteral;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    extra?: { rawValue: boolean; raw: string };
    loc?: namedTypes.SourceLocation | null;
    raw?: string;
    value: boolean;
  }): namedTypes.BooleanLiteral;
}
export interface RegExpLiteralBuilder {
  (pattern: string, flags: string): namedTypes.RegExpLiteral;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    extra?: { rawValue: RegExp; raw: string };
    flags: string;
    loc?: namedTypes.SourceLocation | null;
    pattern: string;
    raw?: string;
    value?: RegExp;
  }): namedTypes.RegExpLiteral;
}
export interface ObjectMethodBuilder {
  (
    kind: "method" | "get" | "set",
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression,
    params: namedTypes.PatternLike[],
    body: namedTypes.BlockStatement,
    computed?: boolean
  ): namedTypes.ObjectMethod;
  from(params: {
    accessibility?: namedTypes.Literal | null;
    async?: boolean;
    body: namedTypes.BlockStatement;
    comments?: namedTypes.Comment[] | null;
    computed?: boolean;
    decorators?: namedTypes.Decorator[] | null;
    defaults?: (namedTypes.Expression | null)[];
    expression?: boolean;
    generator?: boolean;
    id?: namedTypes.Identifier | null;
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    kind: "method" | "get" | "set";
    loc?: namedTypes.SourceLocation | null;
    params: namedTypes.PatternLike[];
    rest?: namedTypes.Identifier | null;
    returnType?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
  }): namedTypes.ObjectMethod;
}
export interface ClassMethodBuilder {
  (
    kind: ("get" | "set" | "method" | "constructor") | undefined,
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression,
    params: namedTypes.PatternLike[],
    body: namedTypes.BlockStatement,
    computed?: boolean,
    staticParam?: boolean | null
  ): namedTypes.ClassMethod;
  from(params: {
    abstract?: boolean | null;
    access?: "public" | "private" | "protected" | null;
    accessibility?: "public" | "private" | "protected" | null;
    async?: boolean;
    body: namedTypes.BlockStatement;
    comments?: namedTypes.Comment[] | null;
    computed?: boolean;
    decorators?: namedTypes.Decorator[] | null;
    defaults?: (namedTypes.Expression | null)[];
    expression?: boolean;
    generator?: boolean;
    id?: namedTypes.Identifier | null;
    key: namedTypes.Literal | namedTypes.Identifier | namedTypes.Expression;
    kind?: "get" | "set" | "method" | "constructor";
    loc?: namedTypes.SourceLocation | null;
    optional?: boolean | null;
    params: namedTypes.PatternLike[];
    rest?: namedTypes.Identifier | null;
    returnType?: namedTypes.TSTypeAnnotation | null;
    static?: boolean | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
  }): namedTypes.ClassMethod;
}
export interface ClassPrivateMethodBuilder {
  (
    key: namedTypes.PrivateName,
    params: namedTypes.PatternLike[],
    body: namedTypes.BlockStatement,
    kind?: "get" | "set" | "method" | "constructor",
    computed?: boolean,
    staticParam?: boolean | null
  ): namedTypes.ClassPrivateMethod;
  from(params: {
    abstract?: boolean | null;
    access?: "public" | "private" | "protected" | null;
    accessibility?: "public" | "private" | "protected" | null;
    async?: boolean;
    body: namedTypes.BlockStatement;
    comments?: namedTypes.Comment[] | null;
    computed?: boolean;
    decorators?: namedTypes.Decorator[] | null;
    defaults?: (namedTypes.Expression | null)[];
    expression?: boolean;
    generator?: boolean;
    id?: namedTypes.Identifier | null;
    key: namedTypes.PrivateName;
    kind?: "get" | "set" | "method" | "constructor";
    loc?: namedTypes.SourceLocation | null;
    optional?: boolean | null;
    params: namedTypes.PatternLike[];
    rest?: namedTypes.Identifier | null;
    returnType?: namedTypes.TSTypeAnnotation | null;
    static?: boolean | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null;
  }): namedTypes.ClassPrivateMethod;
}
export interface ForAwaitStatementBuilder {
  (
    left: namedTypes.VariableDeclaration | namedTypes.Expression,
    right: namedTypes.Expression,
    body: namedTypes.Statement
  ): namedTypes.ForAwaitStatement;
  from(params: {
    body: namedTypes.Statement;
    comments?: namedTypes.Comment[] | null;
    left: namedTypes.VariableDeclaration | namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
    right: namedTypes.Expression;
  }): namedTypes.ForAwaitStatement;
}
export interface ImportBuilder {
  (): namedTypes.Import;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.Import;
}
export interface TSTypeAnnotationBuilder {
  (
    typeAnnotation: namedTypes.TSType | namedTypes.TSTypeAnnotation
  ): namedTypes.TSTypeAnnotation;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    typeAnnotation: namedTypes.TSType | namedTypes.TSTypeAnnotation;
  }): namedTypes.TSTypeAnnotation;
}
export interface TSTypeParameterDeclarationBuilder {
  (params: namedTypes.TSTypeParameter[]): namedTypes.TSTypeParameterDeclaration;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    params: namedTypes.TSTypeParameter[];
  }): namedTypes.TSTypeParameterDeclaration;
}
export interface TSTypeParameterInstantiationBuilder {
  (params: namedTypes.TSType[]): namedTypes.TSTypeParameterInstantiation;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    params: namedTypes.TSType[];
  }): namedTypes.TSTypeParameterInstantiation;
}
export interface TSExpressionWithTypeArgumentsBuilder {
  (
    expression: namedTypes.Identifier | namedTypes.TSQualifiedName,
    typeParameters?: namedTypes.TSTypeParameterInstantiation | null
  ): namedTypes.TSExpressionWithTypeArguments;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    expression: namedTypes.Identifier | namedTypes.TSQualifiedName;
    loc?: namedTypes.SourceLocation | null;
    typeParameters?: namedTypes.TSTypeParameterInstantiation | null;
  }): namedTypes.TSExpressionWithTypeArguments;
}
export interface TSQualifiedNameBuilder {
  (
    left: namedTypes.Identifier | namedTypes.TSQualifiedName,
    right: namedTypes.Identifier | namedTypes.TSQualifiedName
  ): namedTypes.TSQualifiedName;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    left: namedTypes.Identifier | namedTypes.TSQualifiedName;
    loc?: namedTypes.SourceLocation | null;
    right: namedTypes.Identifier | namedTypes.TSQualifiedName;
  }): namedTypes.TSQualifiedName;
}
export interface TSTypeReferenceBuilder {
  (
    typeName: namedTypes.Identifier | namedTypes.TSQualifiedName,
    typeParameters?: namedTypes.TSTypeParameterInstantiation | null
  ): namedTypes.TSTypeReference;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    typeName: namedTypes.Identifier | namedTypes.TSQualifiedName;
    typeParameters?: namedTypes.TSTypeParameterInstantiation | null;
  }): namedTypes.TSTypeReference;
}
export interface TSAsExpressionBuilder {
  (
    expression: namedTypes.Expression,
    typeAnnotation: namedTypes.TSType
  ): namedTypes.TSAsExpression;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    expression: namedTypes.Expression;
    extra?: { parenthesized: boolean } | null;
    loc?: namedTypes.SourceLocation | null;
    typeAnnotation: namedTypes.TSType;
  }): namedTypes.TSAsExpression;
}
export interface TSNonNullExpressionBuilder {
  (expression: namedTypes.Expression): namedTypes.TSNonNullExpression;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    expression: namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSNonNullExpression;
}
export interface TSAnyKeywordBuilder {
  (): namedTypes.TSAnyKeyword;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSAnyKeyword;
}
export interface TSBigIntKeywordBuilder {
  (): namedTypes.TSBigIntKeyword;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSBigIntKeyword;
}
export interface TSBooleanKeywordBuilder {
  (): namedTypes.TSBooleanKeyword;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSBooleanKeyword;
}
export interface TSNeverKeywordBuilder {
  (): namedTypes.TSNeverKeyword;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSNeverKeyword;
}
export interface TSNullKeywordBuilder {
  (): namedTypes.TSNullKeyword;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSNullKeyword;
}
export interface TSNumberKeywordBuilder {
  (): namedTypes.TSNumberKeyword;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSNumberKeyword;
}
export interface TSObjectKeywordBuilder {
  (): namedTypes.TSObjectKeyword;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSObjectKeyword;
}
export interface TSStringKeywordBuilder {
  (): namedTypes.TSStringKeyword;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSStringKeyword;
}
export interface TSSymbolKeywordBuilder {
  (): namedTypes.TSSymbolKeyword;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSSymbolKeyword;
}
export interface TSUndefinedKeywordBuilder {
  (): namedTypes.TSUndefinedKeyword;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSUndefinedKeyword;
}
export interface TSUnknownKeywordBuilder {
  (): namedTypes.TSUnknownKeyword;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSUnknownKeyword;
}
export interface TSVoidKeywordBuilder {
  (): namedTypes.TSVoidKeyword;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSVoidKeyword;
}
export interface TSThisTypeBuilder {
  (): namedTypes.TSThisType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSThisType;
}
export interface TSArrayTypeBuilder {
  (elementType: namedTypes.TSType): namedTypes.TSArrayType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    elementType: namedTypes.TSType;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSArrayType;
}
export interface TSLiteralTypeBuilder {
  (
    literal:
      | namedTypes.NumericLiteral
      | namedTypes.StringLiteral
      | namedTypes.BooleanLiteral
      | namedTypes.TemplateLiteral
      | namedTypes.UnaryExpression
  ): namedTypes.TSLiteralType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    literal:
      | namedTypes.NumericLiteral
      | namedTypes.StringLiteral
      | namedTypes.BooleanLiteral
      | namedTypes.TemplateLiteral
      | namedTypes.UnaryExpression;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSLiteralType;
}
export interface TSUnionTypeBuilder {
  (types: namedTypes.TSType[]): namedTypes.TSUnionType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    types: namedTypes.TSType[];
  }): namedTypes.TSUnionType;
}
export interface TSIntersectionTypeBuilder {
  (types: namedTypes.TSType[]): namedTypes.TSIntersectionType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    types: namedTypes.TSType[];
  }): namedTypes.TSIntersectionType;
}
export interface TSConditionalTypeBuilder {
  (
    checkType: namedTypes.TSType,
    extendsType: namedTypes.TSType,
    trueType: namedTypes.TSType,
    falseType: namedTypes.TSType
  ): namedTypes.TSConditionalType;
  from(params: {
    checkType: namedTypes.TSType;
    comments?: namedTypes.Comment[] | null;
    extendsType: namedTypes.TSType;
    falseType: namedTypes.TSType;
    loc?: namedTypes.SourceLocation | null;
    trueType: namedTypes.TSType;
  }): namedTypes.TSConditionalType;
}
export interface TSInferTypeBuilder {
  (typeParameter: namedTypes.TSTypeParameter): namedTypes.TSInferType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    typeParameter: namedTypes.TSTypeParameter;
  }): namedTypes.TSInferType;
}
export interface TSTypeParameterBuilder {
  (
    name: string,
    constraint?: namedTypes.TSType | undefined,
    defaultParam?: namedTypes.TSType | undefined
  ): namedTypes.TSTypeParameter;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    constraint?: namedTypes.TSType | undefined;
    default?: namedTypes.TSType | undefined;
    loc?: namedTypes.SourceLocation | null;
    name: string;
  }): namedTypes.TSTypeParameter;
}
export interface TSParenthesizedTypeBuilder {
  (typeAnnotation: namedTypes.TSType): namedTypes.TSParenthesizedType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    typeAnnotation: namedTypes.TSType;
  }): namedTypes.TSParenthesizedType;
}
export interface TSFunctionTypeBuilder {
  (
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[]
  ): namedTypes.TSFunctionType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null | undefined;
  }): namedTypes.TSFunctionType;
}
export interface TSConstructorTypeBuilder {
  (
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[]
  ): namedTypes.TSConstructorType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null | undefined;
  }): namedTypes.TSConstructorType;
}
export interface TSDeclareFunctionBuilder {
  (
    id: (namedTypes.Identifier | null) | undefined,
    params: namedTypes.PatternLike[],
    returnType?: namedTypes.TSTypeAnnotation | namedTypes.Noop | null
  ): namedTypes.TSDeclareFunction;
  from(params: {
    async?: boolean;
    comments?: namedTypes.Comment[] | null;
    declare?: boolean;
    generator?: boolean;
    id?: namedTypes.Identifier | null;
    loc?: namedTypes.SourceLocation | null;
    params: namedTypes.PatternLike[];
    returnType?: namedTypes.TSTypeAnnotation | namedTypes.Noop | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null | undefined;
  }): namedTypes.TSDeclareFunction;
}
export interface TSDeclareMethodBuilder {
  (
    key:
      | namedTypes.Identifier
      | namedTypes.StringLiteral
      | namedTypes.NumericLiteral
      | namedTypes.Expression,
    params: namedTypes.PatternLike[],
    returnType?: namedTypes.TSTypeAnnotation | namedTypes.Noop | null
  ): namedTypes.TSDeclareMethod;
  from(params: {
    abstract?: boolean;
    access?: "public" | "private" | "protected" | undefined;
    accessibility?: "public" | "private" | "protected" | undefined;
    async?: boolean;
    comments?: namedTypes.Comment[] | null;
    computed?: boolean;
    decorators?: namedTypes.Decorator[] | null;
    generator?: boolean;
    key:
      | namedTypes.Identifier
      | namedTypes.StringLiteral
      | namedTypes.NumericLiteral
      | namedTypes.Expression;
    kind?: "get" | "set" | "method" | "constructor";
    loc?: namedTypes.SourceLocation | null;
    optional?: boolean;
    params: namedTypes.PatternLike[];
    returnType?: namedTypes.TSTypeAnnotation | namedTypes.Noop | null;
    static?: boolean;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null | undefined;
  }): namedTypes.TSDeclareMethod;
}
export interface TSMappedTypeBuilder {
  (
    typeParameter: namedTypes.TSTypeParameter,
    typeAnnotation?: namedTypes.TSType | null
  ): namedTypes.TSMappedType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    optional?: boolean | "+" | "-";
    readonly?: boolean | "+" | "-";
    typeAnnotation?: namedTypes.TSType | null;
    typeParameter: namedTypes.TSTypeParameter;
  }): namedTypes.TSMappedType;
}
export interface TSTupleTypeBuilder {
  (
    elementTypes: (namedTypes.TSType | namedTypes.TSNamedTupleMember)[]
  ): namedTypes.TSTupleType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    elementTypes: (namedTypes.TSType | namedTypes.TSNamedTupleMember)[];
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSTupleType;
}
export interface TSNamedTupleMemberBuilder {
  (
    label: namedTypes.Identifier,
    elementType: namedTypes.TSType,
    optional?: boolean
  ): namedTypes.TSNamedTupleMember;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    elementType: namedTypes.TSType;
    label: namedTypes.Identifier;
    loc?: namedTypes.SourceLocation | null;
    optional?: boolean;
  }): namedTypes.TSNamedTupleMember;
}
export interface TSRestTypeBuilder {
  (typeAnnotation: namedTypes.TSType): namedTypes.TSRestType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    typeAnnotation: namedTypes.TSType;
  }): namedTypes.TSRestType;
}
export interface TSOptionalTypeBuilder {
  (typeAnnotation: namedTypes.TSType): namedTypes.TSOptionalType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    typeAnnotation: namedTypes.TSType;
  }): namedTypes.TSOptionalType;
}
export interface TSIndexedAccessTypeBuilder {
  (
    objectType: namedTypes.TSType,
    indexType: namedTypes.TSType
  ): namedTypes.TSIndexedAccessType;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    indexType: namedTypes.TSType;
    loc?: namedTypes.SourceLocation | null;
    objectType: namedTypes.TSType;
  }): namedTypes.TSIndexedAccessType;
}
export interface TSTypeOperatorBuilder {
  (operator: string): namedTypes.TSTypeOperator;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    operator: string;
    typeAnnotation: namedTypes.TSType;
  }): namedTypes.TSTypeOperator;
}
export interface TSIndexSignatureBuilder {
  (
    parameters: namedTypes.Identifier[],
    typeAnnotation?: namedTypes.TSTypeAnnotation | null
  ): namedTypes.TSIndexSignature;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    parameters: namedTypes.Identifier[];
    readonly?: boolean;
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
  }): namedTypes.TSIndexSignature;
}
export interface TSPropertySignatureBuilder {
  (
    key: namedTypes.Expression,
    typeAnnotation?: namedTypes.TSTypeAnnotation | null,
    optional?: boolean
  ): namedTypes.TSPropertySignature;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    computed?: boolean;
    initializer?: namedTypes.Expression | null;
    key: namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
    optional?: boolean;
    readonly?: boolean;
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
  }): namedTypes.TSPropertySignature;
}
export interface TSMethodSignatureBuilder {
  (
    key: namedTypes.Expression,
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[],
    typeAnnotation?: namedTypes.TSTypeAnnotation | null
  ): namedTypes.TSMethodSignature;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    computed?: boolean;
    key: namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
    optional?: boolean;
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null | undefined;
  }): namedTypes.TSMethodSignature;
}
export interface TSTypePredicateBuilder {
  (
    parameterName: namedTypes.Identifier | namedTypes.TSThisType,
    typeAnnotation?: namedTypes.TSTypeAnnotation | null,
    asserts?: boolean
  ): namedTypes.TSTypePredicate;
  from(params: {
    asserts?: boolean;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    parameterName: namedTypes.Identifier | namedTypes.TSThisType;
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
  }): namedTypes.TSTypePredicate;
}
export interface TSCallSignatureDeclarationBuilder {
  (
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[],
    typeAnnotation?: namedTypes.TSTypeAnnotation | null
  ): namedTypes.TSCallSignatureDeclaration;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null | undefined;
  }): namedTypes.TSCallSignatureDeclaration;
}
export interface TSConstructSignatureDeclarationBuilder {
  (
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[],
    typeAnnotation?: namedTypes.TSTypeAnnotation | null
  ): namedTypes.TSConstructSignatureDeclaration;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    parameters: (
      | namedTypes.Identifier
      | namedTypes.RestElement
      | namedTypes.ArrayPattern
      | namedTypes.ObjectPattern
    )[];
    typeAnnotation?: namedTypes.TSTypeAnnotation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null | undefined;
  }): namedTypes.TSConstructSignatureDeclaration;
}
export interface TSEnumMemberBuilder {
  (
    id: namedTypes.Identifier | namedTypes.StringLiteral,
    initializer?: namedTypes.Expression | null
  ): namedTypes.TSEnumMember;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    id: namedTypes.Identifier | namedTypes.StringLiteral;
    initializer?: namedTypes.Expression | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSEnumMember;
}
export interface TSTypeQueryBuilder {
  (
    exprName:
      | (namedTypes.Identifier | namedTypes.TSQualifiedName)
      | namedTypes.TSImportType
  ): namedTypes.TSTypeQuery;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    exprName:
      | (namedTypes.Identifier | namedTypes.TSQualifiedName)
      | namedTypes.TSImportType;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSTypeQuery;
}
export interface TSImportTypeBuilder {
  (
    argument: namedTypes.StringLiteral,
    qualifier?:
      | (namedTypes.Identifier | namedTypes.TSQualifiedName)
      | undefined,
    typeParameters?: namedTypes.TSTypeParameterInstantiation | null
  ): namedTypes.TSImportType;
  from(params: {
    argument: namedTypes.StringLiteral;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    qualifier?:
      | (namedTypes.Identifier | namedTypes.TSQualifiedName)
      | undefined;
    typeParameters?: namedTypes.TSTypeParameterInstantiation | null;
  }): namedTypes.TSImportType;
}
export interface TSTypeLiteralBuilder {
  (
    members: (
      | namedTypes.TSCallSignatureDeclaration
      | namedTypes.TSConstructSignatureDeclaration
      | namedTypes.TSIndexSignature
      | namedTypes.TSMethodSignature
      | namedTypes.TSPropertySignature
    )[]
  ): namedTypes.TSTypeLiteral;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    members: (
      | namedTypes.TSCallSignatureDeclaration
      | namedTypes.TSConstructSignatureDeclaration
      | namedTypes.TSIndexSignature
      | namedTypes.TSMethodSignature
      | namedTypes.TSPropertySignature
    )[];
  }): namedTypes.TSTypeLiteral;
}
export interface TSTypeAssertionBuilder {
  (
    typeAnnotation: namedTypes.TSType,
    expression: namedTypes.Expression
  ): namedTypes.TSTypeAssertion;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    expression: namedTypes.Expression;
    extra?: { parenthesized: boolean } | null;
    loc?: namedTypes.SourceLocation | null;
    typeAnnotation: namedTypes.TSType;
  }): namedTypes.TSTypeAssertion;
}
export interface TSEnumDeclarationBuilder {
  (
    id: namedTypes.Identifier,
    members: namedTypes.TSEnumMember[]
  ): namedTypes.TSEnumDeclaration;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    const?: boolean;
    declare?: boolean;
    id: namedTypes.Identifier;
    initializer?: namedTypes.Expression | null;
    loc?: namedTypes.SourceLocation | null;
    members: namedTypes.TSEnumMember[];
  }): namedTypes.TSEnumDeclaration;
}
export interface TSTypeAliasDeclarationBuilder {
  (
    id: namedTypes.Identifier,
    typeAnnotation: namedTypes.TSType
  ): namedTypes.TSTypeAliasDeclaration;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    declare?: boolean;
    id: namedTypes.Identifier;
    loc?: namedTypes.SourceLocation | null;
    typeAnnotation: namedTypes.TSType;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null | undefined;
  }): namedTypes.TSTypeAliasDeclaration;
}
export interface TSModuleBlockBuilder {
  (body: namedTypes.Statement[]): namedTypes.TSModuleBlock;
  from(params: {
    body: namedTypes.Statement[];
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSModuleBlock;
}
export interface TSModuleDeclarationBuilder {
  (
    id:
      | namedTypes.StringLiteral
      | (namedTypes.Identifier | namedTypes.TSQualifiedName),
    body?: namedTypes.TSModuleBlock | namedTypes.TSModuleDeclaration | null
  ): namedTypes.TSModuleDeclaration;
  from(params: {
    body?: namedTypes.TSModuleBlock | namedTypes.TSModuleDeclaration | null;
    comments?: namedTypes.Comment[] | null;
    declare?: boolean;
    global?: boolean;
    id:
      | namedTypes.StringLiteral
      | (namedTypes.Identifier | namedTypes.TSQualifiedName);
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSModuleDeclaration;
}
export interface TSImportEqualsDeclarationBuilder {
  (
    id: namedTypes.Identifier,
    moduleReference:
      | (namedTypes.Identifier | namedTypes.TSQualifiedName)
      | namedTypes.TSExternalModuleReference
  ): namedTypes.TSImportEqualsDeclaration;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    id: namedTypes.Identifier;
    isExport?: boolean;
    loc?: namedTypes.SourceLocation | null;
    moduleReference:
      | (namedTypes.Identifier | namedTypes.TSQualifiedName)
      | namedTypes.TSExternalModuleReference;
  }): namedTypes.TSImportEqualsDeclaration;
}
export interface TSExternalModuleReferenceBuilder {
  (expression: namedTypes.StringLiteral): namedTypes.TSExternalModuleReference;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    expression: namedTypes.StringLiteral;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSExternalModuleReference;
}
export interface TSExportAssignmentBuilder {
  (expression: namedTypes.Expression): namedTypes.TSExportAssignment;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    expression: namedTypes.Expression;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSExportAssignment;
}
export interface TSNamespaceExportDeclarationBuilder {
  (id: namedTypes.Identifier): namedTypes.TSNamespaceExportDeclaration;
  from(params: {
    comments?: namedTypes.Comment[] | null;
    id: namedTypes.Identifier;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSNamespaceExportDeclaration;
}
export interface TSInterfaceBodyBuilder {
  (
    body: (
      | namedTypes.TSCallSignatureDeclaration
      | namedTypes.TSConstructSignatureDeclaration
      | namedTypes.TSIndexSignature
      | namedTypes.TSMethodSignature
      | namedTypes.TSPropertySignature
    )[]
  ): namedTypes.TSInterfaceBody;
  from(params: {
    body: (
      | namedTypes.TSCallSignatureDeclaration
      | namedTypes.TSConstructSignatureDeclaration
      | namedTypes.TSIndexSignature
      | namedTypes.TSMethodSignature
      | namedTypes.TSPropertySignature
    )[];
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
  }): namedTypes.TSInterfaceBody;
}
export interface TSInterfaceDeclarationBuilder {
  (
    id: namedTypes.Identifier | namedTypes.TSQualifiedName,
    body: namedTypes.TSInterfaceBody
  ): namedTypes.TSInterfaceDeclaration;
  from(params: {
    body: namedTypes.TSInterfaceBody;
    comments?: namedTypes.Comment[] | null;
    declare?: boolean;
    extends?: namedTypes.TSExpressionWithTypeArguments[] | null;
    id: namedTypes.Identifier | namedTypes.TSQualifiedName;
    loc?: namedTypes.SourceLocation | null;
    typeParameters?: namedTypes.TSTypeParameterDeclaration | null | undefined;
  }): namedTypes.TSInterfaceDeclaration;
}
export interface TSParameterPropertyBuilder {
  (
    parameter: namedTypes.Identifier | namedTypes.AssignmentPattern
  ): namedTypes.TSParameterProperty;
  from(params: {
    accessibility?: "public" | "private" | "protected" | undefined;
    comments?: namedTypes.Comment[] | null;
    loc?: namedTypes.SourceLocation | null;
    parameter: namedTypes.Identifier | namedTypes.AssignmentPattern;
    readonly?: boolean;
  }): namedTypes.TSParameterProperty;
}
export interface builders {
  awaitExpression: AwaitExpressionBuilder;
  decorator: DecoratorBuilder;
  property: PropertyBuilder;
  methodDefinition: MethodDefinitionBuilder;
  privateName: PrivateNameBuilder;
  identifier: IdentifierBuilder;
  classPrivateProperty: ClassPrivatePropertyBuilder;
  file: FileBuilder;
  program: ProgramBuilder;
  blockStatement: BlockStatementBuilder;
  emptyStatement: EmptyStatementBuilder;
  expressionStatement: ExpressionStatementBuilder;
  ifStatement: IfStatementBuilder;
  labeledStatement: LabeledStatementBuilder;
  breakStatement: BreakStatementBuilder;
  continueStatement: ContinueStatementBuilder;
  withStatement: WithStatementBuilder;
  switchStatement: SwitchStatementBuilder;
  switchCase: SwitchCaseBuilder;
  returnStatement: ReturnStatementBuilder;
  throwStatement: ThrowStatementBuilder;
  tryStatement: TryStatementBuilder;
  catchClause: CatchClauseBuilder;
  whileStatement: WhileStatementBuilder;
  doWhileStatement: DoWhileStatementBuilder;
  forStatement: ForStatementBuilder;
  variableDeclaration: VariableDeclarationBuilder;
  forInStatement: ForInStatementBuilder;
  debuggerStatement: DebuggerStatementBuilder;
  functionDeclaration: FunctionDeclarationBuilder;
  functionExpression: FunctionExpressionBuilder;
  variableDeclarator: VariableDeclaratorBuilder;
  thisExpression: ThisExpressionBuilder;
  arrayExpression: ArrayExpressionBuilder;
  objectExpression: ObjectExpressionBuilder;
  sequenceExpression: SequenceExpressionBuilder;
  unaryExpression: UnaryExpressionBuilder;
  binaryExpression: BinaryExpressionBuilder;
  assignmentExpression: AssignmentExpressionBuilder;
  updateExpression: UpdateExpressionBuilder;
  logicalExpression: LogicalExpressionBuilder;
  conditionalExpression: ConditionalExpressionBuilder;
  newExpression: NewExpressionBuilder;
  callExpression: CallExpressionBuilder;
  memberExpression: MemberExpressionBuilder;
  placeholder: PlaceholderBuilder;
  restElement: RestElementBuilder;
  arrowFunctionExpression: ArrowFunctionExpressionBuilder;
  forOfStatement: ForOfStatementBuilder;
  yieldExpression: YieldExpressionBuilder;
  generatorExpression: GeneratorExpressionBuilder;
  comprehensionBlock: ComprehensionBlockBuilder;
  comprehensionExpression: ComprehensionExpressionBuilder;
  objectProperty: ObjectPropertyBuilder;
  arrayPattern: ArrayPatternBuilder;
  objectPattern: ObjectPatternBuilder;
  spreadElement: SpreadElementBuilder;
  assignmentPattern: AssignmentPatternBuilder;
  classPropertyDefinition: ClassPropertyDefinitionBuilder;
  classProperty: ClassPropertyBuilder;
  classBody: ClassBodyBuilder;
  classDeclaration: ClassDeclarationBuilder;
  classExpression: ClassExpressionBuilder;
  super: SuperBuilder;
  importSpecifier: ImportSpecifierBuilder;
  importDefaultSpecifier: ImportDefaultSpecifierBuilder;
  importNamespaceSpecifier: ImportNamespaceSpecifierBuilder;
  importDeclaration: ImportDeclarationBuilder;
  exportNamedDeclaration: ExportNamedDeclarationBuilder;
  exportSpecifier: ExportSpecifierBuilder;
  exportDefaultDeclaration: ExportDefaultDeclarationBuilder;
  exportAllDeclaration: ExportAllDeclarationBuilder;
  taggedTemplateExpression: TaggedTemplateExpressionBuilder;
  templateLiteral: TemplateLiteralBuilder;
  templateElement: TemplateElementBuilder;
  metaProperty: MetaPropertyBuilder;
  noop: NoopBuilder;
  doExpression: DoExpressionBuilder;
  bindExpression: BindExpressionBuilder;
  parenthesizedExpression: ParenthesizedExpressionBuilder;
  exportNamespaceSpecifier: ExportNamespaceSpecifierBuilder;
  exportDefaultSpecifier: ExportDefaultSpecifierBuilder;
  commentBlock: CommentBlockBuilder;
  commentLine: CommentLineBuilder;
  directive: DirectiveBuilder;
  directiveLiteral: DirectiveLiteralBuilder;
  interpreterDirective: InterpreterDirectiveBuilder;
  stringLiteral: StringLiteralBuilder;
  numericLiteral: NumericLiteralBuilder;
  bigIntLiteral: BigIntLiteralBuilder;
  nullLiteral: NullLiteralBuilder;
  booleanLiteral: BooleanLiteralBuilder;
  regExpLiteral: RegExpLiteralBuilder;
  objectMethod: ObjectMethodBuilder;
  classMethod: ClassMethodBuilder;
  classPrivateMethod: ClassPrivateMethodBuilder;
  forAwaitStatement: ForAwaitStatementBuilder;
  import: ImportBuilder;
  tsTypeAnnotation: TSTypeAnnotationBuilder;
  tsTypeParameterDeclaration: TSTypeParameterDeclarationBuilder;
  tsTypeParameterInstantiation: TSTypeParameterInstantiationBuilder;
  tsExpressionWithTypeArguments: TSExpressionWithTypeArgumentsBuilder;
  tsQualifiedName: TSQualifiedNameBuilder;
  tsTypeReference: TSTypeReferenceBuilder;
  tsAsExpression: TSAsExpressionBuilder;
  tsNonNullExpression: TSNonNullExpressionBuilder;
  tsAnyKeyword: TSAnyKeywordBuilder;
  tsBigIntKeyword: TSBigIntKeywordBuilder;
  tsBooleanKeyword: TSBooleanKeywordBuilder;
  tsNeverKeyword: TSNeverKeywordBuilder;
  tsNullKeyword: TSNullKeywordBuilder;
  tsNumberKeyword: TSNumberKeywordBuilder;
  tsObjectKeyword: TSObjectKeywordBuilder;
  tsStringKeyword: TSStringKeywordBuilder;
  tsSymbolKeyword: TSSymbolKeywordBuilder;
  tsUndefinedKeyword: TSUndefinedKeywordBuilder;
  tsUnknownKeyword: TSUnknownKeywordBuilder;
  tsVoidKeyword: TSVoidKeywordBuilder;
  tsThisType: TSThisTypeBuilder;
  tsArrayType: TSArrayTypeBuilder;
  tsLiteralType: TSLiteralTypeBuilder;
  tsUnionType: TSUnionTypeBuilder;
  tsIntersectionType: TSIntersectionTypeBuilder;
  tsConditionalType: TSConditionalTypeBuilder;
  tsInferType: TSInferTypeBuilder;
  tsTypeParameter: TSTypeParameterBuilder;
  tsParenthesizedType: TSParenthesizedTypeBuilder;
  tsFunctionType: TSFunctionTypeBuilder;
  tsConstructorType: TSConstructorTypeBuilder;
  tsDeclareFunction: TSDeclareFunctionBuilder;
  tsDeclareMethod: TSDeclareMethodBuilder;
  tsMappedType: TSMappedTypeBuilder;
  tsTupleType: TSTupleTypeBuilder;
  tsNamedTupleMember: TSNamedTupleMemberBuilder;
  tsRestType: TSRestTypeBuilder;
  tsOptionalType: TSOptionalTypeBuilder;
  tsIndexedAccessType: TSIndexedAccessTypeBuilder;
  tsTypeOperator: TSTypeOperatorBuilder;
  tsIndexSignature: TSIndexSignatureBuilder;
  tsPropertySignature: TSPropertySignatureBuilder;
  tsMethodSignature: TSMethodSignatureBuilder;
  tsTypePredicate: TSTypePredicateBuilder;
  tsCallSignatureDeclaration: TSCallSignatureDeclarationBuilder;
  tsConstructSignatureDeclaration: TSConstructSignatureDeclarationBuilder;
  tsEnumMember: TSEnumMemberBuilder;
  tsTypeQuery: TSTypeQueryBuilder;
  tsImportType: TSImportTypeBuilder;
  tsTypeLiteral: TSTypeLiteralBuilder;
  tsTypeAssertion: TSTypeAssertionBuilder;
  tsEnumDeclaration: TSEnumDeclarationBuilder;
  tsTypeAliasDeclaration: TSTypeAliasDeclarationBuilder;
  tsModuleBlock: TSModuleBlockBuilder;
  tsModuleDeclaration: TSModuleDeclarationBuilder;
  tsImportEqualsDeclaration: TSImportEqualsDeclarationBuilder;
  tsExternalModuleReference: TSExternalModuleReferenceBuilder;
  tsExportAssignment: TSExportAssignmentBuilder;
  tsNamespaceExportDeclaration: TSNamespaceExportDeclarationBuilder;
  tsInterfaceBody: TSInterfaceBodyBuilder;
  tsInterfaceDeclaration: TSInterfaceDeclarationBuilder;
  tsParameterProperty: TSParameterPropertyBuilder;
  [builderName: string]: any;
}
